# This action runs the Rust checks for the repository.
name: Rust

# This action is triggered for every PR, push to `main`, merge queue, and workflow_dispatch.
on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:
  merge_group:

concurrency:
  group: rust-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  # Not needed in CI, should make things a bit faster
  CARGO_INCREMENTAL: 0
  CARGO_TERM_COLOR: always
  # Prioritise debugging over disk space and build speed
  #RUSTFLAGS: -C strip=symbols
  RUST_BACKTRACE: full

jobs:
  cargo-fmt:
    name: cargo-fmt
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: cargo fmt
        run: cargo fmt --all -- --check

  cargo-clippy:
    name: cargo-clippy
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      # Some clippy checks require a release build
      - name: cargo clippy
        run: |
          cargo clippy --release --locked --all-features --all-targets -- -D warnings

  rust-all:
    # Hack for buggy GitHub Actions behavior with skipped checks:
    # <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/troubleshooting-required-status-checks#handling-skipped-but-required-checks>
    if: ${{ always() }}
    runs-on: ubuntu-24.04
    needs:
      - cargo-fmt
      - cargo-clippy
    steps:
      - name: Check job statuses
        # Another hack is to actually check the status of the dependencies or else it'll fall through
        run: |
          echo "Checking statuses..."
          [[ "${{ needs.cargo-fmt.result }}" == "success" ]] || exit 1
          [[ "${{ needs.cargo-clippy.result }}" == "success" ]] || exit 1
