# [allow (dead_code , unused_imports , non_camel_case_types , unreachable_patterns)] # [allow (clippy :: all)] # [allow (rustdoc :: broken_intra_doc_links)] pub mod api { # [allow (unused_imports)] mod root_mod { pub use super :: * ; } pub static PALLETS : [& str ; 20usize] = ["System" , "Timestamp" , "Subspace" , "Rewards" , "Balances" , "TransactionFees" , "TransactionPayment" , "Utility" , "Domains" , "RuntimeConfigs" , "Mmr" , "SubspaceMmr" , "Messenger" , "Transporter" , "Scheduler" , "Council" , "Democracy" , "Preimage" , "Multisig" , "Sudo" ,] ; pub static RUNTIME_APIS : [& str ; 17usize] = ["Core" , "Metadata" , "BlockBuilder" , "TaggedTransactionQueue" , "OffchainWorkerApi" , "ObjectsApi" , "SubspaceApi" , "DomainsApi" , "BundleProducerElectionApi" , "SessionKeys" , "AccountNonceApi" , "TransactionPaymentApi" , "MessengerApi" , "RelayerApi" , "FraudProofApi" , "MmrApi" , "GenesisBuilder" ,] ; # [doc = r" The error type that is returned when there is a runtime issue."] pub type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [doc = r" The outer event enum."] pub type Event = runtime_types :: subspace_runtime :: RuntimeEvent ; # [doc = r" The outer extrinsic enum."] pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; # [doc = r" The outer error enum represents the DispatchError's Module variant."] pub type Error = runtime_types :: subspace_runtime :: RuntimeError ; pub fn constants () -> ConstantsApi { ConstantsApi } pub fn storage () -> StorageApi { StorageApi } pub fn tx () -> TransactionApi { TransactionApi } pub fn apis () -> runtime_apis :: RuntimeApi { runtime_apis :: RuntimeApi } pub mod runtime_apis { use super :: root_mod ; use super :: runtime_types ; use :: subxt :: ext :: subxt_core :: ext :: codec :: Encode ; pub struct RuntimeApi ; impl RuntimeApi { pub fn core (& self) -> core :: Core { core :: Core } pub fn metadata (& self) -> metadata :: Metadata { metadata :: Metadata } pub fn block_builder (& self) -> block_builder :: BlockBuilder { block_builder :: BlockBuilder } pub fn tagged_transaction_queue (& self) -> tagged_transaction_queue :: TaggedTransactionQueue { tagged_transaction_queue :: TaggedTransactionQueue } pub fn offchain_worker_api (& self) -> offchain_worker_api :: OffchainWorkerApi { offchain_worker_api :: OffchainWorkerApi } pub fn objects_api (& self) -> objects_api :: ObjectsApi { objects_api :: ObjectsApi } pub fn subspace_api (& self) -> subspace_api :: SubspaceApi { subspace_api :: SubspaceApi } pub fn domains_api (& self) -> domains_api :: DomainsApi { domains_api :: DomainsApi } pub fn bundle_producer_election_api (& self) -> bundle_producer_election_api :: BundleProducerElectionApi { bundle_producer_election_api :: BundleProducerElectionApi } pub fn session_keys (& self) -> session_keys :: SessionKeys { session_keys :: SessionKeys } pub fn account_nonce_api (& self) -> account_nonce_api :: AccountNonceApi { account_nonce_api :: AccountNonceApi } pub fn transaction_payment_api (& self) -> transaction_payment_api :: TransactionPaymentApi { transaction_payment_api :: TransactionPaymentApi } pub fn messenger_api (& self) -> messenger_api :: MessengerApi { messenger_api :: MessengerApi } pub fn relayer_api (& self) -> relayer_api :: RelayerApi { relayer_api :: RelayerApi } pub fn fraud_proof_api (& self) -> fraud_proof_api :: FraudProofApi { fraud_proof_api :: FraudProofApi } pub fn mmr_api (& self) -> mmr_api :: MmrApi { mmr_api :: MmrApi } pub fn genesis_builder (& self) -> genesis_builder :: GenesisBuilder { genesis_builder :: GenesisBuilder } } pub mod core { use super :: root_mod ; use super :: runtime_types ; # [doc = " The `Core` runtime api that every Substrate runtime needs to implement."] pub struct Core ; impl Core { # [doc = " Returns the version of the runtime."] pub fn version (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: Version , types :: version :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Core" , "version" , types :: Version { } , [79u8 , 22u8 , 137u8 , 4u8 , 40u8 , 64u8 , 30u8 , 180u8 , 49u8 , 222u8 , 114u8 , 125u8 , 44u8 , 25u8 , 33u8 , 152u8 , 98u8 , 42u8 , 72u8 , 178u8 , 240u8 , 103u8 , 34u8 , 187u8 , 81u8 , 161u8 , 183u8 , 6u8 , 120u8 , 2u8 , 146u8 , 0u8 ,] ,) } # [doc = " Execute the given block."] pub fn execute_block (& self , block : types :: execute_block :: Block ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ExecuteBlock , types :: execute_block :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Core" , "execute_block" , types :: ExecuteBlock { block , } , [133u8 , 135u8 , 228u8 , 65u8 , 106u8 , 27u8 , 85u8 , 158u8 , 112u8 , 254u8 , 93u8 , 26u8 , 102u8 , 201u8 , 118u8 , 216u8 , 249u8 , 247u8 , 91u8 , 74u8 , 56u8 , 208u8 , 231u8 , 115u8 , 131u8 , 29u8 , 209u8 , 6u8 , 65u8 , 57u8 , 214u8 , 125u8 ,] ,) } # [doc = " Initialize a block with the given header and return the runtime executive mode."] pub fn initialize_block (& self , header : types :: initialize_block :: Header ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: InitializeBlock , types :: initialize_block :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Core" , "initialize_block" , types :: InitializeBlock { header , } , [132u8 , 169u8 , 113u8 , 112u8 , 80u8 , 139u8 , 113u8 , 35u8 , 41u8 , 81u8 , 36u8 , 35u8 , 37u8 , 202u8 , 29u8 , 207u8 , 205u8 , 229u8 , 145u8 , 7u8 , 133u8 , 94u8 , 25u8 , 108u8 , 233u8 , 86u8 , 234u8 , 29u8 , 236u8 , 57u8 , 56u8 , 186u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod version { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_version :: RuntimeVersion ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Version { } pub mod execute_block { use super :: runtime_types ; pub type Block = runtime_types :: sp_runtime :: generic :: block :: Block < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > > ; pub mod output { use super :: runtime_types ; pub type Output = () ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExecuteBlock { pub block : execute_block :: Block , } pub mod initialize_block { use super :: runtime_types ; pub type Header = runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_runtime :: ExtrinsicInclusionMode ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InitializeBlock { pub header : initialize_block :: Header , } } } pub mod metadata { use super :: root_mod ; use super :: runtime_types ; # [doc = " The `Metadata` api trait that returns metadata for the runtime."] pub struct Metadata ; impl Metadata { # [doc = " Returns the metadata of a runtime."] pub fn metadata (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: Metadata , types :: metadata :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Metadata" , "metadata" , types :: Metadata { } , [231u8 , 24u8 , 67u8 , 152u8 , 23u8 , 26u8 , 188u8 , 82u8 , 229u8 , 6u8 , 185u8 , 27u8 , 175u8 , 68u8 , 83u8 , 122u8 , 69u8 , 89u8 , 185u8 , 74u8 , 248u8 , 87u8 , 217u8 , 124u8 , 193u8 , 252u8 , 199u8 , 186u8 , 196u8 , 179u8 , 179u8 , 96u8 ,] ,) } # [doc = " Returns the metadata at a given version."] # [doc = ""] # [doc = " If the given `version` isn't supported, this will return `None`."] # [doc = " Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime."] pub fn metadata_at_version (& self , version : types :: metadata_at_version :: Version ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: MetadataAtVersion , types :: metadata_at_version :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Metadata" , "metadata_at_version" , types :: MetadataAtVersion { version , } , [131u8 , 53u8 , 212u8 , 234u8 , 16u8 , 25u8 , 120u8 , 252u8 , 153u8 , 153u8 , 216u8 , 28u8 , 54u8 , 113u8 , 52u8 , 236u8 , 146u8 , 68u8 , 142u8 , 8u8 , 10u8 , 169u8 , 131u8 , 142u8 , 204u8 , 38u8 , 48u8 , 108u8 , 134u8 , 86u8 , 226u8 , 61u8 ,] ,) } # [doc = " Returns the supported metadata versions."] # [doc = ""] # [doc = " This can be used to call `metadata_at_version`."] pub fn metadata_versions (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: MetadataVersions , types :: metadata_versions :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("Metadata" , "metadata_versions" , types :: MetadataVersions { } , [23u8 , 144u8 , 137u8 , 91u8 , 188u8 , 39u8 , 231u8 , 208u8 , 252u8 , 218u8 , 224u8 , 176u8 , 77u8 , 32u8 , 130u8 , 212u8 , 223u8 , 76u8 , 100u8 , 190u8 , 82u8 , 94u8 , 190u8 , 8u8 , 82u8 , 244u8 , 225u8 , 179u8 , 85u8 , 176u8 , 56u8 , 16u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod metadata { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_core :: OpaqueMetadata ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Metadata { } pub mod metadata_at_version { use super :: runtime_types ; pub type Version = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_core :: OpaqueMetadata > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MetadataAtVersion { pub version : metadata_at_version :: Version , } pub mod metadata_versions { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u32 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MetadataVersions { } } } pub mod block_builder { use super :: root_mod ; use super :: runtime_types ; # [doc = " The `BlockBuilder` api trait that provides the required functionality for building a block."] pub struct BlockBuilder ; impl BlockBuilder { # [doc = " Apply the given extrinsic."] # [doc = ""] # [doc = " Returns an inclusion outcome which specifies if this extrinsic is included in"] # [doc = " this block or not."] pub fn apply_extrinsic (& self , extrinsic : types :: apply_extrinsic :: Extrinsic ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ApplyExtrinsic , types :: apply_extrinsic :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BlockBuilder" , "apply_extrinsic" , types :: ApplyExtrinsic { extrinsic , } , [192u8 , 184u8 , 199u8 , 4u8 , 85u8 , 136u8 , 214u8 , 205u8 , 29u8 , 29u8 , 98u8 , 145u8 , 172u8 , 92u8 , 168u8 , 161u8 , 150u8 , 133u8 , 100u8 , 243u8 , 100u8 , 100u8 , 118u8 , 28u8 , 104u8 , 82u8 , 93u8 , 63u8 , 79u8 , 36u8 , 149u8 , 144u8 ,] ,) } # [doc = " Finish the current block."] pub fn finalize_block (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: FinalizeBlock , types :: finalize_block :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BlockBuilder" , "finalize_block" , types :: FinalizeBlock { } , [244u8 , 207u8 , 24u8 , 33u8 , 13u8 , 69u8 , 9u8 , 249u8 , 145u8 , 143u8 , 122u8 , 96u8 , 197u8 , 55u8 , 64u8 , 111u8 , 238u8 , 224u8 , 34u8 , 201u8 , 27u8 , 146u8 , 232u8 , 99u8 , 191u8 , 30u8 , 114u8 , 16u8 , 32u8 , 220u8 , 58u8 , 62u8 ,] ,) } # [doc = " Generate inherent extrinsics. The inherent data will vary from chain to chain."] pub fn inherent_extrinsics (& self , inherent : types :: inherent_extrinsics :: Inherent ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: InherentExtrinsics , types :: inherent_extrinsics :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BlockBuilder" , "inherent_extrinsics" , types :: InherentExtrinsics { inherent , } , [254u8 , 110u8 , 245u8 , 201u8 , 250u8 , 192u8 , 27u8 , 228u8 , 151u8 , 213u8 , 166u8 , 89u8 , 94u8 , 81u8 , 189u8 , 234u8 , 64u8 , 18u8 , 245u8 , 80u8 , 29u8 , 18u8 , 140u8 , 129u8 , 113u8 , 236u8 , 135u8 , 55u8 , 79u8 , 159u8 , 175u8 , 183u8 ,] ,) } # [doc = " Check that the inherents are valid. The inherent data will vary from chain to chain."] pub fn check_inherents (& self , block : types :: check_inherents :: Block , data : types :: check_inherents :: Data ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: CheckInherents , types :: check_inherents :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BlockBuilder" , "check_inherents" , types :: CheckInherents { block , data , } , [153u8 , 134u8 , 1u8 , 215u8 , 139u8 , 11u8 , 53u8 , 51u8 , 210u8 , 175u8 , 197u8 , 28u8 , 38u8 , 209u8 , 175u8 , 247u8 , 142u8 , 157u8 , 50u8 , 151u8 , 164u8 , 191u8 , 181u8 , 118u8 , 80u8 , 97u8 , 160u8 , 248u8 , 110u8 , 217u8 , 181u8 , 234u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod apply_extrinsic { use super :: runtime_types ; pub type Extrinsic = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , runtime_types :: sp_runtime :: transaction_validity :: TransactionValidityError > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ApplyExtrinsic { pub extrinsic : apply_extrinsic :: Extrinsic , } pub mod finalize_block { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FinalizeBlock { } pub mod inherent_extrinsics { use super :: runtime_types ; pub type Inherent = runtime_types :: sp_inherents :: InherentData ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InherentExtrinsics { pub inherent : inherent_extrinsics :: Inherent , } pub mod check_inherents { use super :: runtime_types ; pub type Block = runtime_types :: sp_runtime :: generic :: block :: Block < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > > ; pub type Data = runtime_types :: sp_inherents :: InherentData ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_inherents :: CheckInherentsResult ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckInherents { pub block : check_inherents :: Block , pub data : check_inherents :: Data , } } } pub mod tagged_transaction_queue { use super :: root_mod ; use super :: runtime_types ; # [doc = " The `TaggedTransactionQueue` api trait for interfering with the transaction queue."] pub struct TaggedTransactionQueue ; impl TaggedTransactionQueue { # [doc = " Validate the transaction."] # [doc = ""] # [doc = " This method is invoked by the transaction pool to learn details about given transaction."] # [doc = " The implementation should make sure to verify the correctness of the transaction"] # [doc = " against current state. The given `block_hash` corresponds to the hash of the block"] # [doc = " that is used as current state."] # [doc = ""] # [doc = " Note that this call may be performed by the pool multiple times and transactions"] # [doc = " might be verified in any possible order."] pub fn validate_transaction (& self , source : types :: validate_transaction :: Source , tx : types :: validate_transaction :: Tx , block_hash : types :: validate_transaction :: BlockHash ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ValidateTransaction , types :: validate_transaction :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TaggedTransactionQueue" , "validate_transaction" , types :: ValidateTransaction { source , tx , block_hash , } , [19u8 , 53u8 , 170u8 , 115u8 , 75u8 , 121u8 , 231u8 , 50u8 , 199u8 , 181u8 , 243u8 , 170u8 , 163u8 , 224u8 , 213u8 , 134u8 , 206u8 , 207u8 , 88u8 , 242u8 , 80u8 , 139u8 , 233u8 , 87u8 , 175u8 , 249u8 , 178u8 , 169u8 , 255u8 , 171u8 , 4u8 , 125u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod validate_transaction { use super :: runtime_types ; pub type Source = runtime_types :: sp_runtime :: transaction_validity :: TransactionSource ; pub type Tx = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub type BlockHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < runtime_types :: sp_runtime :: transaction_validity :: ValidTransaction , runtime_types :: sp_runtime :: transaction_validity :: TransactionValidityError > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ValidateTransaction { pub source : validate_transaction :: Source , pub tx : validate_transaction :: Tx , pub block_hash : validate_transaction :: BlockHash , } } } pub mod offchain_worker_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " The offchain worker api."] pub struct OffchainWorkerApi ; impl OffchainWorkerApi { # [doc = " Starts the off-chain task for given block header."] pub fn offchain_worker (& self , header : types :: offchain_worker :: Header ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: OffchainWorker , types :: offchain_worker :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("OffchainWorkerApi" , "offchain_worker" , types :: OffchainWorker { header , } , [10u8 , 135u8 , 19u8 , 153u8 , 33u8 , 216u8 , 18u8 , 242u8 , 33u8 , 140u8 , 4u8 , 223u8 , 200u8 , 130u8 , 103u8 , 118u8 , 137u8 , 24u8 , 19u8 , 127u8 , 161u8 , 29u8 , 184u8 , 111u8 , 222u8 , 111u8 , 253u8 , 73u8 , 45u8 , 31u8 , 79u8 , 60u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod offchain_worker { use super :: runtime_types ; pub type Header = runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > ; pub mod output { use super :: runtime_types ; pub type Output = () ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OffchainWorker { pub header : offchain_worker :: Header , } } } pub mod objects_api { use super :: root_mod ; use super :: runtime_types ; pub struct ObjectsApi ; impl ObjectsApi { # [doc = " Extract block object mapping for a given block"] pub fn extract_block_object_mapping (& self , block : types :: extract_block_object_mapping :: Block ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ExtractBlockObjectMapping , types :: extract_block_object_mapping :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("ObjectsApi" , "extract_block_object_mapping" , types :: ExtractBlockObjectMapping { block , } , [171u8 , 93u8 , 13u8 , 83u8 , 235u8 , 222u8 , 197u8 , 116u8 , 219u8 , 215u8 , 75u8 , 8u8 , 72u8 , 177u8 , 211u8 , 45u8 , 252u8 , 53u8 , 13u8 , 43u8 , 148u8 , 70u8 , 188u8 , 130u8 , 101u8 , 205u8 , 8u8 , 76u8 , 154u8 , 89u8 , 13u8 , 100u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod extract_block_object_mapping { use super :: runtime_types ; pub type Block = runtime_types :: sp_runtime :: generic :: block :: Block < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > > ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: subspace_core_primitives :: objects :: BlockObjectMapping ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExtractBlockObjectMapping { pub block : extract_block_object_mapping :: Block , } } } pub mod subspace_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " API necessary for block authorship with Subspace."] pub struct SubspaceApi ; impl SubspaceApi { # [doc = " Proof of time parameters"] pub fn pot_parameters (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: PotParameters , types :: pot_parameters :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "pot_parameters" , types :: PotParameters { } , [8u8 , 208u8 , 82u8 , 180u8 , 16u8 , 225u8 , 1u8 , 125u8 , 26u8 , 198u8 , 57u8 , 147u8 , 130u8 , 180u8 , 24u8 , 220u8 , 168u8 , 125u8 , 142u8 , 114u8 , 64u8 , 137u8 , 115u8 , 173u8 , 111u8 , 200u8 , 64u8 , 249u8 , 14u8 , 121u8 , 121u8 , 126u8 ,] ,) } # [doc = " Solution ranges."] pub fn solution_ranges (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: SolutionRanges , types :: solution_ranges :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "solution_ranges" , types :: SolutionRanges { } , [201u8 , 139u8 , 168u8 , 49u8 , 85u8 , 79u8 , 197u8 , 4u8 , 37u8 , 191u8 , 43u8 , 141u8 , 46u8 , 34u8 , 196u8 , 132u8 , 116u8 , 207u8 , 85u8 , 22u8 , 44u8 , 38u8 , 229u8 , 67u8 , 204u8 , 146u8 , 136u8 , 101u8 , 175u8 , 220u8 , 127u8 , 27u8 ,] ,) } # [doc = " Submit farmer vote that is essentially a header with bigger solution range than"] # [doc = " acceptable for block authoring. Only useful in an offchain context."] pub fn submit_vote_extrinsic (& self , signed_vote : types :: submit_vote_extrinsic :: SignedVote ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: SubmitVoteExtrinsic , types :: submit_vote_extrinsic :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "submit_vote_extrinsic" , types :: SubmitVoteExtrinsic { signed_vote , } , [198u8 , 136u8 , 136u8 , 86u8 , 144u8 , 124u8 , 206u8 , 27u8 , 2u8 , 153u8 , 25u8 , 223u8 , 2u8 , 14u8 , 110u8 , 164u8 , 175u8 , 97u8 , 218u8 , 175u8 , 232u8 , 155u8 , 45u8 , 102u8 , 185u8 , 72u8 , 144u8 , 111u8 , 86u8 , 42u8 , 170u8 , 155u8 ,] ,) } # [doc = " Size of the blockchain history"] pub fn history_size (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: HistorySize , types :: history_size :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "history_size" , types :: HistorySize { } , [125u8 , 195u8 , 112u8 , 121u8 , 251u8 , 184u8 , 200u8 , 19u8 , 148u8 , 114u8 , 239u8 , 152u8 , 161u8 , 36u8 , 5u8 , 195u8 , 201u8 , 201u8 , 20u8 , 101u8 , 159u8 , 97u8 , 216u8 , 244u8 , 169u8 , 194u8 , 2u8 , 220u8 , 197u8 , 91u8 , 227u8 , 157u8 ,] ,) } # [doc = " How many pieces one sector is supposed to contain (max)"] pub fn max_pieces_in_sector (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: MaxPiecesInSector , types :: max_pieces_in_sector :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "max_pieces_in_sector" , types :: MaxPiecesInSector { } , [82u8 , 131u8 , 179u8 , 166u8 , 163u8 , 75u8 , 99u8 , 189u8 , 141u8 , 72u8 , 105u8 , 18u8 , 173u8 , 60u8 , 43u8 , 240u8 , 235u8 , 225u8 , 110u8 , 102u8 , 204u8 , 226u8 , 112u8 , 218u8 , 194u8 , 63u8 , 206u8 , 105u8 , 228u8 , 157u8 , 21u8 , 142u8 ,] ,) } # [doc = " Get the segment commitment of records for specified segment index"] pub fn segment_commitment (& self , segment_index : types :: segment_commitment :: SegmentIndex ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: SegmentCommitment , types :: segment_commitment :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "segment_commitment" , types :: SegmentCommitment { segment_index , } , [70u8 , 173u8 , 246u8 , 33u8 , 38u8 , 140u8 , 145u8 , 191u8 , 235u8 , 176u8 , 241u8 , 90u8 , 94u8 , 212u8 , 81u8 , 0u8 , 132u8 , 31u8 , 94u8 , 213u8 , 139u8 , 186u8 , 144u8 , 59u8 , 118u8 , 121u8 , 193u8 , 193u8 , 183u8 , 117u8 , 91u8 , 99u8 ,] ,) } # [doc = " Returns `Vec<SegmentHeader>` if a given extrinsic has them."] pub fn extract_segment_headers (& self , ext : types :: extract_segment_headers :: Ext ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ExtractSegmentHeaders , types :: extract_segment_headers :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "extract_segment_headers" , types :: ExtractSegmentHeaders { ext , } , [145u8 , 44u8 , 203u8 , 182u8 , 123u8 , 213u8 , 182u8 , 171u8 , 153u8 , 175u8 , 150u8 , 217u8 , 77u8 , 64u8 , 113u8 , 33u8 , 114u8 , 15u8 , 245u8 , 112u8 , 154u8 , 182u8 , 69u8 , 247u8 , 115u8 , 223u8 , 6u8 , 215u8 , 254u8 , 44u8 , 182u8 , 55u8 ,] ,) } # [doc = " Checks if the extrinsic is an inherent."] pub fn is_inherent (& self , ext : types :: is_inherent :: Ext ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: IsInherent , types :: is_inherent :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "is_inherent" , types :: IsInherent { ext , } , [87u8 , 239u8 , 150u8 , 117u8 , 113u8 , 114u8 , 213u8 , 113u8 , 103u8 , 212u8 , 0u8 , 92u8 , 163u8 , 106u8 , 132u8 , 245u8 , 89u8 , 241u8 , 150u8 , 249u8 , 144u8 , 200u8 , 204u8 , 158u8 , 174u8 , 54u8 , 37u8 , 249u8 , 191u8 , 128u8 , 237u8 , 202u8 ,] ,) } # [doc = " Returns root plot public key in case block authoring is restricted."] pub fn root_plot_public_key (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: RootPlotPublicKey , types :: root_plot_public_key :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "root_plot_public_key" , types :: RootPlotPublicKey { } , [210u8 , 209u8 , 134u8 , 39u8 , 212u8 , 85u8 , 100u8 , 230u8 , 166u8 , 41u8 , 82u8 , 97u8 , 71u8 , 108u8 , 235u8 , 232u8 , 61u8 , 219u8 , 138u8 , 21u8 , 79u8 , 110u8 , 117u8 , 226u8 , 160u8 , 18u8 , 147u8 , 195u8 , 34u8 , 34u8 , 47u8 , 161u8 ,] ,) } # [doc = " Whether solution range adjustment is enabled."] pub fn should_adjust_solution_range (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ShouldAdjustSolutionRange , types :: should_adjust_solution_range :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "should_adjust_solution_range" , types :: ShouldAdjustSolutionRange { } , [26u8 , 191u8 , 47u8 , 253u8 , 100u8 , 80u8 , 110u8 , 212u8 , 209u8 , 134u8 , 10u8 , 51u8 , 178u8 , 242u8 , 174u8 , 54u8 , 201u8 , 194u8 , 155u8 , 196u8 , 83u8 , 95u8 , 29u8 , 170u8 , 150u8 , 64u8 , 221u8 , 214u8 , 190u8 , 193u8 , 167u8 , 184u8 ,] ,) } # [doc = " Get Subspace blockchain constants"] pub fn chain_constants (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ChainConstants , types :: chain_constants :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SubspaceApi" , "chain_constants" , types :: ChainConstants { } , [90u8 , 66u8 , 77u8 , 18u8 , 23u8 , 249u8 , 141u8 , 100u8 , 65u8 , 114u8 , 56u8 , 126u8 , 1u8 , 162u8 , 143u8 , 185u8 , 190u8 , 63u8 , 1u8 , 107u8 , 61u8 , 74u8 , 245u8 , 65u8 , 121u8 , 101u8 , 1u8 , 115u8 , 24u8 , 148u8 , 202u8 , 231u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod pot_parameters { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_consensus_subspace :: PotParameters ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PotParameters { } pub mod solution_ranges { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_consensus_subspace :: SolutionRanges ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SolutionRanges { } pub mod submit_vote_extrinsic { use super :: runtime_types ; pub type SignedVote = runtime_types :: sp_consensus_subspace :: SignedVote < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: subspace_core_primitives :: PublicKey > ; pub mod output { use super :: runtime_types ; pub type Output = () ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubmitVoteExtrinsic { pub signed_vote : submit_vote_extrinsic :: SignedVote , } pub mod history_size { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: subspace_core_primitives :: segments :: HistorySize ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct HistorySize { } pub mod max_pieces_in_sector { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u16 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MaxPiecesInSector { } pub mod segment_commitment { use super :: runtime_types ; pub type SegmentIndex = runtime_types :: subspace_core_primitives :: segments :: SegmentIndex ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: subspace_core_primitives :: segments :: SegmentCommitment > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SegmentCommitment { pub segment_index : segment_commitment :: SegmentIndex , } pub mod extract_segment_headers { use super :: runtime_types ; pub type Ext = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_core_primitives :: segments :: SegmentHeader > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExtractSegmentHeaders { pub ext : extract_segment_headers :: Ext , } pub mod is_inherent { use super :: runtime_types ; pub type Ext = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: bool ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct IsInherent { pub ext : is_inherent :: Ext , } pub mod root_plot_public_key { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: subspace_core_primitives :: PublicKey > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RootPlotPublicKey { } pub mod should_adjust_solution_range { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: bool ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ShouldAdjustSolutionRange { } pub mod chain_constants { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_consensus_subspace :: ChainConstants ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChainConstants { } } } pub mod domains_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " APIs used to access the domains pallet."] pub struct DomainsApi ; impl DomainsApi { # [doc = " Submits the transaction bundle via an unsigned extrinsic."] pub fn submit_bundle_unsigned (& self , opaque_bundle : types :: submit_bundle_unsigned :: OpaqueBundle ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: SubmitBundleUnsigned , types :: submit_bundle_unsigned :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "submit_bundle_unsigned" , types :: SubmitBundleUnsigned { opaque_bundle , } , [63u8 , 248u8 , 83u8 , 244u8 , 214u8 , 79u8 , 160u8 , 192u8 , 1u8 , 64u8 , 5u8 , 90u8 , 137u8 , 221u8 , 121u8 , 10u8 , 185u8 , 240u8 , 10u8 , 59u8 , 78u8 , 241u8 , 10u8 , 204u8 , 39u8 , 243u8 , 24u8 , 197u8 , 88u8 , 22u8 , 97u8 , 123u8 ,] ,) } pub fn submit_receipt_unsigned (& self , singleton_receipt : types :: submit_receipt_unsigned :: SingletonReceipt ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: SubmitReceiptUnsigned , types :: submit_receipt_unsigned :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "submit_receipt_unsigned" , types :: SubmitReceiptUnsigned { singleton_receipt , } , [124u8 , 33u8 , 4u8 , 219u8 , 117u8 , 163u8 , 237u8 , 89u8 , 8u8 , 142u8 , 16u8 , 93u8 , 13u8 , 25u8 , 82u8 , 39u8 , 104u8 , 159u8 , 65u8 , 138u8 , 78u8 , 171u8 , 214u8 , 15u8 , 215u8 , 177u8 , 49u8 , 236u8 , 240u8 , 208u8 , 239u8 , 8u8 ,] ,) } # [doc = " Extracts the bundles successfully stored from the given extrinsics."] pub fn extract_successful_bundles (& self , domain_id : types :: extract_successful_bundles :: DomainId , extrinsics : types :: extract_successful_bundles :: Extrinsics ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ExtractSuccessfulBundles , types :: extract_successful_bundles :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "extract_successful_bundles" , types :: ExtractSuccessfulBundles { domain_id , extrinsics , } , [238u8 , 71u8 , 133u8 , 81u8 , 107u8 , 38u8 , 240u8 , 215u8 , 34u8 , 47u8 , 222u8 , 134u8 , 196u8 , 221u8 , 69u8 , 75u8 , 1u8 , 35u8 , 255u8 , 94u8 , 18u8 , 34u8 , 149u8 , 219u8 , 159u8 , 28u8 , 137u8 , 55u8 , 130u8 , 50u8 , 188u8 , 245u8 ,] ,) } # [doc = " Generates a randomness seed for extrinsics shuffling."] pub fn extrinsics_shuffling_seed (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ExtrinsicsShufflingSeed , types :: extrinsics_shuffling_seed :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "extrinsics_shuffling_seed" , types :: ExtrinsicsShufflingSeed { } , [48u8 , 176u8 , 100u8 , 33u8 , 225u8 , 252u8 , 5u8 , 248u8 , 188u8 , 209u8 , 24u8 , 54u8 , 112u8 , 12u8 , 141u8 , 123u8 , 143u8 , 98u8 , 121u8 , 88u8 , 74u8 , 179u8 , 110u8 , 139u8 , 21u8 , 77u8 , 89u8 , 14u8 , 149u8 , 66u8 , 42u8 , 253u8 ,] ,) } # [doc = " Returns the current WASM bundle for the given `domain_id`."] pub fn domain_runtime_code (& self , domain_id : types :: domain_runtime_code :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainRuntimeCode , types :: domain_runtime_code :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "domain_runtime_code" , types :: DomainRuntimeCode { domain_id , } , [165u8 , 239u8 , 143u8 , 72u8 , 134u8 , 121u8 , 168u8 , 255u8 , 197u8 , 200u8 , 200u8 , 88u8 , 37u8 , 98u8 , 151u8 , 90u8 , 35u8 , 90u8 , 215u8 , 87u8 , 202u8 , 174u8 , 248u8 , 77u8 , 160u8 , 160u8 , 106u8 , 225u8 , 121u8 , 211u8 , 80u8 , 42u8 ,] ,) } # [doc = " Returns the runtime id for the given `domain_id`."] pub fn runtime_id (& self , domain_id : types :: runtime_id :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: RuntimeId , types :: runtime_id :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "runtime_id" , types :: RuntimeId { domain_id , } , [11u8 , 172u8 , 234u8 , 30u8 , 75u8 , 83u8 , 232u8 , 200u8 , 79u8 , 98u8 , 243u8 , 244u8 , 113u8 , 18u8 , 208u8 , 70u8 , 17u8 , 210u8 , 104u8 , 136u8 , 21u8 , 225u8 , 54u8 , 77u8 , 72u8 , 238u8 , 229u8 , 114u8 , 19u8 , 142u8 , 50u8 , 132u8 ,] ,) } # [doc = " Returns the list of runtime upgrades in the current block."] # [doc = " Only present in API versions 2 and later."] pub fn runtime_upgrades (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: RuntimeUpgrades , types :: runtime_upgrades :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "runtime_upgrades" , types :: RuntimeUpgrades { } , [30u8 , 205u8 , 31u8 , 114u8 , 184u8 , 19u8 , 254u8 , 4u8 , 253u8 , 223u8 , 55u8 , 30u8 , 111u8 , 198u8 , 151u8 , 123u8 , 97u8 , 66u8 , 28u8 , 250u8 , 101u8 , 94u8 , 211u8 , 235u8 , 204u8 , 111u8 , 191u8 , 92u8 , 41u8 , 218u8 , 152u8 , 138u8 ,] ,) } # [doc = " Returns the domain instance data for the given `domain_id`."] pub fn domain_instance_data (& self , domain_id : types :: domain_instance_data :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainInstanceData , types :: domain_instance_data :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "domain_instance_data" , types :: DomainInstanceData { domain_id , } , [171u8 , 77u8 , 212u8 , 58u8 , 153u8 , 86u8 , 74u8 , 238u8 , 180u8 , 221u8 , 4u8 , 39u8 , 62u8 , 226u8 , 143u8 , 255u8 , 130u8 , 106u8 , 244u8 , 218u8 , 181u8 , 16u8 , 35u8 , 41u8 , 14u8 , 153u8 , 143u8 , 186u8 , 211u8 , 60u8 , 189u8 , 181u8 ,] ,) } # [doc = " Returns the current timestamp at the current height."] pub fn domain_timestamp (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainTimestamp , types :: domain_timestamp :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "domain_timestamp" , types :: DomainTimestamp { } , [71u8 , 100u8 , 179u8 , 194u8 , 123u8 , 253u8 , 147u8 , 210u8 , 203u8 , 181u8 , 235u8 , 151u8 , 52u8 , 170u8 , 249u8 , 7u8 , 64u8 , 85u8 , 34u8 , 84u8 , 217u8 , 49u8 , 17u8 , 202u8 , 212u8 , 122u8 , 7u8 , 19u8 , 234u8 , 79u8 , 117u8 , 61u8 ,] ,) } # [doc = " Returns the current timestamp at the current height."] pub fn timestamp (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: Timestamp , types :: timestamp :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "timestamp" , types :: Timestamp { } , [128u8 , 88u8 , 98u8 , 77u8 , 220u8 , 71u8 , 8u8 , 211u8 , 136u8 , 243u8 , 50u8 , 109u8 , 24u8 , 97u8 , 106u8 , 174u8 , 236u8 , 45u8 , 199u8 , 124u8 , 81u8 , 188u8 , 151u8 , 95u8 , 78u8 , 70u8 , 225u8 , 23u8 , 233u8 , 102u8 , 99u8 , 171u8 ,] ,) } # [doc = " Returns the consensus transaction byte fee that will used to charge the domain"] # [doc = " transaction for consensus chain storage fees."] pub fn consensus_transaction_byte_fee (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ConsensusTransactionByteFee , types :: consensus_transaction_byte_fee :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "consensus_transaction_byte_fee" , types :: ConsensusTransactionByteFee { } , [220u8 , 205u8 , 128u8 , 51u8 , 153u8 , 140u8 , 137u8 , 216u8 , 48u8 , 116u8 , 17u8 , 52u8 , 138u8 , 133u8 , 85u8 , 192u8 , 183u8 , 66u8 , 193u8 , 78u8 , 163u8 , 168u8 , 119u8 , 53u8 , 146u8 , 78u8 , 4u8 , 149u8 , 6u8 , 205u8 , 199u8 , 13u8 ,] ,) } # [doc = " Returns the consensus chain byte fee that will used to charge the domain transaction"] # [doc = " for consensus chain storage fees."] pub fn consensus_chain_byte_fee (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ConsensusChainByteFee , types :: consensus_chain_byte_fee :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "consensus_chain_byte_fee" , types :: ConsensusChainByteFee { } , [46u8 , 207u8 , 115u8 , 194u8 , 191u8 , 255u8 , 243u8 , 2u8 , 85u8 , 198u8 , 125u8 , 80u8 , 22u8 , 199u8 , 177u8 , 5u8 , 187u8 , 45u8 , 193u8 , 169u8 , 173u8 , 158u8 , 56u8 , 74u8 , 128u8 , 176u8 , 65u8 , 52u8 , 74u8 , 90u8 , 224u8 , 81u8 ,] ,) } # [doc = " Returns the current Tx range for the given domain Id."] pub fn domain_tx_range (& self , domain_id : types :: domain_tx_range :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainTxRange , types :: domain_tx_range :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "domain_tx_range" , types :: DomainTxRange { domain_id , } , [21u8 , 58u8 , 108u8 , 175u8 , 1u8 , 23u8 , 179u8 , 138u8 , 153u8 , 207u8 , 210u8 , 103u8 , 205u8 , 27u8 , 44u8 , 252u8 , 31u8 , 19u8 , 141u8 , 151u8 , 208u8 , 45u8 , 50u8 , 226u8 , 138u8 , 29u8 , 37u8 , 125u8 , 191u8 , 232u8 , 214u8 , 72u8 ,] ,) } # [doc = " Returns the genesis state root if not pruned."] pub fn genesis_state_root (& self , domain_id : types :: genesis_state_root :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GenesisStateRoot , types :: genesis_state_root :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "genesis_state_root" , types :: GenesisStateRoot { domain_id , } , [130u8 , 119u8 , 163u8 , 35u8 , 242u8 , 6u8 , 46u8 , 170u8 , 212u8 , 13u8 , 141u8 , 88u8 , 118u8 , 248u8 , 21u8 , 37u8 , 83u8 , 201u8 , 34u8 , 96u8 , 95u8 , 165u8 , 66u8 , 238u8 , 205u8 , 200u8 , 195u8 , 197u8 , 217u8 , 81u8 , 146u8 , 74u8 ,] ,) } # [doc = " Returns the best execution chain number."] pub fn head_receipt_number (& self , domain_id : types :: head_receipt_number :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: HeadReceiptNumber , types :: head_receipt_number :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "head_receipt_number" , types :: HeadReceiptNumber { domain_id , } , [82u8 , 66u8 , 174u8 , 7u8 , 37u8 , 171u8 , 94u8 , 92u8 , 57u8 , 209u8 , 55u8 , 18u8 , 202u8 , 121u8 , 223u8 , 205u8 , 50u8 , 31u8 , 22u8 , 56u8 , 143u8 , 153u8 , 176u8 , 231u8 , 74u8 , 31u8 , 141u8 , 118u8 , 158u8 , 213u8 , 212u8 , 62u8 ,] ,) } # [doc = " Returns the block number of oldest unconfirmed execution receipt."] pub fn oldest_unconfirmed_receipt_number (& self , domain_id : types :: oldest_unconfirmed_receipt_number :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: OldestUnconfirmedReceiptNumber , types :: oldest_unconfirmed_receipt_number :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "oldest_unconfirmed_receipt_number" , types :: OldestUnconfirmedReceiptNumber { domain_id , } , [197u8 , 138u8 , 14u8 , 203u8 , 112u8 , 124u8 , 39u8 , 5u8 , 12u8 , 78u8 , 73u8 , 134u8 , 125u8 , 128u8 , 31u8 , 180u8 , 77u8 , 31u8 , 165u8 , 31u8 , 53u8 , 125u8 , 150u8 , 224u8 , 88u8 , 217u8 , 115u8 , 27u8 , 127u8 , 47u8 , 8u8 , 18u8 ,] ,) } # [doc = " Returns the domain bundle limit of the given domain."] pub fn domain_bundle_limit (& self , domain_id : types :: domain_bundle_limit :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainBundleLimit , types :: domain_bundle_limit :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "domain_bundle_limit" , types :: DomainBundleLimit { domain_id , } , [91u8 , 169u8 , 93u8 , 177u8 , 52u8 , 202u8 , 225u8 , 160u8 , 71u8 , 58u8 , 11u8 , 58u8 , 61u8 , 129u8 , 66u8 , 59u8 , 139u8 , 25u8 , 112u8 , 57u8 , 11u8 , 63u8 , 238u8 , 104u8 , 241u8 , 231u8 , 236u8 , 183u8 , 101u8 , 114u8 , 64u8 , 24u8 ,] ,) } # [doc = " Returns true if there are any ERs in the challenge period with non empty extrinsics."] pub fn non_empty_er_exists (& self , domain_id : types :: non_empty_er_exists :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: NonEmptyErExists , types :: non_empty_er_exists :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "non_empty_er_exists" , types :: NonEmptyErExists { domain_id , } , [20u8 , 121u8 , 29u8 , 161u8 , 228u8 , 13u8 , 28u8 , 220u8 , 99u8 , 19u8 , 14u8 , 116u8 , 168u8 , 77u8 , 153u8 , 176u8 , 131u8 , 20u8 , 34u8 , 149u8 , 123u8 , 188u8 , 247u8 , 165u8 , 254u8 , 203u8 , 241u8 , 146u8 , 54u8 , 32u8 , 144u8 , 104u8 ,] ,) } # [doc = " Returns the current best block number for the domain."] pub fn domain_best_number (& self , domain_id : types :: domain_best_number :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainBestNumber , types :: domain_best_number :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "domain_best_number" , types :: DomainBestNumber { domain_id , } , [58u8 , 231u8 , 116u8 , 107u8 , 22u8 , 167u8 , 79u8 , 88u8 , 120u8 , 224u8 , 191u8 , 129u8 , 143u8 , 47u8 , 26u8 , 220u8 , 147u8 , 219u8 , 179u8 , 9u8 , 153u8 , 106u8 , 244u8 , 170u8 , 146u8 , 51u8 , 8u8 , 107u8 , 153u8 , 250u8 , 42u8 , 164u8 ,] ,) } # [doc = " Returns the execution receipt with the given hash."] pub fn execution_receipt (& self , receipt_hash : types :: execution_receipt :: ReceiptHash ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ExecutionReceipt , types :: execution_receipt :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "execution_receipt" , types :: ExecutionReceipt { receipt_hash , } , [165u8 , 152u8 , 253u8 , 253u8 , 149u8 , 177u8 , 247u8 , 247u8 , 211u8 , 229u8 , 137u8 , 148u8 , 226u8 , 109u8 , 176u8 , 66u8 , 68u8 , 123u8 , 0u8 , 169u8 , 249u8 , 92u8 , 66u8 , 244u8 , 40u8 , 18u8 , 139u8 , 85u8 , 33u8 , 242u8 , 132u8 , 197u8 ,] ,) } # [doc = " Returns the current epoch and the next epoch operators of the given domain."] pub fn domain_operators (& self , domain_id : types :: domain_operators :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainOperators , types :: domain_operators :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "domain_operators" , types :: DomainOperators { domain_id , } , [99u8 , 192u8 , 90u8 , 103u8 , 179u8 , 190u8 , 36u8 , 149u8 , 250u8 , 67u8 , 68u8 , 201u8 , 106u8 , 154u8 , 181u8 , 4u8 , 176u8 , 100u8 , 235u8 , 251u8 , 130u8 , 28u8 , 251u8 , 230u8 , 174u8 , 219u8 , 219u8 , 27u8 , 230u8 , 28u8 , 114u8 , 70u8 ,] ,) } # [doc = " Returns the execution receipt hash of the given domain and domain block number."] pub fn receipt_hash (& self , domain_id : types :: receipt_hash :: DomainId , domain_number : types :: receipt_hash :: DomainNumber ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ReceiptHash , types :: receipt_hash :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "receipt_hash" , types :: ReceiptHash { domain_id , domain_number , } , [208u8 , 227u8 , 223u8 , 142u8 , 56u8 , 164u8 , 162u8 , 109u8 , 28u8 , 179u8 , 61u8 , 198u8 , 163u8 , 63u8 , 160u8 , 28u8 , 242u8 , 156u8 , 57u8 , 60u8 , 179u8 , 168u8 , 231u8 , 231u8 , 202u8 , 216u8 , 197u8 , 176u8 , 111u8 , 48u8 , 237u8 , 18u8 ,] ,) } # [doc = " Returns the latest confirmed domain block number and hash."] pub fn latest_confirmed_domain_block (& self , domain_id : types :: latest_confirmed_domain_block :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: LatestConfirmedDomainBlock , types :: latest_confirmed_domain_block :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "latest_confirmed_domain_block" , types :: LatestConfirmedDomainBlock { domain_id , } , [132u8 , 64u8 , 115u8 , 148u8 , 233u8 , 98u8 , 23u8 , 80u8 , 147u8 , 188u8 , 142u8 , 245u8 , 183u8 , 251u8 , 194u8 , 167u8 , 65u8 , 142u8 , 94u8 , 214u8 , 27u8 , 4u8 , 17u8 , 134u8 , 32u8 , 129u8 , 197u8 , 68u8 , 67u8 , 64u8 , 49u8 , 136u8 ,] ,) } # [doc = " Returns true if the receipt exists and is going to be pruned"] pub fn is_bad_er_pending_to_prune (& self , domain_id : types :: is_bad_er_pending_to_prune :: DomainId , receipt_hash : types :: is_bad_er_pending_to_prune :: ReceiptHash ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: IsBadErPendingToPrune , types :: is_bad_er_pending_to_prune :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "is_bad_er_pending_to_prune" , types :: IsBadErPendingToPrune { domain_id , receipt_hash , } , [176u8 , 32u8 , 178u8 , 92u8 , 231u8 , 161u8 , 84u8 , 189u8 , 128u8 , 241u8 , 221u8 , 208u8 , 15u8 , 213u8 , 101u8 , 49u8 , 125u8 , 46u8 , 19u8 , 207u8 , 75u8 , 137u8 , 69u8 , 203u8 , 144u8 , 182u8 , 124u8 , 252u8 , 46u8 , 112u8 , 194u8 , 132u8 ,] ,) } # [doc = " Returns the balance of the storage fund account."] pub fn storage_fund_account_balance (& self , operator_id : types :: storage_fund_account_balance :: OperatorId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: StorageFundAccountBalance , types :: storage_fund_account_balance :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "storage_fund_account_balance" , types :: StorageFundAccountBalance { operator_id , } , [87u8 , 69u8 , 61u8 , 56u8 , 213u8 , 22u8 , 232u8 , 140u8 , 180u8 , 63u8 , 139u8 , 235u8 , 33u8 , 240u8 , 160u8 , 52u8 , 98u8 , 91u8 , 175u8 , 188u8 , 134u8 , 220u8 , 28u8 , 234u8 , 71u8 , 246u8 , 80u8 , 222u8 , 76u8 , 62u8 , 16u8 , 243u8 ,] ,) } # [doc = " Returns true if the given domain's runtime code has been upgraded since `at`."] pub fn is_domain_runtime_upgraded_since (& self , domain_id : types :: is_domain_runtime_upgraded_since :: DomainId , at : types :: is_domain_runtime_upgraded_since :: At ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: IsDomainRuntimeUpgradedSince , types :: is_domain_runtime_upgraded_since :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "is_domain_runtime_upgraded_since" , types :: IsDomainRuntimeUpgradedSince { domain_id , at , } , [236u8 , 191u8 , 145u8 , 123u8 , 226u8 , 104u8 , 2u8 , 179u8 , 3u8 , 184u8 , 135u8 , 210u8 , 240u8 , 242u8 , 153u8 , 42u8 , 208u8 , 102u8 , 85u8 , 180u8 , 171u8 , 35u8 , 90u8 , 57u8 , 56u8 , 124u8 , 87u8 , 56u8 , 210u8 , 80u8 , 3u8 , 2u8 ,] ,) } # [doc = " Returns the domain sudo call for the given domain, if any."] pub fn domain_sudo_call (& self , domain_id : types :: domain_sudo_call :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainSudoCall , types :: domain_sudo_call :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "domain_sudo_call" , types :: DomainSudoCall { domain_id , } , [150u8 , 249u8 , 32u8 , 250u8 , 136u8 , 122u8 , 47u8 , 244u8 , 102u8 , 41u8 , 149u8 , 237u8 , 19u8 , 127u8 , 252u8 , 14u8 , 202u8 , 196u8 , 124u8 , 55u8 , 99u8 , 49u8 , 172u8 , 236u8 , 97u8 , 227u8 , 197u8 , 100u8 , 110u8 , 202u8 , 33u8 , 236u8 ,] ,) } # [doc = " Returns the \"set contract creation allowed by\" call for the given EVM domain, if any."] # [doc = " Only present in API versions 4 and later."] pub fn evm_domain_contract_creation_allowed_by_call (& self , domain_id : types :: evm_domain_contract_creation_allowed_by_call :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: EvmDomainContractCreationAllowedByCall , types :: evm_domain_contract_creation_allowed_by_call :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "evm_domain_contract_creation_allowed_by_call" , types :: EvmDomainContractCreationAllowedByCall { domain_id , } , [150u8 , 41u8 , 79u8 , 240u8 , 63u8 , 152u8 , 33u8 , 25u8 , 149u8 , 115u8 , 45u8 , 0u8 , 148u8 , 232u8 , 118u8 , 72u8 , 172u8 , 63u8 , 166u8 , 163u8 , 70u8 , 176u8 , 182u8 , 212u8 , 163u8 , 255u8 , 110u8 , 179u8 , 10u8 , 117u8 , 133u8 , 62u8 ,] ,) } # [doc = " Returns the last confirmed domain block execution receipt."] pub fn last_confirmed_domain_block_receipt (& self , domain_id : types :: last_confirmed_domain_block_receipt :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: LastConfirmedDomainBlockReceipt , types :: last_confirmed_domain_block_receipt :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "last_confirmed_domain_block_receipt" , types :: LastConfirmedDomainBlockReceipt { domain_id , } , [73u8 , 167u8 , 200u8 , 247u8 , 31u8 , 36u8 , 159u8 , 134u8 , 67u8 , 123u8 , 108u8 , 232u8 , 81u8 , 19u8 , 20u8 , 215u8 , 251u8 , 139u8 , 185u8 , 181u8 , 252u8 , 229u8 , 72u8 , 80u8 , 223u8 , 36u8 , 200u8 , 20u8 , 235u8 , 28u8 , 171u8 , 44u8 ,] ,) } # [doc = " Returns the complete nominator position for a given operator and account."] # [doc = ""] # [doc = " This calculates the total position including:"] # [doc = " - Current stake value (converted from shares using current share price)"] # [doc = " - Total storage fee deposits (known + pending)"] # [doc = " - Pending deposits (not yet converted to shares)"] # [doc = " - Pending withdrawals (with unlock timing)"] # [doc = ""] # [doc = " Only present in API versions 5 and later."] pub fn nominator_position (& self , operator_id : types :: nominator_position :: OperatorId , nominator_account : types :: nominator_position :: NominatorAccount ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: NominatorPosition , types :: nominator_position :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("DomainsApi" , "nominator_position" , types :: NominatorPosition { operator_id , nominator_account , } , [122u8 , 160u8 , 187u8 , 226u8 , 189u8 , 133u8 , 121u8 , 242u8 , 172u8 , 4u8 , 75u8 , 145u8 , 10u8 , 175u8 , 32u8 , 162u8 , 215u8 , 86u8 , 215u8 , 39u8 , 143u8 , 217u8 , 18u8 , 248u8 , 207u8 , 189u8 , 212u8 , 57u8 , 108u8 , 42u8 , 216u8 , 138u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod submit_bundle_unsigned { use super :: runtime_types ; pub type OpaqueBundle = runtime_types :: sp_domains :: Bundle < runtime_types :: sp_runtime :: OpaqueExtrinsic , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: core :: primitive :: u128 > ; pub mod output { use super :: runtime_types ; pub type Output = () ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubmitBundleUnsigned { pub opaque_bundle : submit_bundle_unsigned :: OpaqueBundle , } pub mod submit_receipt_unsigned { use super :: runtime_types ; pub type SingletonReceipt = runtime_types :: sp_domains :: SealedSingletonReceipt < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: core :: primitive :: u128 > ; pub mod output { use super :: runtime_types ; pub type Output = () ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubmitReceiptUnsigned { pub singleton_receipt : submit_receipt_unsigned :: SingletonReceipt , } pub mod extract_successful_bundles { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type Extrinsics = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: Bundle < runtime_types :: sp_runtime :: OpaqueExtrinsic , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: core :: primitive :: u128 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExtractSuccessfulBundles { pub domain_id : extract_successful_bundles :: DomainId , pub extrinsics : extract_successful_bundles :: Extrinsics , } pub mod extrinsics_shuffling_seed { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: subspace_core_primitives :: Randomness ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExtrinsicsShufflingSeed { } pub mod domain_runtime_code { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainRuntimeCode { pub domain_id : domain_runtime_code :: DomainId , } pub mod runtime_id { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: core :: primitive :: u32 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeId { pub domain_id : runtime_id :: DomainId , } pub mod runtime_upgrades { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u32 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeUpgrades { } pub mod domain_instance_data { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < (runtime_types :: sp_domains :: DomainInstanceData , :: core :: primitive :: u32 ,) > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainInstanceData { pub domain_id : domain_instance_data :: DomainId , } pub mod domain_timestamp { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u64 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainTimestamp { } pub mod timestamp { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u64 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Timestamp { } pub mod consensus_transaction_byte_fee { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u128 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ConsensusTransactionByteFee { } pub mod consensus_chain_byte_fee { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u128 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ConsensusChainByteFee { } pub mod domain_tx_range { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: subspace_core_primitives :: U256 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainTxRange { pub domain_id : domain_tx_range :: DomainId , } pub mod genesis_state_root { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: H256 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GenesisStateRoot { pub domain_id : genesis_state_root :: DomainId , } pub mod head_receipt_number { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u32 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct HeadReceiptNumber { pub domain_id : head_receipt_number :: DomainId , } pub mod oldest_unconfirmed_receipt_number { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: core :: primitive :: u32 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OldestUnconfirmedReceiptNumber { pub domain_id : oldest_unconfirmed_receipt_number :: DomainId , } pub mod domain_bundle_limit { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_domains :: DomainBundleLimit > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainBundleLimit { pub domain_id : domain_bundle_limit :: DomainId , } pub mod non_empty_er_exists { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: bool ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct NonEmptyErExists { pub domain_id : non_empty_er_exists :: DomainId , } pub mod domain_best_number { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: core :: primitive :: u32 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainBestNumber { pub domain_id : domain_best_number :: DomainId , } pub mod execution_receipt { use super :: runtime_types ; pub type ReceiptHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_domains :: ExecutionReceipt < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u128 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExecutionReceipt { pub receipt_hash : execution_receipt :: ReceiptHash , } pub mod domain_operators { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < (:: subxt :: ext :: subxt_core :: utils :: KeyedVec < :: core :: primitive :: u64 , :: core :: primitive :: u128 > , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > ,) > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainOperators { pub domain_id : domain_operators :: DomainId , } pub mod receipt_hash { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type DomainNumber = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: H256 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ReceiptHash { pub domain_id : receipt_hash :: DomainId , pub domain_number : receipt_hash :: DomainNumber , } pub mod latest_confirmed_domain_block { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < (:: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 ,) > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct LatestConfirmedDomainBlock { pub domain_id : latest_confirmed_domain_block :: DomainId , } pub mod is_bad_er_pending_to_prune { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type ReceiptHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: bool ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct IsBadErPendingToPrune { pub domain_id : is_bad_er_pending_to_prune :: DomainId , pub receipt_hash : is_bad_er_pending_to_prune :: ReceiptHash , } pub mod storage_fund_account_balance { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u128 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StorageFundAccountBalance { pub operator_id : storage_fund_account_balance :: OperatorId , } pub mod is_domain_runtime_upgraded_since { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type At = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: core :: primitive :: bool > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct IsDomainRuntimeUpgradedSince { pub domain_id : is_domain_runtime_upgraded_since :: DomainId , pub at : is_domain_runtime_upgraded_since :: At , } pub mod domain_sudo_call { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainSudoCall { pub domain_id : domain_sudo_call :: DomainId , } pub mod evm_domain_contract_creation_allowed_by_call { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_domains :: PermissionedActionAllowedBy < :: subxt :: ext :: subxt_core :: utils :: AccountId20 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EvmDomainContractCreationAllowedByCall { pub domain_id : evm_domain_contract_creation_allowed_by_call :: DomainId , } pub mod last_confirmed_domain_block_receipt { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_domains :: ExecutionReceipt < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u128 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct LastConfirmedDomainBlockReceipt { pub domain_id : last_confirmed_domain_block_receipt :: DomainId , } pub mod nominator_position { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type NominatorAccount = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_domains :: NominatorPosition < :: core :: primitive :: u128 , :: core :: primitive :: u32 , :: core :: primitive :: u128 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct NominatorPosition { pub operator_id : nominator_position :: OperatorId , pub nominator_account : nominator_position :: NominatorAccount , } } } pub mod bundle_producer_election_api { use super :: root_mod ; use super :: runtime_types ; pub struct BundleProducerElectionApi ; impl BundleProducerElectionApi { pub fn bundle_producer_election_params (& self , domain_id : types :: bundle_producer_election_params :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: BundleProducerElectionParams , types :: bundle_producer_election_params :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BundleProducerElectionApi" , "bundle_producer_election_params" , types :: BundleProducerElectionParams { domain_id , } , [26u8 , 253u8 , 111u8 , 129u8 , 105u8 , 79u8 , 194u8 , 62u8 , 238u8 , 56u8 , 217u8 , 210u8 , 228u8 , 177u8 , 112u8 , 153u8 , 164u8 , 100u8 , 190u8 , 58u8 , 33u8 , 125u8 , 184u8 , 255u8 , 159u8 , 36u8 , 231u8 , 202u8 , 224u8 , 120u8 , 206u8 , 139u8 ,] ,) } pub fn operator (& self , operator_id : types :: operator :: OperatorId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: Operator , types :: operator :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("BundleProducerElectionApi" , "operator" , types :: Operator { operator_id , } , [230u8 , 129u8 , 197u8 , 68u8 , 195u8 , 208u8 , 162u8 , 246u8 , 106u8 , 190u8 , 25u8 , 34u8 , 120u8 , 250u8 , 26u8 , 223u8 , 185u8 , 119u8 , 76u8 , 59u8 , 208u8 , 20u8 , 123u8 , 63u8 , 142u8 , 79u8 , 148u8 , 247u8 , 177u8 , 205u8 , 10u8 , 116u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod bundle_producer_election_params { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_domains :: bundle_producer_election :: BundleProducerElectionParams < :: core :: primitive :: u128 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BundleProducerElectionParams { pub domain_id : bundle_producer_election_params :: DomainId , } pub mod operator { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < (runtime_types :: sp_domains :: app :: Public , :: core :: primitive :: u128 ,) > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Operator { pub operator_id : operator :: OperatorId , } } } pub mod session_keys { use super :: root_mod ; use super :: runtime_types ; # [doc = " Session keys runtime api."] pub struct SessionKeys ; impl SessionKeys { # [doc = " Generate a set of session keys with optionally using the given seed."] # [doc = " The keys should be stored within the keystore exposed via runtime"] # [doc = " externalities."] # [doc = ""] # [doc = " The seed needs to be a valid `utf8` string."] # [doc = ""] # [doc = " Returns the concatenated SCALE encoded public keys."] pub fn generate_session_keys (& self , seed : types :: generate_session_keys :: Seed ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GenerateSessionKeys , types :: generate_session_keys :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SessionKeys" , "generate_session_keys" , types :: GenerateSessionKeys { seed , } , [96u8 , 171u8 , 164u8 , 166u8 , 175u8 , 102u8 , 101u8 , 47u8 , 133u8 , 95u8 , 102u8 , 202u8 , 83u8 , 26u8 , 238u8 , 47u8 , 126u8 , 132u8 , 22u8 , 11u8 , 33u8 , 190u8 , 175u8 , 94u8 , 58u8 , 245u8 , 46u8 , 80u8 , 195u8 , 184u8 , 107u8 , 65u8 ,] ,) } # [doc = " Decode the given public session keys."] # [doc = ""] # [doc = " Returns the list of public raw public keys + key type."] pub fn decode_session_keys (& self , encoded : types :: decode_session_keys :: Encoded ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DecodeSessionKeys , types :: decode_session_keys :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("SessionKeys" , "decode_session_keys" , types :: DecodeSessionKeys { encoded , } , [57u8 , 242u8 , 18u8 , 51u8 , 132u8 , 110u8 , 238u8 , 255u8 , 39u8 , 194u8 , 8u8 , 54u8 , 198u8 , 178u8 , 75u8 , 151u8 , 148u8 , 176u8 , 144u8 , 197u8 , 87u8 , 29u8 , 179u8 , 235u8 , 176u8 , 78u8 , 252u8 , 103u8 , 72u8 , 203u8 , 151u8 , 248u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod generate_session_keys { use super :: runtime_types ; pub type Seed = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GenerateSessionKeys { pub seed : generate_session_keys :: Seed , } pub mod decode_session_keys { use super :: runtime_types ; pub type Encoded = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: sp_core :: crypto :: KeyTypeId ,) > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DecodeSessionKeys { pub encoded : decode_session_keys :: Encoded , } } } pub mod account_nonce_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " The API to query account nonce."] pub struct AccountNonceApi ; impl AccountNonceApi { # [doc = " Get current account nonce of given `AccountId`."] pub fn account_nonce (& self , account : types :: account_nonce :: Account ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: AccountNonce , types :: account_nonce :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("AccountNonceApi" , "account_nonce" , types :: AccountNonce { account , } , [231u8 , 82u8 , 7u8 , 227u8 , 131u8 , 2u8 , 215u8 , 252u8 , 173u8 , 82u8 , 11u8 , 103u8 , 200u8 , 25u8 , 114u8 , 116u8 , 79u8 , 229u8 , 152u8 , 150u8 , 236u8 , 37u8 , 101u8 , 26u8 , 220u8 , 146u8 , 182u8 , 101u8 , 73u8 , 55u8 , 191u8 , 171u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod account_nonce { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u32 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct AccountNonce { pub account : account_nonce :: Account , } } } pub mod transaction_payment_api { use super :: root_mod ; use super :: runtime_types ; pub struct TransactionPaymentApi ; impl TransactionPaymentApi { pub fn query_info (& self , uxt : types :: query_info :: Uxt , len : types :: query_info :: Len ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryInfo , types :: query_info :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentApi" , "query_info" , types :: QueryInfo { uxt , len , } , [56u8 , 30u8 , 174u8 , 34u8 , 202u8 , 24u8 , 177u8 , 189u8 , 145u8 , 36u8 , 1u8 , 156u8 , 98u8 , 209u8 , 178u8 , 49u8 , 198u8 , 23u8 , 150u8 , 173u8 , 35u8 , 205u8 , 147u8 , 129u8 , 42u8 , 22u8 , 69u8 , 3u8 , 129u8 , 8u8 , 196u8 , 139u8 ,] ,) } pub fn query_fee_details (& self , uxt : types :: query_fee_details :: Uxt , len : types :: query_fee_details :: Len ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryFeeDetails , types :: query_fee_details :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentApi" , "query_fee_details" , types :: QueryFeeDetails { uxt , len , } , [117u8 , 60u8 , 137u8 , 159u8 , 237u8 , 252u8 , 216u8 , 238u8 , 232u8 , 1u8 , 100u8 , 152u8 , 26u8 , 185u8 , 145u8 , 125u8 , 68u8 , 189u8 , 4u8 , 30u8 , 125u8 , 7u8 , 196u8 , 153u8 , 235u8 , 51u8 , 219u8 , 108u8 , 185u8 , 254u8 , 100u8 , 201u8 ,] ,) } pub fn query_weight_to_fee (& self , weight : types :: query_weight_to_fee :: Weight ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryWeightToFee , types :: query_weight_to_fee :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentApi" , "query_weight_to_fee" , types :: QueryWeightToFee { weight , } , [206u8 , 243u8 , 189u8 , 83u8 , 231u8 , 244u8 , 247u8 , 52u8 , 126u8 , 208u8 , 224u8 , 5u8 , 163u8 , 108u8 , 254u8 , 114u8 , 214u8 , 156u8 , 227u8 , 217u8 , 211u8 , 198u8 , 121u8 , 164u8 , 110u8 , 54u8 , 181u8 , 146u8 , 50u8 , 146u8 , 146u8 , 23u8 ,] ,) } pub fn query_length_to_fee (& self , length : types :: query_length_to_fee :: Length ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: QueryLengthToFee , types :: query_length_to_fee :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("TransactionPaymentApi" , "query_length_to_fee" , types :: QueryLengthToFee { length , } , [92u8 , 132u8 , 29u8 , 119u8 , 66u8 , 11u8 , 196u8 , 224u8 , 129u8 , 23u8 , 249u8 , 12u8 , 32u8 , 28u8 , 92u8 , 50u8 , 188u8 , 101u8 , 203u8 , 229u8 , 248u8 , 216u8 , 130u8 , 150u8 , 212u8 , 161u8 , 81u8 , 254u8 , 116u8 , 89u8 , 162u8 , 48u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod query_info { use super :: runtime_types ; pub type Uxt = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub type Len = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: pallet_transaction_payment :: types :: RuntimeDispatchInfo < :: core :: primitive :: u128 , runtime_types :: sp_weights :: weight_v2 :: Weight > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryInfo { pub uxt : query_info :: Uxt , pub len : query_info :: Len , } pub mod query_fee_details { use super :: runtime_types ; pub type Uxt = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub type Len = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: pallet_transaction_payment :: types :: FeeDetails < :: core :: primitive :: u128 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryFeeDetails { pub uxt : query_fee_details :: Uxt , pub len : query_fee_details :: Len , } pub mod query_weight_to_fee { use super :: runtime_types ; pub type Weight = runtime_types :: sp_weights :: weight_v2 :: Weight ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u128 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryWeightToFee { pub weight : query_weight_to_fee :: Weight , } pub mod query_length_to_fee { use super :: runtime_types ; pub type Length = :: core :: primitive :: u32 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: u128 ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct QueryLengthToFee { pub length : query_length_to_fee :: Length , } } } pub mod messenger_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " Api to provide XDM extraction from Runtime Calls."] pub struct MessengerApi ; impl MessengerApi { # [doc = " Returns `Some(true)` if valid XDM or `Some(false)` if not"] # [doc = " Returns None if this is not an XDM"] pub fn is_xdm_mmr_proof_valid (& self , ext : types :: is_xdm_mmr_proof_valid :: Ext ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: IsXdmMmrProofValid , types :: is_xdm_mmr_proof_valid :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "is_xdm_mmr_proof_valid" , types :: IsXdmMmrProofValid { ext , } , [176u8 , 90u8 , 110u8 , 155u8 , 82u8 , 54u8 , 168u8 , 57u8 , 37u8 , 77u8 , 179u8 , 251u8 , 214u8 , 254u8 , 144u8 , 241u8 , 238u8 , 123u8 , 217u8 , 235u8 , 35u8 , 243u8 , 151u8 , 56u8 , 180u8 , 6u8 , 99u8 , 110u8 , 235u8 , 26u8 , 174u8 , 140u8 ,] ,) } pub fn extract_xdm_mmr_proof (& self , ext : types :: extract_xdm_mmr_proof :: Ext ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ExtractXdmMmrProof , types :: extract_xdm_mmr_proof :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "extract_xdm_mmr_proof" , types :: ExtractXdmMmrProof { ext , } , [111u8 , 120u8 , 210u8 , 57u8 , 65u8 , 45u8 , 118u8 , 221u8 , 160u8 , 189u8 , 249u8 , 148u8 , 83u8 , 70u8 , 133u8 , 234u8 , 197u8 , 9u8 , 53u8 , 241u8 , 156u8 , 125u8 , 77u8 , 151u8 , 52u8 , 38u8 , 210u8 , 91u8 , 101u8 , 231u8 , 61u8 , 104u8 ,] ,) } pub fn batch_extract_xdm_mmr_proof (& self , ext : types :: batch_extract_xdm_mmr_proof :: Ext ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: BatchExtractXdmMmrProof , types :: batch_extract_xdm_mmr_proof :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "batch_extract_xdm_mmr_proof" , types :: BatchExtractXdmMmrProof { ext , } , [88u8 , 124u8 , 93u8 , 145u8 , 217u8 , 115u8 , 205u8 , 182u8 , 136u8 , 255u8 , 66u8 , 137u8 , 80u8 , 155u8 , 185u8 , 227u8 , 238u8 , 58u8 , 182u8 , 71u8 , 212u8 , 73u8 , 157u8 , 133u8 , 171u8 , 75u8 , 176u8 , 145u8 , 151u8 , 117u8 , 97u8 , 15u8 ,] ,) } # [doc = " Returns the confirmed domain block storage for given domain."] pub fn confirmed_domain_block_storage_key (& self , domain_id : types :: confirmed_domain_block_storage_key :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ConfirmedDomainBlockStorageKey , types :: confirmed_domain_block_storage_key :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "confirmed_domain_block_storage_key" , types :: ConfirmedDomainBlockStorageKey { domain_id , } , [92u8 , 20u8 , 115u8 , 57u8 , 241u8 , 130u8 , 208u8 , 80u8 , 236u8 , 186u8 , 13u8 , 167u8 , 253u8 , 137u8 , 166u8 , 3u8 , 248u8 , 179u8 , 182u8 , 28u8 , 254u8 , 139u8 , 53u8 , 151u8 , 168u8 , 63u8 , 49u8 , 2u8 , 1u8 , 233u8 , 22u8 , 138u8 ,] ,) } # [doc = " Returns storage key for outbox for a given message_id."] pub fn outbox_storage_key (& self , message_key : types :: outbox_storage_key :: MessageKey ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: OutboxStorageKey , types :: outbox_storage_key :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "outbox_storage_key" , types :: OutboxStorageKey { message_key , } , [107u8 , 101u8 , 10u8 , 6u8 , 156u8 , 67u8 , 29u8 , 204u8 , 208u8 , 211u8 , 150u8 , 127u8 , 87u8 , 222u8 , 27u8 , 151u8 , 129u8 , 14u8 , 134u8 , 193u8 , 14u8 , 88u8 , 20u8 , 88u8 , 23u8 , 128u8 , 144u8 , 150u8 , 21u8 , 244u8 , 171u8 , 175u8 ,] ,) } # [doc = " Returns storage key for inbox response for a given message_id."] pub fn inbox_response_storage_key (& self , message_key : types :: inbox_response_storage_key :: MessageKey ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: InboxResponseStorageKey , types :: inbox_response_storage_key :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "inbox_response_storage_key" , types :: InboxResponseStorageKey { message_key , } , [227u8 , 222u8 , 30u8 , 1u8 , 205u8 , 102u8 , 195u8 , 36u8 , 98u8 , 128u8 , 61u8 , 74u8 , 175u8 , 86u8 , 212u8 , 157u8 , 104u8 , 198u8 , 89u8 , 41u8 , 37u8 , 91u8 , 87u8 , 77u8 , 209u8 , 237u8 , 95u8 , 90u8 , 181u8 , 39u8 , 118u8 , 136u8 ,] ,) } # [doc = " Returns any domain's chains allowlist updates on consensus chain."] pub fn domain_chains_allowlist_update (& self , domain_id : types :: domain_chains_allowlist_update :: DomainId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: DomainChainsAllowlistUpdate , types :: domain_chains_allowlist_update :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "domain_chains_allowlist_update" , types :: DomainChainsAllowlistUpdate { domain_id , } , [193u8 , 214u8 , 221u8 , 107u8 , 253u8 , 173u8 , 97u8 , 145u8 , 96u8 , 151u8 , 99u8 , 191u8 , 56u8 , 165u8 , 205u8 , 1u8 , 79u8 , 184u8 , 149u8 , 121u8 , 86u8 , 61u8 , 143u8 , 122u8 , 178u8 , 138u8 , 186u8 , 208u8 , 84u8 , 163u8 , 98u8 , 12u8 ,] ,) } # [doc = " Returns XDM message ID"] pub fn xdm_id (& self , ext : types :: xdm_id :: Ext ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: XdmId , types :: xdm_id :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "xdm_id" , types :: XdmId { ext , } , [14u8 , 36u8 , 196u8 , 151u8 , 192u8 , 125u8 , 10u8 , 121u8 , 87u8 , 232u8 , 226u8 , 211u8 , 150u8 , 94u8 , 122u8 , 208u8 , 56u8 , 81u8 , 124u8 , 212u8 , 173u8 , 230u8 , 169u8 , 181u8 , 77u8 , 32u8 , 129u8 , 148u8 , 46u8 , 122u8 , 213u8 , 11u8 ,] ,) } # [doc = " Get Channel nonce for given chain and channel id."] pub fn channel_nonce (& self , chain_id : types :: channel_nonce :: ChainId , channel_id : types :: channel_nonce :: ChannelId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ChannelNonce , types :: channel_nonce :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MessengerApi" , "channel_nonce" , types :: ChannelNonce { chain_id , channel_id , } , [118u8 , 118u8 , 247u8 , 70u8 , 34u8 , 253u8 , 152u8 , 97u8 , 155u8 , 68u8 , 87u8 , 22u8 , 98u8 , 253u8 , 171u8 , 100u8 , 124u8 , 20u8 , 213u8 , 165u8 , 12u8 , 76u8 , 15u8 , 148u8 , 46u8 , 17u8 , 97u8 , 203u8 , 233u8 , 71u8 , 111u8 , 181u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod is_xdm_mmr_proof_valid { use super :: runtime_types ; pub type Ext = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: core :: primitive :: bool > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct IsXdmMmrProofValid { pub ext : is_xdm_mmr_proof_valid :: Ext , } pub mod extract_xdm_mmr_proof { use super :: runtime_types ; pub type Ext = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_subspace_mmr :: ConsensusChainMmrLeafProof < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: H256 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExtractXdmMmrProof { pub ext : extract_xdm_mmr_proof :: Ext , } pub mod batch_extract_xdm_mmr_proof { use super :: runtime_types ; pub type Ext = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: utils :: KeyedVec < :: core :: primitive :: u32 , runtime_types :: sp_subspace_mmr :: ConsensusChainMmrLeafProof < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: H256 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BatchExtractXdmMmrProof { pub ext : batch_extract_xdm_mmr_proof :: Ext , } pub mod confirmed_domain_block_storage_key { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ConfirmedDomainBlockStorageKey { pub domain_id : confirmed_domain_block_storage_key :: DomainId , } pub mod outbox_storage_key { use super :: runtime_types ; pub type MessageKey = (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OutboxStorageKey { pub message_key : outbox_storage_key :: MessageKey , } pub mod inbox_response_storage_key { use super :: runtime_types ; pub type MessageKey = (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InboxResponseStorageKey { pub message_key : inbox_response_storage_key :: MessageKey , } pub mod domain_chains_allowlist_update { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_domains :: DomainAllowlistUpdates > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainChainsAllowlistUpdate { pub domain_id : domain_chains_allowlist_update :: DomainId , } pub mod xdm_id { use super :: runtime_types ; pub type Ext = :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_messenger :: XdmId > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct XdmId { pub ext : xdm_id :: Ext , } pub mod channel_nonce { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: sp_messenger :: ChannelNonce > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChannelNonce { pub chain_id : channel_nonce :: ChainId , pub channel_id : channel_nonce :: ChannelId , } } } pub mod relayer_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " Api useful for relayers to fetch messages and submit transactions."] pub struct RelayerApi ; impl RelayerApi { # [doc = " Returns all the outbox and inbox responses to deliver."] # [doc = " Storage key is used to generate the storage proof for the message."] pub fn block_messages (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: BlockMessages , types :: block_messages :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "block_messages" , types :: BlockMessages { } , [79u8 , 208u8 , 60u8 , 241u8 , 240u8 , 40u8 , 110u8 , 78u8 , 200u8 , 166u8 , 187u8 , 120u8 , 128u8 , 217u8 , 58u8 , 250u8 , 23u8 , 29u8 , 104u8 , 119u8 , 197u8 , 33u8 , 36u8 , 87u8 , 123u8 , 165u8 , 202u8 , 142u8 , 254u8 , 183u8 , 184u8 , 240u8 ,] ,) } # [doc = " Constructs an outbox message to the dst_chain as an unsigned extrinsic."] pub fn outbox_message_unsigned (& self , msg : types :: outbox_message_unsigned :: Msg ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: OutboxMessageUnsigned , types :: outbox_message_unsigned :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "outbox_message_unsigned" , types :: OutboxMessageUnsigned { msg , } , [105u8 , 173u8 , 60u8 , 213u8 , 140u8 , 62u8 , 11u8 , 93u8 , 20u8 , 104u8 , 147u8 , 12u8 , 46u8 , 30u8 , 39u8 , 27u8 , 209u8 , 247u8 , 48u8 , 176u8 , 12u8 , 254u8 , 225u8 , 170u8 , 73u8 , 30u8 , 120u8 , 242u8 , 92u8 , 207u8 , 2u8 , 240u8 ,] ,) } # [doc = " Constructs an inbox response message to the dst_chain as an unsigned extrinsic."] pub fn inbox_response_message_unsigned (& self , msg : types :: inbox_response_message_unsigned :: Msg ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: InboxResponseMessageUnsigned , types :: inbox_response_message_unsigned :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "inbox_response_message_unsigned" , types :: InboxResponseMessageUnsigned { msg , } , [36u8 , 185u8 , 234u8 , 76u8 , 15u8 , 84u8 , 12u8 , 75u8 , 79u8 , 176u8 , 107u8 , 102u8 , 178u8 , 96u8 , 181u8 , 138u8 , 56u8 , 39u8 , 247u8 , 89u8 , 184u8 , 66u8 , 80u8 , 247u8 , 191u8 , 230u8 , 167u8 , 138u8 , 12u8 , 91u8 , 150u8 , 167u8 ,] ,) } # [doc = " Returns true if the outbox message is ready to be relayed to dst_chain."] pub fn should_relay_outbox_message (& self , dst_chain_id : types :: should_relay_outbox_message :: DstChainId , msg_id : types :: should_relay_outbox_message :: MsgId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ShouldRelayOutboxMessage , types :: should_relay_outbox_message :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "should_relay_outbox_message" , types :: ShouldRelayOutboxMessage { dst_chain_id , msg_id , } , [73u8 , 156u8 , 205u8 , 82u8 , 135u8 , 225u8 , 191u8 , 202u8 , 23u8 , 154u8 , 208u8 , 228u8 , 36u8 , 126u8 , 33u8 , 11u8 , 163u8 , 115u8 , 59u8 , 51u8 , 80u8 , 221u8 , 75u8 , 97u8 , 68u8 , 221u8 , 89u8 , 71u8 , 154u8 , 171u8 , 243u8 , 85u8 ,] ,) } # [doc = " Returns true if the inbox message response is ready to be relayed to dst_chain."] pub fn should_relay_inbox_message_response (& self , dst_chain_id : types :: should_relay_inbox_message_response :: DstChainId , msg_id : types :: should_relay_inbox_message_response :: MsgId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ShouldRelayInboxMessageResponse , types :: should_relay_inbox_message_response :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "should_relay_inbox_message_response" , types :: ShouldRelayInboxMessageResponse { dst_chain_id , msg_id , } , [104u8 , 27u8 , 40u8 , 239u8 , 29u8 , 146u8 , 161u8 , 81u8 , 201u8 , 239u8 , 237u8 , 87u8 , 50u8 , 157u8 , 95u8 , 127u8 , 106u8 , 17u8 , 68u8 , 142u8 , 180u8 , 89u8 , 65u8 , 98u8 , 67u8 , 163u8 , 64u8 , 137u8 , 168u8 , 183u8 , 214u8 , 210u8 ,] ,) } # [doc = " Returns the list of channels updated in the given block."] pub fn updated_channels (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: UpdatedChannels , types :: updated_channels :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "updated_channels" , types :: UpdatedChannels { } , [122u8 , 27u8 , 107u8 , 36u8 , 129u8 , 147u8 , 14u8 , 79u8 , 82u8 , 33u8 , 0u8 , 162u8 , 181u8 , 55u8 , 209u8 , 79u8 , 209u8 , 72u8 , 126u8 , 111u8 , 117u8 , 8u8 , 72u8 , 166u8 , 147u8 , 232u8 , 131u8 , 210u8 , 87u8 , 151u8 , 15u8 , 255u8 ,] ,) } # [doc = " Returns storage key for channels for given chain and channel id."] pub fn channel_storage_key (& self , chain_id : types :: channel_storage_key :: ChainId , channel_id : types :: channel_storage_key :: ChannelId ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ChannelStorageKey , types :: channel_storage_key :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "channel_storage_key" , types :: ChannelStorageKey { chain_id , channel_id , } , [102u8 , 244u8 , 133u8 , 196u8 , 68u8 , 164u8 , 117u8 , 41u8 , 100u8 , 83u8 , 170u8 , 96u8 , 146u8 , 198u8 , 94u8 , 151u8 , 233u8 , 136u8 , 50u8 , 125u8 , 208u8 , 91u8 , 10u8 , 97u8 , 98u8 , 64u8 , 70u8 , 178u8 , 151u8 , 110u8 , 86u8 , 16u8 ,] ,) } # [doc = " Returns all the open channels to other chains."] pub fn open_channels (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: OpenChannels , types :: open_channels :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "open_channels" , types :: OpenChannels { } , [248u8 , 43u8 , 102u8 , 90u8 , 83u8 , 238u8 , 78u8 , 98u8 , 237u8 , 227u8 , 38u8 , 55u8 , 152u8 , 39u8 , 165u8 , 198u8 , 20u8 , 166u8 , 234u8 , 103u8 , 109u8 , 94u8 , 218u8 , 130u8 , 96u8 , 52u8 , 20u8 , 199u8 , 243u8 , 223u8 , 220u8 , 87u8 ,] ,) } # [doc = " Returns outbox and inbox responses from given nonce to maximum allowed nonce per block"] # [doc = " Storage key is used to generate the storage proof for the message."] pub fn block_messages_with_query (& self , query : types :: block_messages_with_query :: Query ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: BlockMessagesWithQuery , types :: block_messages_with_query :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "block_messages_with_query" , types :: BlockMessagesWithQuery { query , } , [60u8 , 43u8 , 244u8 , 178u8 , 254u8 , 117u8 , 29u8 , 205u8 , 82u8 , 63u8 , 130u8 , 65u8 , 76u8 , 132u8 , 202u8 , 228u8 , 23u8 , 89u8 , 97u8 , 207u8 , 100u8 , 40u8 , 14u8 , 202u8 , 64u8 , 123u8 , 81u8 , 150u8 , 154u8 , 130u8 , 180u8 , 203u8 ,] ,) } # [doc = " Returns all the channels to other chains and their local Channel state."] pub fn channels_and_state (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: ChannelsAndState , types :: channels_and_state :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "channels_and_state" , types :: ChannelsAndState { } , [216u8 , 216u8 , 215u8 , 165u8 , 157u8 , 240u8 , 163u8 , 92u8 , 4u8 , 85u8 , 156u8 , 193u8 , 179u8 , 140u8 , 90u8 , 128u8 , 196u8 , 225u8 , 255u8 , 203u8 , 4u8 , 138u8 , 44u8 , 93u8 , 202u8 , 71u8 , 59u8 , 243u8 , 125u8 , 82u8 , 185u8 , 98u8 ,] ,) } # [doc = " Returns the first outbox message nonce that should be relayed to the dst_chain."] pub fn first_outbox_message_nonce_to_relay (& self , dst_chain_id : types :: first_outbox_message_nonce_to_relay :: DstChainId , channel_id : types :: first_outbox_message_nonce_to_relay :: ChannelId , from_nonce : types :: first_outbox_message_nonce_to_relay :: FromNonce ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: FirstOutboxMessageNonceToRelay , types :: first_outbox_message_nonce_to_relay :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "first_outbox_message_nonce_to_relay" , types :: FirstOutboxMessageNonceToRelay { dst_chain_id , channel_id , from_nonce , } , [239u8 , 247u8 , 188u8 , 207u8 , 240u8 , 237u8 , 121u8 , 199u8 , 0u8 , 1u8 , 45u8 , 13u8 , 143u8 , 74u8 , 161u8 , 54u8 , 85u8 , 207u8 , 9u8 , 160u8 , 222u8 , 146u8 , 233u8 , 62u8 , 68u8 , 62u8 , 100u8 , 24u8 , 37u8 , 194u8 , 108u8 , 124u8 ,] ,) } # [doc = " Returns the first inbox response message nonce that should be relayed to the dst_chain."] pub fn first_inbox_message_response_nonce_to_relay (& self , dst_chain_id : types :: first_inbox_message_response_nonce_to_relay :: DstChainId , channel_id : types :: first_inbox_message_response_nonce_to_relay :: ChannelId , from_nonce : types :: first_inbox_message_response_nonce_to_relay :: FromNonce ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: FirstInboxMessageResponseNonceToRelay , types :: first_inbox_message_response_nonce_to_relay :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("RelayerApi" , "first_inbox_message_response_nonce_to_relay" , types :: FirstInboxMessageResponseNonceToRelay { dst_chain_id , channel_id , from_nonce , } , [228u8 , 224u8 , 27u8 , 200u8 , 44u8 , 4u8 , 33u8 , 177u8 , 250u8 , 181u8 , 167u8 , 102u8 , 241u8 , 255u8 , 226u8 , 111u8 , 3u8 , 48u8 , 137u8 , 5u8 , 163u8 , 74u8 , 209u8 , 210u8 , 13u8 , 187u8 , 22u8 , 78u8 , 57u8 , 74u8 , 60u8 , 53u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod block_messages { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_messenger :: messages :: BlockMessagesWithStorageKey ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockMessages { } pub mod outbox_message_unsigned { use super :: runtime_types ; pub type Msg = runtime_types :: sp_messenger :: messages :: CrossDomainMessage < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OutboxMessageUnsigned { pub msg : outbox_message_unsigned :: Msg , } pub mod inbox_response_message_unsigned { use super :: runtime_types ; pub type Msg = runtime_types :: sp_messenger :: messages :: CrossDomainMessage < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: UncheckedExtrinsic < :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: MultiSignature , (runtime_types :: frame_system :: extensions :: check_non_zero_sender :: CheckNonZeroSender , runtime_types :: frame_system :: extensions :: check_spec_version :: CheckSpecVersion , runtime_types :: frame_system :: extensions :: check_tx_version :: CheckTxVersion , runtime_types :: frame_system :: extensions :: check_genesis :: CheckGenesis , runtime_types :: frame_system :: extensions :: check_mortality :: CheckMortality , runtime_types :: frame_system :: extensions :: check_nonce :: CheckNonce , runtime_types :: frame_system :: extensions :: check_weight :: CheckWeight , runtime_types :: pallet_transaction_payment :: ChargeTransactionPayment , runtime_types :: subspace_runtime_primitives :: extension :: BalanceTransferCheckExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_subspace :: extensions :: SubspaceExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_domains :: extensions :: DomainsExtension < runtime_types :: subspace_runtime :: Runtime > , runtime_types :: pallet_messenger :: extensions :: MessengerExtension < runtime_types :: subspace_runtime :: Runtime > ,) > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InboxResponseMessageUnsigned { pub msg : inbox_response_message_unsigned :: Msg , } pub mod should_relay_outbox_message { use super :: runtime_types ; pub type DstChainId = runtime_types :: sp_domains :: ChainId ; pub type MsgId = (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: bool ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ShouldRelayOutboxMessage { pub dst_chain_id : should_relay_outbox_message :: DstChainId , pub msg_id : should_relay_outbox_message :: MsgId , } pub mod should_relay_inbox_message_response { use super :: runtime_types ; pub type DstChainId = runtime_types :: sp_domains :: ChainId ; pub type MsgId = (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: primitive :: bool ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ShouldRelayInboxMessageResponse { pub dst_chain_id : should_relay_inbox_message_response :: DstChainId , pub msg_id : should_relay_inbox_message_response :: MsgId , } pub mod updated_channels { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 ,) > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct UpdatedChannels { } pub mod channel_storage_key { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChannelStorageKey { pub chain_id : channel_storage_key :: ChainId , pub channel_id : channel_storage_key :: ChannelId , } pub mod open_channels { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 ,) > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OpenChannels { } pub mod block_messages_with_query { use super :: runtime_types ; pub type Query = runtime_types :: sp_messenger :: messages :: BlockMessagesQuery ; pub mod output { use super :: runtime_types ; pub type Output = runtime_types :: sp_messenger :: messages :: MessagesWithStorageKey ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockMessagesWithQuery { pub query : block_messages_with_query :: Query , } pub mod channels_and_state { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 , runtime_types :: sp_messenger :: messages :: ChannelStateWithNonce ,) > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChannelsAndState { } pub mod first_outbox_message_nonce_to_relay { use super :: runtime_types ; pub type DstChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub type FromNonce = runtime_types :: primitive_types :: U256 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: primitive_types :: U256 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FirstOutboxMessageNonceToRelay { pub dst_chain_id : first_outbox_message_nonce_to_relay :: DstChainId , pub channel_id : first_outbox_message_nonce_to_relay :: ChannelId , pub from_nonce : first_outbox_message_nonce_to_relay :: FromNonce , } pub mod first_inbox_message_response_nonce_to_relay { use super :: runtime_types ; pub type DstChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub type FromNonce = runtime_types :: primitive_types :: U256 ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < runtime_types :: primitive_types :: U256 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FirstInboxMessageResponseNonceToRelay { pub dst_chain_id : first_inbox_message_response_nonce_to_relay :: DstChainId , pub channel_id : first_inbox_message_response_nonce_to_relay :: ChannelId , pub from_nonce : first_inbox_message_response_nonce_to_relay :: FromNonce , } } } pub mod fraud_proof_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " API necessary for fraud proof."] pub struct FraudProofApi ; impl FraudProofApi { # [doc = " Submit the fraud proof via an unsigned extrinsic."] pub fn submit_fraud_proof_unsigned (& self , fraud_proof : types :: submit_fraud_proof_unsigned :: FraudProof ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: SubmitFraudProofUnsigned , types :: submit_fraud_proof_unsigned :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("FraudProofApi" , "submit_fraud_proof_unsigned" , types :: SubmitFraudProofUnsigned { fraud_proof , } , [151u8 , 146u8 , 217u8 , 85u8 , 237u8 , 135u8 , 118u8 , 164u8 , 26u8 , 33u8 , 255u8 , 223u8 , 180u8 , 247u8 , 40u8 , 112u8 , 197u8 , 202u8 , 2u8 , 185u8 , 25u8 , 42u8 , 106u8 , 101u8 , 247u8 , 200u8 , 6u8 , 10u8 , 226u8 , 160u8 , 139u8 , 229u8 ,] ,) } # [doc = " Return the storage key used in fraud proof"] pub fn fraud_proof_storage_key (& self , req : types :: fraud_proof_storage_key :: Req ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: FraudProofStorageKey , types :: fraud_proof_storage_key :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("FraudProofApi" , "fraud_proof_storage_key" , types :: FraudProofStorageKey { req , } , [72u8 , 182u8 , 179u8 , 173u8 , 35u8 , 151u8 , 20u8 , 72u8 , 43u8 , 3u8 , 147u8 , 62u8 , 154u8 , 38u8 , 150u8 , 44u8 , 78u8 , 119u8 , 113u8 , 186u8 , 3u8 , 130u8 , 247u8 , 21u8 , 59u8 , 228u8 , 253u8 , 78u8 , 31u8 , 227u8 , 198u8 , 235u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod submit_fraud_proof_unsigned { use super :: runtime_types ; pub type FraudProof = runtime_types :: sp_domains_fraud_proof :: fraud_proof :: FraudProof < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub mod output { use super :: runtime_types ; pub type Output = () ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubmitFraudProofUnsigned { pub fraud_proof : submit_fraud_proof_unsigned :: FraudProof , } pub mod fraud_proof_storage_key { use super :: runtime_types ; pub type Req = runtime_types :: sp_domains_fraud_proof :: storage_proof :: FraudProofStorageKeyRequest < :: core :: primitive :: u32 > ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FraudProofStorageKey { pub req : fraud_proof_storage_key :: Req , } } } pub mod mmr_api { use super :: root_mod ; use super :: runtime_types ; # [doc = " API to interact with MMR pallet."] pub struct MmrApi ; impl MmrApi { # [doc = " Return the on-chain MMR root hash."] pub fn mmr_root (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: MmrRoot , types :: mmr_root :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MmrApi" , "mmr_root" , types :: MmrRoot { } , [148u8 , 252u8 , 77u8 , 233u8 , 236u8 , 8u8 , 119u8 , 105u8 , 207u8 , 161u8 , 109u8 , 158u8 , 211u8 , 64u8 , 67u8 , 216u8 , 242u8 , 52u8 , 122u8 , 4u8 , 83u8 , 113u8 , 54u8 , 77u8 , 165u8 , 89u8 , 61u8 , 159u8 , 98u8 , 51u8 , 45u8 , 90u8 ,] ,) } # [doc = " Return the number of MMR blocks in the chain."] pub fn mmr_leaf_count (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: MmrLeafCount , types :: mmr_leaf_count :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MmrApi" , "mmr_leaf_count" , types :: MmrLeafCount { } , [165u8 , 141u8 , 127u8 , 184u8 , 27u8 , 185u8 , 251u8 , 25u8 , 44u8 , 93u8 , 239u8 , 158u8 , 104u8 , 91u8 , 22u8 , 87u8 , 101u8 , 166u8 , 90u8 , 90u8 , 45u8 , 105u8 , 254u8 , 136u8 , 233u8 , 121u8 , 9u8 , 216u8 , 179u8 , 55u8 , 126u8 , 158u8 ,] ,) } # [doc = " Generate MMR proof for a series of block numbers. If `best_known_block_number = Some(n)`,"] # [doc = " use historical MMR state at given block height `n`. Else, use current MMR state."] pub fn generate_proof (& self , block_numbers : types :: generate_proof :: BlockNumbers , best_known_block_number : types :: generate_proof :: BestKnownBlockNumber ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GenerateProof , types :: generate_proof :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MmrApi" , "generate_proof" , types :: GenerateProof { block_numbers , best_known_block_number , } , [187u8 , 175u8 , 153u8 , 82u8 , 245u8 , 180u8 , 126u8 , 156u8 , 67u8 , 89u8 , 253u8 , 29u8 , 54u8 , 168u8 , 196u8 , 144u8 , 24u8 , 123u8 , 154u8 , 69u8 , 245u8 , 90u8 , 110u8 , 239u8 , 15u8 , 125u8 , 204u8 , 148u8 , 71u8 , 209u8 , 58u8 , 32u8 ,] ,) } # [doc = " Verify MMR proof against on-chain MMR for a batch of leaves."] # [doc = ""] # [doc = " Note this function will use on-chain MMR root hash and check if the proof matches the hash."] # [doc = " Note, the leaves should be sorted such that corresponding leaves and leaf indices have the"] # [doc = " same position in both the `leaves` vector and the `leaf_indices` vector contained in the [LeafProof]"] pub fn verify_proof (& self , leaves : types :: verify_proof :: Leaves , proof : types :: verify_proof :: Proof ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: VerifyProof , types :: verify_proof :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MmrApi" , "verify_proof" , types :: VerifyProof { leaves , proof , } , [236u8 , 54u8 , 135u8 , 196u8 , 161u8 , 247u8 , 183u8 , 78u8 , 153u8 , 69u8 , 59u8 , 78u8 , 62u8 , 20u8 , 187u8 , 47u8 , 77u8 , 209u8 , 209u8 , 224u8 , 127u8 , 85u8 , 122u8 , 33u8 , 123u8 , 128u8 , 92u8 , 251u8 , 110u8 , 233u8 , 50u8 , 160u8 ,] ,) } # [doc = " Verify MMR proof against given root hash for a batch of leaves."] # [doc = ""] # [doc = " Note this function does not require any on-chain storage - the"] # [doc = " proof is verified against given MMR root hash."] # [doc = ""] # [doc = " Note, the leaves should be sorted such that corresponding leaves and leaf indices have the"] # [doc = " same position in both the `leaves` vector and the `leaf_indices` vector contained in the [LeafProof]"] pub fn verify_proof_stateless (& self , root : types :: verify_proof_stateless :: Root , leaves : types :: verify_proof_stateless :: Leaves , proof : types :: verify_proof_stateless :: Proof ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: VerifyProofStateless , types :: verify_proof_stateless :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("MmrApi" , "verify_proof_stateless" , types :: VerifyProofStateless { root , leaves , proof , } , [163u8 , 232u8 , 190u8 , 65u8 , 135u8 , 136u8 , 50u8 , 60u8 , 137u8 , 37u8 , 192u8 , 24u8 , 137u8 , 144u8 , 165u8 , 131u8 , 49u8 , 88u8 , 15u8 , 139u8 , 83u8 , 152u8 , 162u8 , 148u8 , 22u8 , 74u8 , 82u8 , 25u8 , 183u8 , 83u8 , 212u8 , 56u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod mmr_root { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_mmr_primitives :: Error > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MmrRoot { } pub mod mmr_leaf_count { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < :: core :: primitive :: u64 , runtime_types :: sp_mmr_primitives :: Error > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MmrLeafCount { } pub mod generate_proof { use super :: runtime_types ; pub type BlockNumbers = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u32 > ; pub type BestKnownBlockNumber = :: core :: option :: Option < :: core :: primitive :: u32 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_mmr_primitives :: EncodableOpaqueLeaf > , runtime_types :: sp_mmr_primitives :: LeafProof < :: subxt :: ext :: subxt_core :: utils :: H256 > ,) , runtime_types :: sp_mmr_primitives :: Error > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GenerateProof { pub block_numbers : generate_proof :: BlockNumbers , pub best_known_block_number : generate_proof :: BestKnownBlockNumber , } pub mod verify_proof { use super :: runtime_types ; pub type Leaves = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_mmr_primitives :: EncodableOpaqueLeaf > ; pub type Proof = runtime_types :: sp_mmr_primitives :: LeafProof < :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < () , runtime_types :: sp_mmr_primitives :: Error > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct VerifyProof { pub leaves : verify_proof :: Leaves , pub proof : verify_proof :: Proof , } pub mod verify_proof_stateless { use super :: runtime_types ; pub type Root = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Leaves = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_mmr_primitives :: EncodableOpaqueLeaf > ; pub type Proof = runtime_types :: sp_mmr_primitives :: LeafProof < :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < () , runtime_types :: sp_mmr_primitives :: Error > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct VerifyProofStateless { pub root : verify_proof_stateless :: Root , pub leaves : verify_proof_stateless :: Leaves , pub proof : verify_proof_stateless :: Proof , } } } pub mod genesis_builder { use super :: root_mod ; use super :: runtime_types ; # [doc = " API to interact with `RuntimeGenesisConfig` for the runtime"] pub struct GenesisBuilder ; impl GenesisBuilder { # [doc = " Build `RuntimeGenesisConfig` from a JSON blob not using any defaults and store it in the"] # [doc = " storage."] # [doc = ""] # [doc = " In the case of a FRAME-based runtime, this function deserializes the full"] # [doc = " `RuntimeGenesisConfig` from the given JSON blob and puts it into the storage. If the"] # [doc = " provided JSON blob is incorrect or incomplete or the deserialization fails, an error"] # [doc = " is returned."] # [doc = ""] # [doc = " Please note that provided JSON blob must contain all `RuntimeGenesisConfig` fields, no"] # [doc = " defaults will be used."] pub fn build_state (& self , json : types :: build_state :: Json ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: BuildState , types :: build_state :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GenesisBuilder" , "build_state" , types :: BuildState { json , } , [203u8 , 233u8 , 104u8 , 116u8 , 111u8 , 131u8 , 201u8 , 235u8 , 117u8 , 116u8 , 140u8 , 185u8 , 93u8 , 25u8 , 155u8 , 210u8 , 56u8 , 49u8 , 23u8 , 32u8 , 253u8 , 92u8 , 149u8 , 241u8 , 85u8 , 245u8 , 137u8 , 45u8 , 209u8 , 189u8 , 81u8 , 2u8 ,] ,) } # [doc = " Returns a JSON blob representation of the built-in `RuntimeGenesisConfig` identified by"] # [doc = " `id`."] # [doc = ""] # [doc = " If `id` is `None` the function should return JSON blob representation of the default"] # [doc = " `RuntimeGenesisConfig` struct of the runtime. Implementation must provide default"] # [doc = " `RuntimeGenesisConfig`."] # [doc = ""] # [doc = " Otherwise function returns a JSON representation of the built-in, named"] # [doc = " `RuntimeGenesisConfig` preset identified by `id`, or `None` if such preset does not"] # [doc = " exist. Returned `Vec<u8>` contains bytes of JSON blob (patch) which comprises a list of"] # [doc = " (potentially nested) key-value pairs that are intended for customizing the default"] # [doc = " runtime genesis config. The patch shall be merged (rfc7386) with the JSON representation"] # [doc = " of the default `RuntimeGenesisConfig` to create a comprehensive genesis config that can"] # [doc = " be used in `build_state` method."] pub fn get_preset (& self , id : types :: get_preset :: Id ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: GetPreset , types :: get_preset :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GenesisBuilder" , "get_preset" , types :: GetPreset { id , } , [43u8 , 153u8 , 23u8 , 52u8 , 113u8 , 161u8 , 227u8 , 122u8 , 169u8 , 135u8 , 119u8 , 8u8 , 128u8 , 33u8 , 143u8 , 235u8 , 13u8 , 173u8 , 58u8 , 121u8 , 178u8 , 223u8 , 66u8 , 217u8 , 22u8 , 244u8 , 168u8 , 113u8 , 202u8 , 186u8 , 241u8 , 124u8 ,] ,) } # [doc = " Returns a list of identifiers for available builtin `RuntimeGenesisConfig` presets."] # [doc = ""] # [doc = " The presets from the list can be queried with [`GenesisBuilder::get_preset`] method. If"] # [doc = " no named presets are provided by the runtime the list is empty."] pub fn preset_names (& self ,) -> :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload < types :: PresetNames , types :: preset_names :: output :: Output > { :: subxt :: ext :: subxt_core :: runtime_api :: payload :: StaticPayload :: new_static ("GenesisBuilder" , "preset_names" , types :: PresetNames { } , [150u8 , 117u8 , 54u8 , 129u8 , 221u8 , 130u8 , 186u8 , 71u8 , 13u8 , 140u8 , 77u8 , 180u8 , 141u8 , 37u8 , 22u8 , 219u8 , 149u8 , 218u8 , 186u8 , 206u8 , 80u8 , 42u8 , 165u8 , 41u8 , 99u8 , 184u8 , 73u8 , 37u8 , 125u8 , 188u8 , 167u8 , 122u8 ,] ,) } } pub mod types { use super :: runtime_types ; pub mod build_state { use super :: runtime_types ; pub type Json = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: result :: Result < () , :: subxt :: ext :: subxt_core :: alloc :: string :: String > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BuildState { pub json : build_state :: Json , } pub mod get_preset { use super :: runtime_types ; pub type Id = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: string :: String > ; pub mod output { use super :: runtime_types ; pub type Output = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct GetPreset { pub id : get_preset :: Id , } pub mod preset_names { use super :: runtime_types ; pub mod output { use super :: runtime_types ; pub type Output = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: string :: String > ; } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PresetNames { } } } } pub fn view_functions () -> ViewFunctionsApi { ViewFunctionsApi } pub fn custom () -> CustomValuesApi { CustomValuesApi } pub struct CustomValuesApi ; impl CustomValuesApi { } pub struct ConstantsApi ; impl ConstantsApi { pub fn system (& self) -> system :: constants :: ConstantsApi { system :: constants :: ConstantsApi } pub fn timestamp (& self) -> timestamp :: constants :: ConstantsApi { timestamp :: constants :: ConstantsApi } pub fn subspace (& self) -> subspace :: constants :: ConstantsApi { subspace :: constants :: ConstantsApi } pub fn rewards (& self) -> rewards :: constants :: ConstantsApi { rewards :: constants :: ConstantsApi } pub fn balances (& self) -> balances :: constants :: ConstantsApi { balances :: constants :: ConstantsApi } pub fn transaction_fees (& self) -> transaction_fees :: constants :: ConstantsApi { transaction_fees :: constants :: ConstantsApi } pub fn transaction_payment (& self) -> transaction_payment :: constants :: ConstantsApi { transaction_payment :: constants :: ConstantsApi } pub fn utility (& self) -> utility :: constants :: ConstantsApi { utility :: constants :: ConstantsApi } pub fn domains (& self) -> domains :: constants :: ConstantsApi { domains :: constants :: ConstantsApi } pub fn messenger (& self) -> messenger :: constants :: ConstantsApi { messenger :: constants :: ConstantsApi } pub fn scheduler (& self) -> scheduler :: constants :: ConstantsApi { scheduler :: constants :: ConstantsApi } pub fn council (& self) -> council :: constants :: ConstantsApi { council :: constants :: ConstantsApi } pub fn democracy (& self) -> democracy :: constants :: ConstantsApi { democracy :: constants :: ConstantsApi } pub fn multisig (& self) -> multisig :: constants :: ConstantsApi { multisig :: constants :: ConstantsApi } } pub struct StorageApi ; impl StorageApi { pub fn system (& self) -> system :: storage :: StorageApi { system :: storage :: StorageApi } pub fn timestamp (& self) -> timestamp :: storage :: StorageApi { timestamp :: storage :: StorageApi } pub fn subspace (& self) -> subspace :: storage :: StorageApi { subspace :: storage :: StorageApi } pub fn rewards (& self) -> rewards :: storage :: StorageApi { rewards :: storage :: StorageApi } pub fn balances (& self) -> balances :: storage :: StorageApi { balances :: storage :: StorageApi } pub fn transaction_fees (& self) -> transaction_fees :: storage :: StorageApi { transaction_fees :: storage :: StorageApi } pub fn transaction_payment (& self) -> transaction_payment :: storage :: StorageApi { transaction_payment :: storage :: StorageApi } pub fn domains (& self) -> domains :: storage :: StorageApi { domains :: storage :: StorageApi } pub fn runtime_configs (& self) -> runtime_configs :: storage :: StorageApi { runtime_configs :: storage :: StorageApi } pub fn mmr (& self) -> mmr :: storage :: StorageApi { mmr :: storage :: StorageApi } pub fn subspace_mmr (& self) -> subspace_mmr :: storage :: StorageApi { subspace_mmr :: storage :: StorageApi } pub fn messenger (& self) -> messenger :: storage :: StorageApi { messenger :: storage :: StorageApi } pub fn transporter (& self) -> transporter :: storage :: StorageApi { transporter :: storage :: StorageApi } pub fn scheduler (& self) -> scheduler :: storage :: StorageApi { scheduler :: storage :: StorageApi } pub fn council (& self) -> council :: storage :: StorageApi { council :: storage :: StorageApi } pub fn democracy (& self) -> democracy :: storage :: StorageApi { democracy :: storage :: StorageApi } pub fn preimage (& self) -> preimage :: storage :: StorageApi { preimage :: storage :: StorageApi } pub fn multisig (& self) -> multisig :: storage :: StorageApi { multisig :: storage :: StorageApi } pub fn sudo (& self) -> sudo :: storage :: StorageApi { sudo :: storage :: StorageApi } } pub struct TransactionApi ; impl TransactionApi { pub fn system (& self) -> system :: calls :: TransactionApi { system :: calls :: TransactionApi } pub fn timestamp (& self) -> timestamp :: calls :: TransactionApi { timestamp :: calls :: TransactionApi } pub fn subspace (& self) -> subspace :: calls :: TransactionApi { subspace :: calls :: TransactionApi } pub fn rewards (& self) -> rewards :: calls :: TransactionApi { rewards :: calls :: TransactionApi } pub fn balances (& self) -> balances :: calls :: TransactionApi { balances :: calls :: TransactionApi } pub fn utility (& self) -> utility :: calls :: TransactionApi { utility :: calls :: TransactionApi } pub fn domains (& self) -> domains :: calls :: TransactionApi { domains :: calls :: TransactionApi } pub fn runtime_configs (& self) -> runtime_configs :: calls :: TransactionApi { runtime_configs :: calls :: TransactionApi } pub fn messenger (& self) -> messenger :: calls :: TransactionApi { messenger :: calls :: TransactionApi } pub fn transporter (& self) -> transporter :: calls :: TransactionApi { transporter :: calls :: TransactionApi } pub fn scheduler (& self) -> scheduler :: calls :: TransactionApi { scheduler :: calls :: TransactionApi } pub fn council (& self) -> council :: calls :: TransactionApi { council :: calls :: TransactionApi } pub fn democracy (& self) -> democracy :: calls :: TransactionApi { democracy :: calls :: TransactionApi } pub fn preimage (& self) -> preimage :: calls :: TransactionApi { preimage :: calls :: TransactionApi } pub fn multisig (& self) -> multisig :: calls :: TransactionApi { multisig :: calls :: TransactionApi } pub fn sudo (& self) -> sudo :: calls :: TransactionApi { sudo :: calls :: TransactionApi } } pub struct ViewFunctionsApi ; impl ViewFunctionsApi { } # [doc = r" check whether the metadata provided is aligned with this statically generated code."] pub fn is_codegen_valid_for (metadata : & :: subxt :: ext :: subxt_core :: Metadata) -> bool { let runtime_metadata_hash = metadata . hasher () . only_these_pallets (& PALLETS) . only_these_runtime_apis (& RUNTIME_APIS) . hash () ; runtime_metadata_hash == [171u8 , 196u8 , 25u8 , 125u8 , 165u8 , 39u8 , 36u8 , 177u8 , 197u8 , 154u8 , 166u8 , 177u8 , 79u8 , 109u8 , 170u8 , 8u8 , 178u8 , 159u8 , 96u8 , 228u8 , 166u8 , 176u8 , 157u8 , 243u8 , 182u8 , 121u8 , 222u8 , 12u8 , 97u8 , 232u8 , 222u8 , 223u8 ,] } pub mod system { use super :: root_mod ; use super :: runtime_types ; # [doc = "Error for the System pallet"] pub type Error = runtime_types :: frame_system :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: frame_system :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "Can be executed by every `origin`."] pub struct Remark { pub remark : remark :: Remark , } pub mod remark { use super :: runtime_types ; pub type Remark = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Remark { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "remark" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the number of pages in the WebAssembly environment's heap."] pub struct SetHeapPages { pub pages : set_heap_pages :: Pages , } pub mod set_heap_pages { use super :: runtime_types ; pub type Pages = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetHeapPages { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "set_heap_pages" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the new runtime code."] pub struct SetCode { pub code : set_code :: Code , } pub mod set_code { use super :: runtime_types ; pub type Code = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetCode { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "set_code" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"] # [doc = "version!"] pub struct SetCodeWithoutChecks { pub code : set_code_without_checks :: Code , } pub mod set_code_without_checks { use super :: runtime_types ; pub type Code = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetCodeWithoutChecks { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "set_code_without_checks" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set some items of storage."] pub struct SetStorage { pub items : set_storage :: Items , } pub mod set_storage { use super :: runtime_types ; pub type Items = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetStorage { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "set_storage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Kill some items from storage."] pub struct KillStorage { pub keys : kill_storage :: Keys , } pub mod kill_storage { use super :: runtime_types ; pub type Keys = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for KillStorage { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "kill_storage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] pub struct KillPrefix { pub prefix : kill_prefix :: Prefix , pub subkeys : kill_prefix :: Subkeys , } pub mod kill_prefix { use super :: runtime_types ; pub type Prefix = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Subkeys = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for KillPrefix { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "kill_prefix" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Make some on-chain remark and emit event."] pub struct RemarkWithEvent { pub remark : remark_with_event :: Remark , } pub mod remark_with_event { use super :: runtime_types ; pub type Remark = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemarkWithEvent { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "remark_with_event" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "This call requires Root origin."] pub struct AuthorizeUpgrade { pub code_hash : authorize_upgrade :: CodeHash , } pub mod authorize_upgrade { use super :: runtime_types ; pub type CodeHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AuthorizeUpgrade { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "authorize_upgrade" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"] # [doc = "example that the spec name remains the same and that the version number increases. Not"] # [doc = "recommended for normal use. Use `authorize_upgrade` instead."] # [doc = ""] # [doc = "This call requires Root origin."] pub struct AuthorizeUpgradeWithoutChecks { pub code_hash : authorize_upgrade_without_checks :: CodeHash , } pub mod authorize_upgrade_without_checks { use super :: runtime_types ; pub type CodeHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AuthorizeUpgradeWithoutChecks { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "authorize_upgrade_without_checks" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."] # [doc = ""] # [doc = "If the authorization required a version check, this call will ensure the spec name"] # [doc = "remains unchanged and that the spec version has increased."] # [doc = ""] # [doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"] # [doc = "the new `code` in the same block or attempt to schedule the upgrade."] # [doc = ""] # [doc = "All origins are allowed."] pub struct ApplyAuthorizedUpgrade { pub code : apply_authorized_upgrade :: Code , } pub mod apply_authorized_upgrade { use super :: runtime_types ; pub type Code = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ApplyAuthorizedUpgrade { const PALLET : & 'static str = "System" ; const CALL : & 'static str = "apply_authorized_upgrade" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "Can be executed by every `origin`."] pub fn remark (& self , remark : types :: remark :: Remark ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Remark > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "remark" , types :: Remark { remark , } , [43u8 , 126u8 , 180u8 , 174u8 , 141u8 , 48u8 , 52u8 , 125u8 , 166u8 , 212u8 , 216u8 , 98u8 , 100u8 , 24u8 , 132u8 , 71u8 , 101u8 , 64u8 , 246u8 , 169u8 , 33u8 , 250u8 , 147u8 , 208u8 , 2u8 , 40u8 , 129u8 , 209u8 , 232u8 , 207u8 , 207u8 , 13u8 ,]) } # [doc = "Set the number of pages in the WebAssembly environment's heap."] pub fn set_heap_pages (& self , pages : types :: set_heap_pages :: Pages ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetHeapPages > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "set_heap_pages" , types :: SetHeapPages { pages , } , [188u8 , 191u8 , 99u8 , 216u8 , 219u8 , 109u8 , 141u8 , 50u8 , 78u8 , 235u8 , 215u8 , 242u8 , 195u8 , 24u8 , 111u8 , 76u8 , 229u8 , 64u8 , 99u8 , 225u8 , 134u8 , 121u8 , 81u8 , 209u8 , 127u8 , 223u8 , 98u8 , 215u8 , 150u8 , 70u8 , 57u8 , 147u8 ,]) } # [doc = "Set the new runtime code."] pub fn set_code (& self , code : types :: set_code :: Code ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetCode > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "set_code" , types :: SetCode { code , } , [233u8 , 248u8 , 88u8 , 245u8 , 28u8 , 65u8 , 25u8 , 169u8 , 35u8 , 237u8 , 19u8 , 203u8 , 136u8 , 160u8 , 18u8 , 3u8 , 20u8 , 197u8 , 81u8 , 169u8 , 244u8 , 188u8 , 27u8 , 147u8 , 147u8 , 236u8 , 65u8 , 25u8 , 3u8 , 143u8 , 182u8 , 22u8 ,]) } # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"] # [doc = "version!"] pub fn set_code_without_checks (& self , code : types :: set_code_without_checks :: Code ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetCodeWithoutChecks > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "set_code_without_checks" , types :: SetCodeWithoutChecks { code , } , [82u8 , 212u8 , 157u8 , 44u8 , 70u8 , 0u8 , 143u8 , 15u8 , 109u8 , 109u8 , 107u8 , 157u8 , 141u8 , 42u8 , 169u8 , 11u8 , 15u8 , 186u8 , 252u8 , 138u8 , 10u8 , 147u8 , 15u8 , 178u8 , 247u8 , 229u8 , 213u8 , 98u8 , 207u8 , 231u8 , 119u8 , 115u8 ,]) } # [doc = "Set some items of storage."] pub fn set_storage (& self , items : types :: set_storage :: Items ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetStorage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "set_storage" , types :: SetStorage { items , } , [141u8 , 216u8 , 52u8 , 222u8 , 223u8 , 136u8 , 123u8 , 181u8 , 19u8 , 75u8 , 163u8 , 102u8 , 229u8 , 189u8 , 158u8 , 142u8 , 95u8 , 235u8 , 240u8 , 49u8 , 150u8 , 76u8 , 78u8 , 137u8 , 126u8 , 88u8 , 183u8 , 88u8 , 231u8 , 146u8 , 234u8 , 43u8 ,]) } # [doc = "Kill some items from storage."] pub fn kill_storage (& self , keys : types :: kill_storage :: Keys ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: KillStorage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "kill_storage" , types :: KillStorage { keys , } , [73u8 , 63u8 , 196u8 , 36u8 , 144u8 , 114u8 , 34u8 , 213u8 , 108u8 , 93u8 , 209u8 , 234u8 , 153u8 , 185u8 , 33u8 , 91u8 , 187u8 , 195u8 , 223u8 , 130u8 , 58u8 , 156u8 , 63u8 , 47u8 , 228u8 , 249u8 , 216u8 , 139u8 , 143u8 , 177u8 , 41u8 , 35u8 ,]) } # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] pub fn kill_prefix (& self , prefix : types :: kill_prefix :: Prefix , subkeys : types :: kill_prefix :: Subkeys ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: KillPrefix > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "kill_prefix" , types :: KillPrefix { prefix , subkeys , } , [184u8 , 57u8 , 139u8 , 24u8 , 208u8 , 87u8 , 108u8 , 215u8 , 198u8 , 189u8 , 175u8 , 242u8 , 167u8 , 215u8 , 97u8 , 63u8 , 110u8 , 166u8 , 238u8 , 98u8 , 67u8 , 236u8 , 111u8 , 110u8 , 234u8 , 81u8 , 102u8 , 5u8 , 182u8 , 5u8 , 214u8 , 85u8 ,]) } # [doc = "Make some on-chain remark and emit event."] pub fn remark_with_event (& self , remark : types :: remark_with_event :: Remark ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemarkWithEvent > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "remark_with_event" , types :: RemarkWithEvent { remark , } , [120u8 , 120u8 , 153u8 , 92u8 , 184u8 , 85u8 , 34u8 , 2u8 , 174u8 , 206u8 , 105u8 , 228u8 , 233u8 , 130u8 , 80u8 , 246u8 , 228u8 , 59u8 , 234u8 , 240u8 , 4u8 , 49u8 , 147u8 , 170u8 , 115u8 , 91u8 , 149u8 , 200u8 , 228u8 , 181u8 , 8u8 , 154u8 ,]) } # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "This call requires Root origin."] pub fn authorize_upgrade (& self , code_hash : types :: authorize_upgrade :: CodeHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AuthorizeUpgrade > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "authorize_upgrade" , types :: AuthorizeUpgrade { code_hash , } , [4u8 , 14u8 , 76u8 , 107u8 , 209u8 , 129u8 , 9u8 , 39u8 , 193u8 , 17u8 , 84u8 , 254u8 , 170u8 , 214u8 , 24u8 , 155u8 , 29u8 , 184u8 , 249u8 , 241u8 , 109u8 , 58u8 , 145u8 , 131u8 , 109u8 , 63u8 , 38u8 , 165u8 , 107u8 , 215u8 , 217u8 , 172u8 ,]) } # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"] # [doc = "example that the spec name remains the same and that the version number increases. Not"] # [doc = "recommended for normal use. Use `authorize_upgrade` instead."] # [doc = ""] # [doc = "This call requires Root origin."] pub fn authorize_upgrade_without_checks (& self , code_hash : types :: authorize_upgrade_without_checks :: CodeHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AuthorizeUpgradeWithoutChecks > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "authorize_upgrade_without_checks" , types :: AuthorizeUpgradeWithoutChecks { code_hash , } , [126u8 , 126u8 , 55u8 , 26u8 , 47u8 , 55u8 , 66u8 , 8u8 , 167u8 , 18u8 , 29u8 , 136u8 , 146u8 , 14u8 , 189u8 , 117u8 , 16u8 , 227u8 , 162u8 , 61u8 , 149u8 , 197u8 , 104u8 , 184u8 , 185u8 , 161u8 , 99u8 , 154u8 , 80u8 , 125u8 , 181u8 , 233u8 ,]) } # [doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."] # [doc = ""] # [doc = "If the authorization required a version check, this call will ensure the spec name"] # [doc = "remains unchanged and that the spec version has increased."] # [doc = ""] # [doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"] # [doc = "the new `code` in the same block or attempt to schedule the upgrade."] # [doc = ""] # [doc = "All origins are allowed."] pub fn apply_authorized_upgrade (& self , code : types :: apply_authorized_upgrade :: Code ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ApplyAuthorizedUpgrade > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("System" , "apply_authorized_upgrade" , types :: ApplyAuthorizedUpgrade { code , } , [232u8 , 107u8 , 127u8 , 38u8 , 230u8 , 29u8 , 97u8 , 4u8 , 160u8 , 191u8 , 222u8 , 156u8 , 245u8 , 102u8 , 196u8 , 141u8 , 44u8 , 163u8 , 98u8 , 68u8 , 125u8 , 32u8 , 124u8 , 101u8 , 108u8 , 93u8 , 211u8 , 52u8 , 0u8 , 231u8 , 33u8 , 227u8 ,]) } } } # [doc = "Event for the System pallet."] pub type Event = runtime_types :: frame_system :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An extrinsic completed successfully."] pub struct ExtrinsicSuccess { pub dispatch_info : extrinsic_success :: DispatchInfo , } pub mod extrinsic_success { use super :: runtime_types ; pub type DispatchInfo = runtime_types :: frame_system :: DispatchEventInfo ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ExtrinsicSuccess { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicSuccess" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An extrinsic failed."] pub struct ExtrinsicFailed { pub dispatch_error : extrinsic_failed :: DispatchError , pub dispatch_info : extrinsic_failed :: DispatchInfo , } pub mod extrinsic_failed { use super :: runtime_types ; pub type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub type DispatchInfo = runtime_types :: frame_system :: DispatchEventInfo ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ExtrinsicFailed { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "`:code` was updated."] pub struct CodeUpdated ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for CodeUpdated { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "CodeUpdated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A new account was created."] pub struct NewAccount { pub account : new_account :: Account , } pub mod new_account { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NewAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "NewAccount" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account was reaped."] pub struct KilledAccount { pub account : killed_account :: Account , } pub mod killed_account { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KilledAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "KilledAccount" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "On on-chain remark happened."] pub struct Remarked { pub sender : remarked :: Sender , pub hash : remarked :: Hash , } pub mod remarked { use super :: runtime_types ; pub type Sender = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Remarked { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "Remarked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An upgrade was authorized."] pub struct UpgradeAuthorized { pub code_hash : upgrade_authorized :: CodeHash , pub check_version : upgrade_authorized :: CheckVersion , } pub mod upgrade_authorized { use super :: runtime_types ; pub type CodeHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type CheckVersion = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for UpgradeAuthorized { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "UpgradeAuthorized" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod account { use super :: runtime_types ; pub type Account = runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: types :: AccountData < :: core :: primitive :: u128 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod extrinsic_count { use super :: runtime_types ; pub type ExtrinsicCount = :: core :: primitive :: u32 ; } pub mod inherents_applied { use super :: runtime_types ; pub type InherentsApplied = :: core :: primitive :: bool ; } pub mod block_weight { use super :: runtime_types ; pub type BlockWeight = runtime_types :: frame_support :: dispatch :: PerDispatchClass < runtime_types :: sp_weights :: weight_v2 :: Weight > ; } pub mod all_extrinsics_len { use super :: runtime_types ; pub type AllExtrinsicsLen = :: core :: primitive :: u32 ; } pub mod block_hash { use super :: runtime_types ; pub type BlockHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod extrinsic_data { use super :: runtime_types ; pub type ExtrinsicData = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod number { use super :: runtime_types ; pub type Number = :: core :: primitive :: u32 ; } pub mod parent_hash { use super :: runtime_types ; pub type ParentHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod digest { use super :: runtime_types ; pub type Digest = runtime_types :: sp_runtime :: generic :: digest :: Digest ; } pub mod events { use super :: runtime_types ; pub type Events = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: subspace_runtime :: RuntimeEvent , :: subxt :: ext :: subxt_core :: utils :: H256 > > ; } pub mod event_count { use super :: runtime_types ; pub type EventCount = :: core :: primitive :: u32 ; } pub mod event_segments { use super :: runtime_types ; pub type EventSegments = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: subspace_runtime :: RuntimeEvent , :: subxt :: ext :: subxt_core :: utils :: H256 > > ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod uncleared_event_count { use super :: runtime_types ; pub type UnclearedEventCount = :: core :: primitive :: u32 ; } pub mod event_topics { use super :: runtime_types ; pub type EventTopics = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod last_runtime_upgrade { use super :: runtime_types ; pub type LastRuntimeUpgrade = runtime_types :: frame_system :: LastRuntimeUpgradeInfo ; } pub mod upgraded_to_u32_ref_count { use super :: runtime_types ; pub type UpgradedToU32RefCount = :: core :: primitive :: bool ; } pub mod upgraded_to_triple_ref_count { use super :: runtime_types ; pub type UpgradedToTripleRefCount = :: core :: primitive :: bool ; } pub mod execution_phase { use super :: runtime_types ; pub type ExecutionPhase = runtime_types :: frame_system :: Phase ; } pub mod authorized_upgrade { use super :: runtime_types ; pub type AuthorizedUpgrade = runtime_types :: frame_system :: CodeUpgradeAuthorization ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The full account information for a particular account ID."] pub fn account_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: account :: Account , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Account" , () , [85u8 , 59u8 , 75u8 , 83u8 , 12u8 , 215u8 , 34u8 , 81u8 , 222u8 , 4u8 , 88u8 , 114u8 , 235u8 , 101u8 , 148u8 , 5u8 , 140u8 , 85u8 , 91u8 , 97u8 , 190u8 , 26u8 , 86u8 , 185u8 , 171u8 , 0u8 , 137u8 , 227u8 , 223u8 , 174u8 , 144u8 , 141u8 ,]) } # [doc = " The full account information for a particular account ID."] pub fn account (& self , _0 : types :: account :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: account :: Param0 > , types :: account :: Account , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Account" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [85u8 , 59u8 , 75u8 , 83u8 , 12u8 , 215u8 , 34u8 , 81u8 , 222u8 , 4u8 , 88u8 , 114u8 , 235u8 , 101u8 , 148u8 , 5u8 , 140u8 , 85u8 , 91u8 , 97u8 , 190u8 , 26u8 , 86u8 , 185u8 , 171u8 , 0u8 , 137u8 , 227u8 , 223u8 , 174u8 , 144u8 , 141u8 ,]) } # [doc = " Total extrinsics count for the current block."] pub fn extrinsic_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: extrinsic_count :: ExtrinsicCount , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ExtrinsicCount" , () , [102u8 , 76u8 , 236u8 , 42u8 , 40u8 , 231u8 , 33u8 , 222u8 , 123u8 , 147u8 , 153u8 , 148u8 , 234u8 , 203u8 , 181u8 , 119u8 , 6u8 , 187u8 , 177u8 , 199u8 , 120u8 , 47u8 , 137u8 , 254u8 , 96u8 , 100u8 , 165u8 , 182u8 , 249u8 , 230u8 , 159u8 , 79u8 ,]) } # [doc = " Whether all inherents have been applied."] pub fn inherents_applied (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inherents_applied :: InherentsApplied , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "InherentsApplied" , () , [132u8 , 249u8 , 142u8 , 252u8 , 8u8 , 103u8 , 80u8 , 120u8 , 50u8 , 6u8 , 188u8 , 223u8 , 101u8 , 55u8 , 165u8 , 189u8 , 172u8 , 249u8 , 165u8 , 230u8 , 183u8 , 109u8 , 34u8 , 65u8 , 185u8 , 150u8 , 29u8 , 8u8 , 186u8 , 129u8 , 135u8 , 239u8 ,]) } # [doc = " The current weight for the block."] pub fn block_weight (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_weight :: BlockWeight , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "BlockWeight" , () , [158u8 , 46u8 , 228u8 , 89u8 , 210u8 , 214u8 , 84u8 , 154u8 , 50u8 , 68u8 , 63u8 , 62u8 , 43u8 , 42u8 , 99u8 , 27u8 , 54u8 , 42u8 , 146u8 , 44u8 , 241u8 , 216u8 , 229u8 , 30u8 , 216u8 , 255u8 , 165u8 , 238u8 , 181u8 , 130u8 , 36u8 , 102u8 ,]) } # [doc = " Total length (in bytes) for all extrinsics put together, for the current block."] pub fn all_extrinsics_len (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: all_extrinsics_len :: AllExtrinsicsLen , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "AllExtrinsicsLen" , () , [117u8 , 86u8 , 61u8 , 243u8 , 41u8 , 51u8 , 102u8 , 214u8 , 137u8 , 100u8 , 243u8 , 185u8 , 122u8 , 174u8 , 187u8 , 117u8 , 86u8 , 189u8 , 63u8 , 135u8 , 101u8 , 218u8 , 203u8 , 201u8 , 237u8 , 254u8 , 128u8 , 183u8 , 169u8 , 221u8 , 242u8 , 65u8 ,]) } # [doc = " Map of block numbers to block hashes."] pub fn block_hash_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_hash :: BlockHash , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "BlockHash" , () , [217u8 , 32u8 , 215u8 , 253u8 , 24u8 , 182u8 , 207u8 , 178u8 , 157u8 , 24u8 , 103u8 , 100u8 , 195u8 , 165u8 , 69u8 , 152u8 , 112u8 , 181u8 , 56u8 , 192u8 , 164u8 , 16u8 , 20u8 , 222u8 , 28u8 , 214u8 , 144u8 , 142u8 , 146u8 , 69u8 , 202u8 , 118u8 ,]) } # [doc = " Map of block numbers to block hashes."] pub fn block_hash (& self , _0 : types :: block_hash :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_hash :: Param0 > , types :: block_hash :: BlockHash , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "BlockHash" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [217u8 , 32u8 , 215u8 , 253u8 , 24u8 , 182u8 , 207u8 , 178u8 , 157u8 , 24u8 , 103u8 , 100u8 , 195u8 , 165u8 , 69u8 , 152u8 , 112u8 , 181u8 , 56u8 , 192u8 , 164u8 , 16u8 , 20u8 , 222u8 , 28u8 , 214u8 , 144u8 , 142u8 , 146u8 , 69u8 , 202u8 , 118u8 ,]) } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub fn extrinsic_data_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: extrinsic_data :: ExtrinsicData , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ExtrinsicData" , () , [160u8 , 180u8 , 122u8 , 18u8 , 196u8 , 26u8 , 2u8 , 37u8 , 115u8 , 232u8 , 133u8 , 220u8 , 106u8 , 245u8 , 4u8 , 129u8 , 42u8 , 84u8 , 241u8 , 45u8 , 199u8 , 179u8 , 128u8 , 61u8 , 170u8 , 137u8 , 231u8 , 156u8 , 247u8 , 57u8 , 47u8 , 38u8 ,]) } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub fn extrinsic_data (& self , _0 : types :: extrinsic_data :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: extrinsic_data :: Param0 > , types :: extrinsic_data :: ExtrinsicData , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ExtrinsicData" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [160u8 , 180u8 , 122u8 , 18u8 , 196u8 , 26u8 , 2u8 , 37u8 , 115u8 , 232u8 , 133u8 , 220u8 , 106u8 , 245u8 , 4u8 , 129u8 , 42u8 , 84u8 , 241u8 , 45u8 , 199u8 , 179u8 , 128u8 , 61u8 , 170u8 , 137u8 , 231u8 , 156u8 , 247u8 , 57u8 , 47u8 , 38u8 ,]) } # [doc = " The current block number being processed. Set by `execute_block`."] pub fn number (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: number :: Number , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Number" , () , [30u8 , 194u8 , 177u8 , 90u8 , 194u8 , 232u8 , 46u8 , 180u8 , 85u8 , 129u8 , 14u8 , 9u8 , 8u8 , 8u8 , 23u8 , 95u8 , 230u8 , 5u8 , 13u8 , 105u8 , 125u8 , 2u8 , 22u8 , 200u8 , 78u8 , 93u8 , 115u8 , 28u8 , 150u8 , 113u8 , 48u8 , 53u8 ,]) } # [doc = " Hash of the previous block."] pub fn parent_hash (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: parent_hash :: ParentHash , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ParentHash" , () , [26u8 , 130u8 , 11u8 , 216u8 , 155u8 , 71u8 , 128u8 , 170u8 , 30u8 , 153u8 , 21u8 , 192u8 , 62u8 , 93u8 , 137u8 , 80u8 , 120u8 , 81u8 , 202u8 , 94u8 , 248u8 , 125u8 , 71u8 , 82u8 , 141u8 , 229u8 , 32u8 , 56u8 , 73u8 , 50u8 , 101u8 , 78u8 ,]) } # [doc = " Digest of the current block, also part of the block header."] pub fn digest (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: digest :: Digest , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Digest" , () , [61u8 , 64u8 , 237u8 , 91u8 , 145u8 , 232u8 , 17u8 , 254u8 , 181u8 , 16u8 , 234u8 , 91u8 , 51u8 , 140u8 , 254u8 , 131u8 , 98u8 , 135u8 , 21u8 , 37u8 , 251u8 , 20u8 , 58u8 , 92u8 , 123u8 , 141u8 , 14u8 , 227u8 , 146u8 , 46u8 , 222u8 , 117u8 ,]) } # [doc = " Events deposited for the current block."] # [doc = ""] # [doc = " NOTE: The item is unbound and should therefore never be read on chain."] # [doc = " It could otherwise inflate the PoV size of a block."] # [doc = ""] # [doc = " Events have a large in-memory size. Box the events to not go out-of-memory"] # [doc = " just in case someone still reads them from within the runtime."] pub fn events (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: events :: Events , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "Events" , () , [55u8 , 29u8 , 21u8 , 88u8 , 168u8 , 40u8 , 105u8 , 229u8 , 207u8 , 87u8 , 93u8 , 149u8 , 160u8 , 239u8 , 107u8 , 64u8 , 227u8 , 199u8 , 159u8 , 116u8 , 92u8 , 161u8 , 142u8 , 86u8 , 106u8 , 203u8 , 170u8 , 59u8 , 52u8 , 190u8 , 128u8 , 5u8 ,]) } # [doc = " The number of events in the `Events<T>` list."] pub fn event_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: event_count :: EventCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "EventCount" , () , [175u8 , 24u8 , 252u8 , 184u8 , 210u8 , 167u8 , 146u8 , 143u8 , 164u8 , 80u8 , 151u8 , 205u8 , 189u8 , 189u8 , 55u8 , 220u8 , 47u8 , 101u8 , 181u8 , 33u8 , 254u8 , 131u8 , 13u8 , 143u8 , 3u8 , 244u8 , 245u8 , 45u8 , 2u8 , 210u8 , 79u8 , 133u8 ,]) } # [doc = " Similar to `Events`, storing events deposited for the current block but `EventSegmentSize`"] # [doc = " number of events are stored together in an item (under the same key) in the map."] # [doc = ""] # [doc = " For an event with event index `i`, it is stored in the segment under key `i / EventSegmentSize`"] # [doc = " in the map and index `i % EventSegmentSize` in the segment."] # [doc = ""] # [doc = " NOTE: The event segment from the previous blocks is not cleared but instead overwritten"] # [doc = " by event deposited later, only the first `EventCount` number of events in the map are"] # [doc = " deposited by the current block."] pub fn event_segments_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: event_segments :: EventSegments , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "EventSegments" , () , [65u8 , 240u8 , 120u8 , 163u8 , 150u8 , 241u8 , 232u8 , 253u8 , 169u8 , 49u8 , 24u8 , 60u8 , 77u8 , 31u8 , 43u8 , 115u8 , 145u8 , 188u8 , 157u8 , 83u8 , 74u8 , 42u8 , 39u8 , 99u8 , 161u8 , 74u8 , 77u8 , 205u8 , 137u8 , 118u8 , 99u8 , 48u8 ,]) } # [doc = " Similar to `Events`, storing events deposited for the current block but `EventSegmentSize`"] # [doc = " number of events are stored together in an item (under the same key) in the map."] # [doc = ""] # [doc = " For an event with event index `i`, it is stored in the segment under key `i / EventSegmentSize`"] # [doc = " in the map and index `i % EventSegmentSize` in the segment."] # [doc = ""] # [doc = " NOTE: The event segment from the previous blocks is not cleared but instead overwritten"] # [doc = " by event deposited later, only the first `EventCount` number of events in the map are"] # [doc = " deposited by the current block."] pub fn event_segments (& self , _0 : types :: event_segments :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: event_segments :: Param0 > , types :: event_segments :: EventSegments , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "EventSegments" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [65u8 , 240u8 , 120u8 , 163u8 , 150u8 , 241u8 , 232u8 , 253u8 , 169u8 , 49u8 , 24u8 , 60u8 , 77u8 , 31u8 , 43u8 , 115u8 , 145u8 , 188u8 , 157u8 , 83u8 , 74u8 , 42u8 , 39u8 , 99u8 , 161u8 , 74u8 , 77u8 , 205u8 , 137u8 , 118u8 , 99u8 , 48u8 ,]) } # [doc = " The total number of uncleared events from the previous blocks."] pub fn uncleared_event_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: uncleared_event_count :: UnclearedEventCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "UnclearedEventCount" , () , [194u8 , 52u8 , 159u8 , 55u8 , 146u8 , 226u8 , 91u8 , 207u8 , 158u8 , 144u8 , 51u8 , 76u8 , 158u8 , 242u8 , 255u8 , 94u8 , 30u8 , 152u8 , 148u8 , 192u8 , 183u8 , 8u8 , 13u8 , 176u8 , 111u8 , 77u8 , 253u8 , 234u8 , 35u8 , 213u8 , 220u8 , 121u8 ,]) } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub fn event_topics_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: event_topics :: EventTopics , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "EventTopics" , () , [40u8 , 225u8 , 14u8 , 75u8 , 44u8 , 176u8 , 76u8 , 34u8 , 143u8 , 107u8 , 69u8 , 133u8 , 114u8 , 13u8 , 172u8 , 250u8 , 141u8 , 73u8 , 12u8 , 65u8 , 217u8 , 63u8 , 120u8 , 241u8 , 48u8 , 106u8 , 143u8 , 161u8 , 128u8 , 100u8 , 166u8 , 59u8 ,]) } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub fn event_topics (& self , _0 : types :: event_topics :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: event_topics :: Param0 > , types :: event_topics :: EventTopics , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "EventTopics" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [40u8 , 225u8 , 14u8 , 75u8 , 44u8 , 176u8 , 76u8 , 34u8 , 143u8 , 107u8 , 69u8 , 133u8 , 114u8 , 13u8 , 172u8 , 250u8 , 141u8 , 73u8 , 12u8 , 65u8 , 217u8 , 63u8 , 120u8 , 241u8 , 48u8 , 106u8 , 143u8 , 161u8 , 128u8 , 100u8 , 166u8 , 59u8 ,]) } # [doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."] pub fn last_runtime_upgrade (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_runtime_upgrade :: LastRuntimeUpgrade , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "LastRuntimeUpgrade" , () , [197u8 , 212u8 , 249u8 , 209u8 , 79u8 , 34u8 , 55u8 , 203u8 , 31u8 , 42u8 , 199u8 , 242u8 , 188u8 , 74u8 , 234u8 , 250u8 , 245u8 , 44u8 , 139u8 , 162u8 , 45u8 , 150u8 , 230u8 , 249u8 , 135u8 , 100u8 , 158u8 , 167u8 , 118u8 , 219u8 , 28u8 , 98u8 ,]) } # [doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."] pub fn upgraded_to_u32_ref_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: upgraded_to_u32_ref_count :: UpgradedToU32RefCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "UpgradedToU32RefCount" , () , [229u8 , 73u8 , 9u8 , 132u8 , 186u8 , 116u8 , 151u8 , 171u8 , 145u8 , 29u8 , 34u8 , 130u8 , 52u8 , 146u8 , 124u8 , 175u8 , 79u8 , 189u8 , 147u8 , 230u8 , 234u8 , 107u8 , 124u8 , 31u8 , 2u8 , 22u8 , 86u8 , 190u8 , 4u8 , 147u8 , 50u8 , 245u8 ,]) } # [doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"] # [doc = " (default) if not."] pub fn upgraded_to_triple_ref_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: upgraded_to_triple_ref_count :: UpgradedToTripleRefCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "UpgradedToTripleRefCount" , () , [97u8 , 66u8 , 124u8 , 243u8 , 27u8 , 167u8 , 147u8 , 81u8 , 254u8 , 201u8 , 101u8 , 24u8 , 40u8 , 231u8 , 14u8 , 179u8 , 154u8 , 163u8 , 71u8 , 81u8 , 185u8 , 167u8 , 82u8 , 254u8 , 189u8 , 3u8 , 101u8 , 207u8 , 206u8 , 194u8 , 155u8 , 151u8 ,]) } # [doc = " The execution phase of the block."] pub fn execution_phase (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: execution_phase :: ExecutionPhase , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "ExecutionPhase" , () , [191u8 , 129u8 , 100u8 , 134u8 , 126u8 , 116u8 , 154u8 , 203u8 , 220u8 , 200u8 , 0u8 , 26u8 , 161u8 , 250u8 , 133u8 , 205u8 , 146u8 , 24u8 , 5u8 , 156u8 , 158u8 , 35u8 , 36u8 , 253u8 , 52u8 , 235u8 , 86u8 , 167u8 , 35u8 , 100u8 , 119u8 , 27u8 ,]) } # [doc = " `Some` if a code upgrade has been authorized."] pub fn authorized_upgrade (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: authorized_upgrade :: AuthorizedUpgrade , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("System" , "AuthorizedUpgrade" , () , [165u8 , 97u8 , 27u8 , 138u8 , 2u8 , 28u8 , 55u8 , 92u8 , 96u8 , 96u8 , 168u8 , 169u8 , 55u8 , 178u8 , 44u8 , 127u8 , 58u8 , 140u8 , 206u8 , 178u8 , 1u8 , 37u8 , 214u8 , 213u8 , 251u8 , 123u8 , 5u8 , 111u8 , 90u8 , 148u8 , 217u8 , 135u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Block & extrinsics weights: base values and limits."] pub fn block_weights (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: frame_system :: limits :: BlockWeights > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "BlockWeights" , [176u8 , 124u8 , 225u8 , 136u8 , 25u8 , 73u8 , 247u8 , 33u8 , 82u8 , 206u8 , 85u8 , 190u8 , 127u8 , 102u8 , 71u8 , 11u8 , 185u8 , 8u8 , 58u8 , 0u8 , 94u8 , 55u8 , 163u8 , 177u8 , 104u8 , 59u8 , 60u8 , 136u8 , 246u8 , 116u8 , 0u8 , 239u8 ,]) } # [doc = " The maximum length of a block (in bytes)."] pub fn block_length (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: frame_system :: limits :: BlockLength > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "BlockLength" , [23u8 , 242u8 , 225u8 , 39u8 , 225u8 , 67u8 , 152u8 , 41u8 , 155u8 , 104u8 , 68u8 , 229u8 , 185u8 , 133u8 , 10u8 , 143u8 , 184u8 , 152u8 , 234u8 , 44u8 , 140u8 , 96u8 , 166u8 , 235u8 , 162u8 , 160u8 , 72u8 , 7u8 , 35u8 , 194u8 , 3u8 , 37u8 ,]) } # [doc = " Maximum number of block number to block hash mappings to keep (oldest pruned first)."] pub fn block_hash_count (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "BlockHashCount" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The weight of runtime database operations the runtime can invoke."] pub fn db_weight (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_weights :: RuntimeDbWeight > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "DbWeight" , [42u8 , 43u8 , 178u8 , 142u8 , 243u8 , 203u8 , 60u8 , 173u8 , 118u8 , 111u8 , 200u8 , 170u8 , 102u8 , 70u8 , 237u8 , 187u8 , 198u8 , 120u8 , 153u8 , 232u8 , 183u8 , 76u8 , 74u8 , 10u8 , 70u8 , 243u8 , 14u8 , 218u8 , 213u8 , 126u8 , 29u8 , 177u8 ,]) } # [doc = " Get the chain's in-code version."] pub fn version (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_version :: RuntimeVersion > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "Version" , [214u8 , 43u8 , 96u8 , 193u8 , 96u8 , 213u8 , 63u8 , 124u8 , 22u8 , 111u8 , 41u8 , 78u8 , 146u8 , 77u8 , 34u8 , 163u8 , 117u8 , 100u8 , 6u8 , 216u8 , 238u8 , 54u8 , 80u8 , 185u8 , 219u8 , 11u8 , 192u8 , 200u8 , 129u8 , 88u8 , 161u8 , 250u8 ,]) } # [doc = " The designated SS58 prefix of this chain."] # [doc = ""] # [doc = " This replaces the \"ss58Format\" property declared in the chain spec. Reason is"] # [doc = " that the runtime should know about the prefix in order to make use of it as"] # [doc = " an identifier of the chain."] pub fn ss58_prefix (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "SS58Prefix" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " The number of events stored together in a segment."] # [doc = ""] # [doc = " When set to zero all the events are stored in a single storage value `Events` under one key,"] # [doc = " when set to a non-zero value `N`, `N` number of events will be stored together in a segment"] # [doc = " under one key in the storage map `EventSegments`."] # [doc = ""] # [doc = " Given the same amount of event, the smaller this value the smaller the segment and thus a smaller"] # [doc = " storage proof for a specific event, but as the number of segment increases and there will be more"] # [doc = " key-value added to the Trie and may impact the performance."] pub fn event_segment_size (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("System" , "EventSegmentSize" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod timestamp { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_timestamp :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "[`Config::MinimumPeriod`]."] # [doc = ""] # [doc = "The dispatch origin for this call must be _None_."] # [doc = ""] # [doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"] # [doc = "that changing the complexity of this call could result exhausting the resources in a"] # [doc = "block to execute any other calls."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] pub struct Set { # [codec (compact)] pub now : set :: Now , } pub mod set { use super :: runtime_types ; pub type Now = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Set { const PALLET : & 'static str = "Timestamp" ; const CALL : & 'static str = "set" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "[`Config::MinimumPeriod`]."] # [doc = ""] # [doc = "The dispatch origin for this call must be _None_."] # [doc = ""] # [doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"] # [doc = "that changing the complexity of this call could result exhausting the resources in a"] # [doc = "block to execute any other calls."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] pub fn set (& self , now : types :: set :: Now ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Set > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Timestamp" , "set" , types :: Set { now , } , [37u8 , 95u8 , 49u8 , 218u8 , 24u8 , 22u8 , 0u8 , 95u8 , 72u8 , 35u8 , 155u8 , 199u8 , 213u8 , 54u8 , 207u8 , 22u8 , 185u8 , 193u8 , 221u8 , 70u8 , 18u8 , 200u8 , 4u8 , 231u8 , 195u8 , 173u8 , 6u8 , 122u8 , 11u8 , 203u8 , 231u8 , 227u8 ,]) } } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod now { use super :: runtime_types ; pub type Now = :: core :: primitive :: u64 ; } pub mod did_update { use super :: runtime_types ; pub type DidUpdate = :: core :: primitive :: bool ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The current time for the current block."] pub fn now (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: now :: Now , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Timestamp" , "Now" , () , [44u8 , 50u8 , 80u8 , 30u8 , 195u8 , 146u8 , 123u8 , 238u8 , 8u8 , 163u8 , 187u8 , 92u8 , 61u8 , 39u8 , 51u8 , 29u8 , 173u8 , 169u8 , 217u8 , 158u8 , 85u8 , 187u8 , 141u8 , 26u8 , 12u8 , 115u8 , 51u8 , 11u8 , 200u8 , 244u8 , 138u8 , 152u8 ,]) } # [doc = " Whether the timestamp has been updated in this block."] # [doc = ""] # [doc = " This value is updated to `true` upon successful submission of a timestamp by a node."] # [doc = " It is then checked at the end of each block execution in the `on_finalize` hook."] pub fn did_update (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: did_update :: DidUpdate , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Timestamp" , "DidUpdate" , () , [229u8 , 175u8 , 246u8 , 102u8 , 237u8 , 158u8 , 212u8 , 229u8 , 238u8 , 214u8 , 205u8 , 160u8 , 164u8 , 252u8 , 195u8 , 75u8 , 139u8 , 110u8 , 22u8 , 34u8 , 248u8 , 204u8 , 107u8 , 46u8 , 20u8 , 200u8 , 238u8 , 167u8 , 71u8 , 41u8 , 214u8 , 140u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum period between blocks."] # [doc = ""] # [doc = " Be aware that this is different to the *expected* period that the block production"] # [doc = " apparatus provides. Your chosen consensus system will generally work with this to"] # [doc = " determine a sensible block time. For example, in the Aura pallet it will be double this"] # [doc = " period on default settings."] pub fn minimum_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Timestamp" , "MinimumPeriod" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod subspace { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_subspace :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_subspace :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Submit new segment header to the blockchain. This is an inherent extrinsic and part of"] # [doc = "the Subspace consensus logic."] pub struct StoreSegmentHeaders { pub segment_headers : store_segment_headers :: SegmentHeaders , } pub mod store_segment_headers { use super :: runtime_types ; pub type SegmentHeaders = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_core_primitives :: segments :: SegmentHeader > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for StoreSegmentHeaders { const PALLET : & 'static str = "Subspace" ; const CALL : & 'static str = "store_segment_headers" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Enable solution range adjustment after every era."] # [doc = "Note: No effect on the solution range for the current era"] pub struct EnableSolutionRangeAdjustment { pub solution_range_override : enable_solution_range_adjustment :: SolutionRangeOverride , pub voting_solution_range_override : enable_solution_range_adjustment :: VotingSolutionRangeOverride , } pub mod enable_solution_range_adjustment { use super :: runtime_types ; pub type SolutionRangeOverride = :: core :: option :: Option < :: core :: primitive :: u64 > ; pub type VotingSolutionRangeOverride = :: core :: option :: Option < :: core :: primitive :: u64 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for EnableSolutionRangeAdjustment { const PALLET : & 'static str = "Subspace" ; const CALL : & 'static str = "enable_solution_range_adjustment" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Farmer vote, currently only used for extra rewards to farmers."] pub struct Vote { pub signed_vote : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < vote :: SignedVote > , } pub mod vote { use super :: runtime_types ; pub type SignedVote = runtime_types :: sp_consensus_subspace :: SignedVote < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Vote { const PALLET : & 'static str = "Subspace" ; const CALL : & 'static str = "vote" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Enable rewards for blocks and votes at specified block height."] pub struct EnableRewardsAt { pub enable_rewards_at : enable_rewards_at :: EnableRewardsAt , } pub mod enable_rewards_at { use super :: runtime_types ; pub type EnableRewardsAt = runtime_types :: pallet_subspace :: pallet :: EnableRewardsAt < :: core :: primitive :: u32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for EnableRewardsAt { const PALLET : & 'static str = "Subspace" ; const CALL : & 'static str = "enable_rewards_at" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Enable storage access for all users."] pub struct EnableAuthoringByAnyone ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for EnableAuthoringByAnyone { const PALLET : & 'static str = "Subspace" ; const CALL : & 'static str = "enable_authoring_by_anyone" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Update proof of time slot iterations"] pub struct SetPotSlotIterations { pub slot_iterations : set_pot_slot_iterations :: SlotIterations , } pub mod set_pot_slot_iterations { use super :: runtime_types ; pub type SlotIterations = :: core :: num :: NonZeroU32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetPotSlotIterations { const PALLET : & 'static str = "Subspace" ; const CALL : & 'static str = "set_pot_slot_iterations" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Submit new segment header to the blockchain. This is an inherent extrinsic and part of"] # [doc = "the Subspace consensus logic."] pub fn store_segment_headers (& self , segment_headers : types :: store_segment_headers :: SegmentHeaders ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: StoreSegmentHeaders > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Subspace" , "store_segment_headers" , types :: StoreSegmentHeaders { segment_headers , } , [35u8 , 9u8 , 72u8 , 99u8 , 93u8 , 81u8 , 93u8 , 89u8 , 173u8 , 20u8 , 23u8 , 196u8 , 94u8 , 19u8 , 51u8 , 36u8 , 85u8 , 191u8 , 18u8 , 164u8 , 247u8 , 187u8 , 107u8 , 22u8 , 247u8 , 223u8 , 103u8 , 254u8 , 196u8 , 234u8 , 48u8 , 115u8 ,]) } # [doc = "Enable solution range adjustment after every era."] # [doc = "Note: No effect on the solution range for the current era"] pub fn enable_solution_range_adjustment (& self , solution_range_override : types :: enable_solution_range_adjustment :: SolutionRangeOverride , voting_solution_range_override : types :: enable_solution_range_adjustment :: VotingSolutionRangeOverride ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: EnableSolutionRangeAdjustment > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Subspace" , "enable_solution_range_adjustment" , types :: EnableSolutionRangeAdjustment { solution_range_override , voting_solution_range_override , } , [154u8 , 170u8 , 145u8 , 223u8 , 144u8 , 24u8 , 172u8 , 101u8 , 57u8 , 119u8 , 124u8 , 238u8 , 162u8 , 210u8 , 244u8 , 53u8 , 106u8 , 185u8 , 238u8 , 50u8 , 45u8 , 133u8 , 4u8 , 197u8 , 175u8 , 13u8 , 82u8 , 20u8 , 178u8 , 181u8 , 32u8 , 110u8 ,]) } # [doc = "Farmer vote, currently only used for extra rewards to farmers."] pub fn vote (& self , signed_vote : types :: vote :: SignedVote ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Vote > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Subspace" , "vote" , types :: Vote { signed_vote : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (signed_vote) , } , [247u8 , 31u8 , 129u8 , 127u8 , 69u8 , 161u8 , 234u8 , 44u8 , 63u8 , 44u8 , 125u8 , 115u8 , 88u8 , 204u8 , 33u8 , 101u8 , 131u8 , 34u8 , 65u8 , 97u8 , 32u8 , 171u8 , 5u8 , 62u8 , 190u8 , 81u8 , 160u8 , 170u8 , 61u8 , 6u8 , 33u8 , 228u8 ,]) } # [doc = "Enable rewards for blocks and votes at specified block height."] pub fn enable_rewards_at (& self , enable_rewards_at : types :: enable_rewards_at :: EnableRewardsAt ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: EnableRewardsAt > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Subspace" , "enable_rewards_at" , types :: EnableRewardsAt { enable_rewards_at , } , [4u8 , 140u8 , 41u8 , 119u8 , 153u8 , 98u8 , 9u8 , 76u8 , 78u8 , 200u8 , 125u8 , 114u8 , 21u8 , 167u8 , 170u8 , 127u8 , 21u8 , 185u8 , 70u8 , 45u8 , 104u8 , 99u8 , 235u8 , 119u8 , 116u8 , 156u8 , 246u8 , 120u8 , 2u8 , 224u8 , 250u8 , 239u8 ,]) } # [doc = "Enable storage access for all users."] pub fn enable_authoring_by_anyone (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: EnableAuthoringByAnyone > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Subspace" , "enable_authoring_by_anyone" , types :: EnableAuthoringByAnyone { } , [91u8 , 177u8 , 99u8 , 24u8 , 113u8 , 108u8 , 146u8 , 195u8 , 91u8 , 139u8 , 196u8 , 109u8 , 255u8 , 213u8 , 43u8 , 87u8 , 143u8 , 99u8 , 196u8 , 182u8 , 124u8 , 83u8 , 99u8 , 231u8 , 113u8 , 212u8 , 100u8 , 228u8 , 141u8 , 11u8 , 153u8 , 157u8 ,]) } # [doc = "Update proof of time slot iterations"] pub fn set_pot_slot_iterations (& self , slot_iterations : types :: set_pot_slot_iterations :: SlotIterations ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetPotSlotIterations > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Subspace" , "set_pot_slot_iterations" , types :: SetPotSlotIterations { slot_iterations , } , [101u8 , 165u8 , 50u8 , 81u8 , 146u8 , 130u8 , 35u8 , 7u8 , 10u8 , 143u8 , 141u8 , 4u8 , 153u8 , 13u8 , 181u8 , 233u8 , 186u8 , 67u8 , 76u8 , 227u8 , 247u8 , 12u8 , 96u8 , 235u8 , 238u8 , 147u8 , 48u8 , 25u8 , 117u8 , 217u8 , 192u8 , 134u8 ,]) } } } # [doc = "Events type."] pub type Event = runtime_types :: pallet_subspace :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Segment header was stored in blockchain history."] pub struct SegmentHeaderStored { pub segment_header : segment_header_stored :: SegmentHeader , } pub mod segment_header_stored { use super :: runtime_types ; pub type SegmentHeader = runtime_types :: subspace_core_primitives :: segments :: SegmentHeader ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SegmentHeaderStored { const PALLET : & 'static str = "Subspace" ; const EVENT : & 'static str = "SegmentHeaderStored" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Farmer vote."] pub struct FarmerVote { pub public_key : farmer_vote :: PublicKey , pub reward_address : farmer_vote :: RewardAddress , pub height : farmer_vote :: Height , pub parent_hash : farmer_vote :: ParentHash , } pub mod farmer_vote { use super :: runtime_types ; pub type PublicKey = runtime_types :: subspace_core_primitives :: PublicKey ; pub type RewardAddress = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Height = :: core :: primitive :: u32 ; pub type ParentHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for FarmerVote { const PALLET : & 'static str = "Subspace" ; const EVENT : & 'static str = "FarmerVote" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod block_slots { use super :: runtime_types ; pub type BlockSlots = runtime_types :: bounded_collections :: bounded_btree_map :: BoundedBTreeMap < :: core :: primitive :: u32 , runtime_types :: sp_consensus_slots :: Slot > ; } pub mod solution_ranges { use super :: runtime_types ; pub type SolutionRanges = runtime_types :: sp_consensus_subspace :: SolutionRanges ; } pub mod should_adjust_solution_range { use super :: runtime_types ; pub type ShouldAdjustSolutionRange = :: core :: primitive :: bool ; } pub mod next_solution_range_override { use super :: runtime_types ; pub type NextSolutionRangeOverride = runtime_types :: pallet_subspace :: pallet :: SolutionRangeOverride ; } pub mod era_start_slot { use super :: runtime_types ; pub type EraStartSlot = runtime_types :: sp_consensus_slots :: Slot ; } pub mod segment_commitment { use super :: runtime_types ; pub type SegmentCommitment = runtime_types :: subspace_core_primitives :: segments :: SegmentCommitment ; pub type Param0 = runtime_types :: subspace_core_primitives :: segments :: SegmentIndex ; } pub mod counter_for_segment_commitment { use super :: runtime_types ; pub type CounterForSegmentCommitment = :: core :: primitive :: u32 ; } pub mod did_process_segment_headers { use super :: runtime_types ; pub type DidProcessSegmentHeaders = :: core :: primitive :: bool ; } pub mod parent_vote_verification_data { use super :: runtime_types ; pub type ParentVoteVerificationData = runtime_types :: pallet_subspace :: VoteVerificationData ; } pub mod parent_block_author_info { use super :: runtime_types ; pub type ParentBlockAuthorInfo = (runtime_types :: subspace_core_primitives :: PublicKey , :: core :: primitive :: u16 , runtime_types :: subspace_core_primitives :: pieces :: PieceOffset , runtime_types :: subspace_core_primitives :: ScalarBytes , runtime_types :: sp_consensus_slots :: Slot ,) ; } pub mod enable_rewards { use super :: runtime_types ; pub type EnableRewards = :: core :: primitive :: u32 ; } pub mod enable_rewards_below_solution_range { use super :: runtime_types ; pub type EnableRewardsBelowSolutionRange = :: core :: primitive :: u64 ; } pub mod current_block_author_info { use super :: runtime_types ; pub type CurrentBlockAuthorInfo = (runtime_types :: subspace_core_primitives :: PublicKey , :: core :: primitive :: u16 , runtime_types :: subspace_core_primitives :: pieces :: PieceOffset , runtime_types :: subspace_core_primitives :: ScalarBytes , runtime_types :: sp_consensus_slots :: Slot , :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ,) ; } pub mod parent_block_voters { use super :: runtime_types ; pub type ParentBlockVoters = :: subxt :: ext :: subxt_core :: utils :: KeyedVec < (runtime_types :: subspace_core_primitives :: PublicKey , :: core :: primitive :: u16 , runtime_types :: subspace_core_primitives :: pieces :: PieceOffset , runtime_types :: subspace_core_primitives :: ScalarBytes , runtime_types :: sp_consensus_slots :: Slot ,) , (:: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , runtime_types :: subspace_core_primitives :: solutions :: RewardSignature ,) > ; } pub mod current_block_voters { use super :: runtime_types ; pub type CurrentBlockVoters = :: subxt :: ext :: subxt_core :: utils :: KeyedVec < (runtime_types :: subspace_core_primitives :: PublicKey , :: core :: primitive :: u16 , runtime_types :: subspace_core_primitives :: pieces :: PieceOffset , runtime_types :: subspace_core_primitives :: ScalarBytes , runtime_types :: sp_consensus_slots :: Slot ,) , (:: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , runtime_types :: subspace_core_primitives :: solutions :: RewardSignature ,) > ; } pub mod pot_slot_iterations { use super :: runtime_types ; pub type PotSlotIterations = runtime_types :: pallet_subspace :: pallet :: PotSlotIterationsValue ; } pub mod pot_entropy { use super :: runtime_types ; pub type PotEntropy = :: subxt :: ext :: subxt_core :: utils :: KeyedVec < :: core :: primitive :: u32 , runtime_types :: pallet_subspace :: pallet :: PotEntropyValue > ; } pub mod block_randomness { use super :: runtime_types ; pub type BlockRandomness = runtime_types :: subspace_core_primitives :: Randomness ; } pub mod allow_authoring_by_anyone { use super :: runtime_types ; pub type AllowAuthoringByAnyone = :: core :: primitive :: bool ; } pub mod root_plot_public_key { use super :: runtime_types ; pub type RootPlotPublicKey = runtime_types :: subspace_core_primitives :: PublicKey ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Bounded mapping from block number to slot"] pub fn block_slots (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_slots :: BlockSlots , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "BlockSlots" , () , [175u8 , 132u8 , 66u8 , 177u8 , 104u8 , 156u8 , 61u8 , 231u8 , 15u8 , 27u8 , 223u8 , 210u8 , 96u8 , 139u8 , 21u8 , 210u8 , 236u8 , 204u8 , 188u8 , 94u8 , 156u8 , 26u8 , 219u8 , 251u8 , 120u8 , 8u8 , 82u8 , 168u8 , 198u8 , 19u8 , 85u8 , 41u8 ,]) } # [doc = " Solution ranges used for challenges."] pub fn solution_ranges (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: solution_ranges :: SolutionRanges , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "SolutionRanges" , () , [17u8 , 134u8 , 28u8 , 8u8 , 100u8 , 130u8 , 195u8 , 157u8 , 22u8 , 195u8 , 183u8 , 44u8 , 190u8 , 75u8 , 183u8 , 113u8 , 203u8 , 162u8 , 50u8 , 77u8 , 176u8 , 212u8 , 189u8 , 139u8 , 43u8 , 112u8 , 24u8 , 85u8 , 253u8 , 136u8 , 7u8 , 198u8 ,]) } # [doc = " Storage to check if the solution range is to be adjusted for next era"] pub fn should_adjust_solution_range (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: should_adjust_solution_range :: ShouldAdjustSolutionRange , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "ShouldAdjustSolutionRange" , () , [142u8 , 100u8 , 214u8 , 226u8 , 248u8 , 6u8 , 61u8 , 175u8 , 82u8 , 118u8 , 150u8 , 195u8 , 191u8 , 215u8 , 164u8 , 27u8 , 179u8 , 16u8 , 75u8 , 94u8 , 232u8 , 156u8 , 167u8 , 251u8 , 1u8 , 216u8 , 83u8 , 50u8 , 66u8 , 167u8 , 247u8 , 105u8 ,]) } # [doc = " Override solution range during next update"] pub fn next_solution_range_override (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_solution_range_override :: NextSolutionRangeOverride , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "NextSolutionRangeOverride" , () , [198u8 , 212u8 , 188u8 , 0u8 , 203u8 , 181u8 , 93u8 , 157u8 , 251u8 , 209u8 , 210u8 , 78u8 , 221u8 , 150u8 , 134u8 , 3u8 , 109u8 , 124u8 , 11u8 , 209u8 , 215u8 , 55u8 , 83u8 , 135u8 , 36u8 , 82u8 , 46u8 , 156u8 , 28u8 , 130u8 , 202u8 , 236u8 ,]) } # [doc = " Slot at which current era started."] pub fn era_start_slot (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: era_start_slot :: EraStartSlot , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "EraStartSlot" , () , [184u8 , 229u8 , 248u8 , 128u8 , 61u8 , 87u8 , 49u8 , 33u8 , 84u8 , 253u8 , 134u8 , 173u8 , 248u8 , 247u8 , 253u8 , 211u8 , 57u8 , 23u8 , 240u8 , 2u8 , 62u8 , 227u8 , 223u8 , 222u8 , 243u8 , 88u8 , 145u8 , 93u8 , 151u8 , 38u8 , 212u8 , 20u8 ,]) } # [doc = " Mapping from segment index to corresponding segment commitment of contained records."] pub fn segment_commitment_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: segment_commitment :: SegmentCommitment , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "SegmentCommitment" , () , [122u8 , 170u8 , 133u8 , 68u8 , 21u8 , 237u8 , 97u8 , 29u8 , 42u8 , 79u8 , 236u8 , 154u8 , 209u8 , 242u8 , 186u8 , 16u8 , 161u8 , 0u8 , 229u8 , 119u8 , 183u8 , 220u8 , 186u8 , 80u8 , 60u8 , 7u8 , 88u8 , 30u8 , 26u8 , 132u8 , 198u8 , 66u8 ,]) } # [doc = " Mapping from segment index to corresponding segment commitment of contained records."] pub fn segment_commitment (& self , _0 : types :: segment_commitment :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: segment_commitment :: Param0 > , types :: segment_commitment :: SegmentCommitment , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "SegmentCommitment" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [122u8 , 170u8 , 133u8 , 68u8 , 21u8 , 237u8 , 97u8 , 29u8 , 42u8 , 79u8 , 236u8 , 154u8 , 209u8 , 242u8 , 186u8 , 16u8 , 161u8 , 0u8 , 229u8 , 119u8 , 183u8 , 220u8 , 186u8 , 80u8 , 60u8 , 7u8 , 88u8 , 30u8 , 26u8 , 132u8 , 198u8 , 66u8 ,]) } # [doc = "Counter for the related counted storage map"] pub fn counter_for_segment_commitment (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: counter_for_segment_commitment :: CounterForSegmentCommitment , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "CounterForSegmentCommitment" , () , [136u8 , 19u8 , 14u8 , 240u8 , 107u8 , 156u8 , 75u8 , 51u8 , 149u8 , 29u8 , 105u8 , 133u8 , 178u8 , 225u8 , 130u8 , 87u8 , 150u8 , 169u8 , 226u8 , 100u8 , 29u8 , 129u8 , 207u8 , 138u8 , 251u8 , 246u8 , 162u8 , 11u8 , 246u8 , 123u8 , 130u8 , 8u8 ,]) } # [doc = " Whether the segment headers inherent has been processed in this block (temporary value)."] # [doc = ""] # [doc = " This value is updated to `true` when processing `store_segment_headers` by a node."] # [doc = " It is then cleared at the end of each block execution in the `on_finalize` hook."] pub fn did_process_segment_headers (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: did_process_segment_headers :: DidProcessSegmentHeaders , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "DidProcessSegmentHeaders" , () , [43u8 , 191u8 , 7u8 , 39u8 , 97u8 , 193u8 , 91u8 , 222u8 , 200u8 , 169u8 , 54u8 , 4u8 , 5u8 , 128u8 , 67u8 , 233u8 , 0u8 , 75u8 , 42u8 , 240u8 , 26u8 , 138u8 , 97u8 , 164u8 , 230u8 , 139u8 , 250u8 , 27u8 , 165u8 , 220u8 , 3u8 , 49u8 ,]) } # [doc = " Storage of previous vote verification data, updated on each block during finalization."] pub fn parent_vote_verification_data (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: parent_vote_verification_data :: ParentVoteVerificationData , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "ParentVoteVerificationData" , () , [51u8 , 165u8 , 182u8 , 76u8 , 215u8 , 141u8 , 143u8 , 185u8 , 132u8 , 34u8 , 201u8 , 0u8 , 201u8 , 107u8 , 83u8 , 19u8 , 136u8 , 177u8 , 99u8 , 151u8 , 71u8 , 84u8 , 219u8 , 227u8 , 79u8 , 247u8 , 80u8 , 43u8 , 229u8 , 155u8 , 157u8 , 143u8 ,]) } # [doc = " Parent block author information."] pub fn parent_block_author_info (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: parent_block_author_info :: ParentBlockAuthorInfo , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "ParentBlockAuthorInfo" , () , [86u8 , 240u8 , 165u8 , 104u8 , 166u8 , 169u8 , 98u8 , 1u8 , 82u8 , 222u8 , 26u8 , 210u8 , 230u8 , 106u8 , 130u8 , 213u8 , 160u8 , 197u8 , 204u8 , 107u8 , 123u8 , 91u8 , 229u8 , 224u8 , 84u8 , 70u8 , 47u8 , 197u8 , 111u8 , 13u8 , 3u8 , 225u8 ,]) } # [doc = " Enable rewards since specified block number."] pub fn enable_rewards (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: enable_rewards :: EnableRewards , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "EnableRewards" , () , [203u8 , 246u8 , 207u8 , 222u8 , 202u8 , 131u8 , 50u8 , 15u8 , 53u8 , 57u8 , 66u8 , 227u8 , 223u8 , 251u8 , 248u8 , 29u8 , 116u8 , 215u8 , 153u8 , 230u8 , 250u8 , 209u8 , 147u8 , 95u8 , 226u8 , 24u8 , 252u8 , 28u8 , 215u8 , 32u8 , 46u8 , 141u8 ,]) } # [doc = " Enable rewards when solution range is below this threshold."] pub fn enable_rewards_below_solution_range (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: enable_rewards_below_solution_range :: EnableRewardsBelowSolutionRange , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "EnableRewardsBelowSolutionRange" , () , [241u8 , 185u8 , 97u8 , 144u8 , 165u8 , 58u8 , 77u8 , 225u8 , 45u8 , 120u8 , 160u8 , 122u8 , 208u8 , 163u8 , 218u8 , 98u8 , 76u8 , 26u8 , 151u8 , 177u8 , 63u8 , 137u8 , 211u8 , 115u8 , 68u8 , 135u8 , 125u8 , 1u8 , 242u8 , 171u8 , 131u8 , 141u8 ,]) } # [doc = " Block author information"] pub fn current_block_author_info (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: current_block_author_info :: CurrentBlockAuthorInfo , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "CurrentBlockAuthorInfo" , () , [61u8 , 21u8 , 114u8 , 85u8 , 155u8 , 27u8 , 146u8 , 26u8 , 134u8 , 188u8 , 226u8 , 123u8 , 57u8 , 118u8 , 221u8 , 20u8 , 88u8 , 66u8 , 55u8 , 173u8 , 127u8 , 232u8 , 170u8 , 7u8 , 200u8 , 150u8 , 85u8 , 95u8 , 222u8 , 51u8 , 39u8 , 9u8 ,]) } # [doc = " Voters in the parent block (set at the end of the block with current values)."] pub fn parent_block_voters (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: parent_block_voters :: ParentBlockVoters , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "ParentBlockVoters" , () , [59u8 , 38u8 , 234u8 , 57u8 , 207u8 , 150u8 , 9u8 , 76u8 , 175u8 , 221u8 , 21u8 , 194u8 , 83u8 , 161u8 , 163u8 , 103u8 , 21u8 , 111u8 , 193u8 , 17u8 , 138u8 , 206u8 , 48u8 , 44u8 , 71u8 , 83u8 , 42u8 , 85u8 , 175u8 , 58u8 , 2u8 , 97u8 ,]) } # [doc = " Voters in the current block thus far"] pub fn current_block_voters (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: current_block_voters :: CurrentBlockVoters , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "CurrentBlockVoters" , () , [101u8 , 43u8 , 157u8 , 58u8 , 148u8 , 182u8 , 219u8 , 120u8 , 50u8 , 96u8 , 43u8 , 172u8 , 176u8 , 230u8 , 206u8 , 208u8 , 114u8 , 80u8 , 24u8 , 11u8 , 70u8 , 56u8 , 72u8 , 132u8 , 42u8 , 45u8 , 100u8 , 236u8 , 104u8 , 214u8 , 89u8 , 111u8 ,]) } # [doc = " Number of iterations for proof of time per slot with optional scheduled update"] pub fn pot_slot_iterations (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pot_slot_iterations :: PotSlotIterations , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "PotSlotIterations" , () , [133u8 , 167u8 , 50u8 , 13u8 , 188u8 , 28u8 , 125u8 , 182u8 , 118u8 , 160u8 , 80u8 , 99u8 , 153u8 , 209u8 , 182u8 , 82u8 , 20u8 , 174u8 , 252u8 , 226u8 , 207u8 , 229u8 , 141u8 , 118u8 , 221u8 , 14u8 , 94u8 , 72u8 , 157u8 , 49u8 , 110u8 , 233u8 ,]) } # [doc = " Entropy that needs to be injected into proof of time chain at specific slot associated with"] # [doc = " block number it came from."] pub fn pot_entropy (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pot_entropy :: PotEntropy , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "PotEntropy" , () , [13u8 , 226u8 , 142u8 , 254u8 , 228u8 , 164u8 , 42u8 , 58u8 , 168u8 , 154u8 , 74u8 , 105u8 , 155u8 , 46u8 , 232u8 , 130u8 , 97u8 , 14u8 , 75u8 , 227u8 , 0u8 , 42u8 , 13u8 , 137u8 , 209u8 , 154u8 , 80u8 , 5u8 , 38u8 , 98u8 , 207u8 , 34u8 ,]) } # [doc = " The current block randomness, updated at block initialization. When the proof of time feature"] # [doc = " is enabled it derived from PoT otherwise PoR."] pub fn block_randomness (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_randomness :: BlockRandomness , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "BlockRandomness" , () , [226u8 , 134u8 , 13u8 , 134u8 , 221u8 , 85u8 , 34u8 , 205u8 , 217u8 , 196u8 , 178u8 , 207u8 , 143u8 , 172u8 , 235u8 , 17u8 , 198u8 , 195u8 , 92u8 , 252u8 , 226u8 , 44u8 , 58u8 , 225u8 , 27u8 , 157u8 , 35u8 , 230u8 , 227u8 , 10u8 , 223u8 , 70u8 ,]) } # [doc = " Allow block authoring by anyone or just root."] pub fn allow_authoring_by_anyone (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: allow_authoring_by_anyone :: AllowAuthoringByAnyone , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "AllowAuthoringByAnyone" , () , [153u8 , 87u8 , 177u8 , 90u8 , 182u8 , 110u8 , 29u8 , 167u8 , 9u8 , 42u8 , 206u8 , 213u8 , 174u8 , 72u8 , 172u8 , 41u8 , 81u8 , 183u8 , 221u8 , 118u8 , 176u8 , 50u8 , 224u8 , 125u8 , 77u8 , 107u8 , 215u8 , 124u8 , 42u8 , 180u8 , 197u8 , 165u8 ,]) } # [doc = " Root plot public key."] # [doc = ""] # [doc = " Set just once to make sure no one else can author blocks until allowed for anyone."] pub fn root_plot_public_key (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: root_plot_public_key :: RootPlotPublicKey , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Subspace" , "RootPlotPublicKey" , () , [26u8 , 65u8 , 226u8 , 63u8 , 0u8 , 29u8 , 214u8 , 138u8 , 40u8 , 96u8 , 82u8 , 37u8 , 131u8 , 201u8 , 0u8 , 137u8 , 15u8 , 132u8 , 26u8 , 244u8 , 121u8 , 148u8 , 7u8 , 119u8 , 237u8 , 130u8 , 173u8 , 46u8 , 58u8 , 30u8 , 185u8 , 42u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Number of slots between slot arrival and when corresponding block can be produced."] # [doc = ""] # [doc = " Practically this means future proof of time proof needs to be revealed this many slots"] # [doc = " ahead before block can be authored even though solution is available before that."] pub fn block_authoring_delay (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_consensus_slots :: Slot > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "BlockAuthoringDelay" , [184u8 , 78u8 , 161u8 , 6u8 , 214u8 , 205u8 , 82u8 , 205u8 , 126u8 , 46u8 , 7u8 , 198u8 , 186u8 , 10u8 , 66u8 , 116u8 , 191u8 , 223u8 , 17u8 , 246u8 , 196u8 , 190u8 , 222u8 , 226u8 , 62u8 , 35u8 , 191u8 , 127u8 , 60u8 , 171u8 , 85u8 , 201u8 ,]) } # [doc = " Interval, in blocks, between blockchain entropy injection into proof of time chain."] pub fn pot_entropy_injection_interval (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "PotEntropyInjectionInterval" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Interval, in entropy injection intervals, where to take entropy for injection from."] pub fn pot_entropy_injection_lookback_depth (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u8 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "PotEntropyInjectionLookbackDepth" , [141u8 , 130u8 , 11u8 , 35u8 , 226u8 , 114u8 , 92u8 , 179u8 , 168u8 , 110u8 , 28u8 , 91u8 , 221u8 , 64u8 , 4u8 , 148u8 , 201u8 , 193u8 , 185u8 , 66u8 , 226u8 , 114u8 , 97u8 , 79u8 , 62u8 , 212u8 , 202u8 , 114u8 , 237u8 , 228u8 , 183u8 , 165u8 ,]) } # [doc = " Delay after block, in slots, when entropy injection takes effect."] pub fn pot_entropy_injection_delay (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_consensus_slots :: Slot > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "PotEntropyInjectionDelay" , [184u8 , 78u8 , 161u8 , 6u8 , 214u8 , 205u8 , 82u8 , 205u8 , 126u8 , 46u8 , 7u8 , 198u8 , 186u8 , 10u8 , 66u8 , 116u8 , 191u8 , 223u8 , 17u8 , 246u8 , 196u8 , 190u8 , 222u8 , 226u8 , 62u8 , 35u8 , 191u8 , 127u8 , 60u8 , 171u8 , 85u8 , 201u8 ,]) } # [doc = " The amount of time, in blocks, that each era should last."] # [doc = " NOTE: Currently it is not possible to change the era duration after"] # [doc = " the chain has started. Attempting to do so will brick block production."] pub fn era_duration (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "EraDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Initial solution range used for challenges during the very first era."] pub fn initial_solution_range (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "InitialSolutionRange" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " How often in slots slots (on average, not counting collisions) will have a block."] # [doc = ""] # [doc = " Expressed as a rational where the first member of the tuple is the"] # [doc = " numerator and the second is the denominator. The rational should"] # [doc = " represent a value between 0 and 1."] pub fn slot_probability (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "SlotProbability" , [152u8 , 117u8 , 175u8 , 148u8 , 25u8 , 87u8 , 115u8 , 153u8 , 72u8 , 53u8 , 134u8 , 19u8 , 201u8 , 134u8 , 181u8 , 104u8 , 87u8 , 173u8 , 243u8 , 49u8 , 245u8 , 144u8 , 230u8 , 40u8 , 29u8 , 192u8 , 234u8 , 1u8 , 180u8 , 183u8 , 251u8 , 20u8 ,]) } # [doc = " Depth `K` after which a block enters the recorded history (a global constant, as opposed"] # [doc = " to the client-dependent transaction confirmation depth `k`)."] pub fn confirmation_depth_k (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "ConfirmationDepthK" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Number of latest archived segments that are considered \"recent history\"."] pub fn recent_segments (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: subspace_core_primitives :: segments :: HistorySize > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "RecentSegments" , [83u8 , 77u8 , 147u8 , 104u8 , 163u8 , 10u8 , 49u8 , 218u8 , 106u8 , 203u8 , 254u8 , 98u8 , 91u8 , 226u8 , 230u8 , 22u8 , 42u8 , 34u8 , 49u8 , 175u8 , 254u8 , 149u8 , 199u8 , 48u8 , 20u8 , 24u8 , 81u8 , 173u8 , 50u8 , 179u8 , 78u8 , 6u8 ,]) } # [doc = " Fraction of pieces from the \"recent history\" (`recent_segments`) in each sector."] pub fn recent_history_fraction (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < (runtime_types :: subspace_core_primitives :: segments :: HistorySize , runtime_types :: subspace_core_primitives :: segments :: HistorySize ,) > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "RecentHistoryFraction" , [2u8 , 121u8 , 247u8 , 222u8 , 246u8 , 31u8 , 190u8 , 75u8 , 177u8 , 89u8 , 205u8 , 184u8 , 87u8 , 153u8 , 152u8 , 89u8 , 1u8 , 89u8 , 238u8 , 66u8 , 145u8 , 43u8 , 12u8 , 67u8 , 173u8 , 217u8 , 96u8 , 7u8 , 32u8 , 131u8 , 102u8 , 131u8 ,]) } # [doc = " Minimum lifetime of a plotted sector, measured in archived segment."] pub fn min_sector_lifetime (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: subspace_core_primitives :: segments :: HistorySize > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "MinSectorLifetime" , [83u8 , 77u8 , 147u8 , 104u8 , 163u8 , 10u8 , 49u8 , 218u8 , 106u8 , 203u8 , 254u8 , 98u8 , 91u8 , 226u8 , 230u8 , 22u8 , 42u8 , 34u8 , 49u8 , 175u8 , 254u8 , 149u8 , 199u8 , 48u8 , 20u8 , 24u8 , 81u8 , 173u8 , 50u8 , 179u8 , 78u8 , 6u8 ,]) } # [doc = " Number of votes expected per block."] # [doc = ""] # [doc = " This impacts solution range for votes in consensus."] pub fn expected_votes_per_block (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "ExpectedVotesPerBlock" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " How many pieces one sector is supposed to contain (max)"] pub fn max_pieces_in_sector (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "MaxPiecesInSector" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " Maximum number of block number to block slot mappings to keep (oldest pruned first)."] pub fn block_slot_count (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Subspace" , "BlockSlotCount" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod rewards { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_rewards :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Update dynamic issuance parameters"] pub struct UpdateIssuanceParams { pub proposer_subsidy_points : update_issuance_params :: ProposerSubsidyPoints , pub voter_subsidy_points : update_issuance_params :: VoterSubsidyPoints , } pub mod update_issuance_params { use super :: runtime_types ; pub type ProposerSubsidyPoints = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_rewards :: RewardPoint < :: core :: primitive :: u32 , :: core :: primitive :: u128 > > ; pub type VoterSubsidyPoints = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_rewards :: RewardPoint < :: core :: primitive :: u32 , :: core :: primitive :: u128 > > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UpdateIssuanceParams { const PALLET : & 'static str = "Rewards" ; const CALL : & 'static str = "update_issuance_params" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Update dynamic issuance parameters"] pub fn update_issuance_params (& self , proposer_subsidy_points : types :: update_issuance_params :: ProposerSubsidyPoints , voter_subsidy_points : types :: update_issuance_params :: VoterSubsidyPoints ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UpdateIssuanceParams > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Rewards" , "update_issuance_params" , types :: UpdateIssuanceParams { proposer_subsidy_points , voter_subsidy_points , } , [16u8 , 2u8 , 244u8 , 144u8 , 245u8 , 234u8 , 148u8 , 36u8 , 156u8 , 157u8 , 200u8 , 121u8 , 154u8 , 199u8 , 113u8 , 213u8 , 223u8 , 81u8 , 190u8 , 124u8 , 240u8 , 114u8 , 217u8 , 19u8 , 103u8 , 29u8 , 184u8 , 211u8 , 98u8 , 241u8 , 109u8 , 158u8 ,]) } } } # [doc = "`pallet-rewards` events"] pub type Event = runtime_types :: pallet_rewards :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Issued reward for the block author"] pub struct BlockReward { pub block_author : block_reward :: BlockAuthor , pub reward : block_reward :: Reward , } pub mod block_reward { use super :: runtime_types ; pub type BlockAuthor = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Reward = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BlockReward { const PALLET : & 'static str = "Rewards" ; const EVENT : & 'static str = "BlockReward" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Issued reward for the voter"] pub struct VoteReward { pub voter : vote_reward :: Voter , pub reward : vote_reward :: Reward , } pub mod vote_reward { use super :: runtime_types ; pub type Voter = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Reward = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for VoteReward { const PALLET : & 'static str = "Rewards" ; const EVENT : & 'static str = "VoteReward" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod avg_blockspace_usage { use super :: runtime_types ; pub type AvgBlockspaceUsage = :: core :: primitive :: u32 ; } pub mod rewards_enabled { use super :: runtime_types ; pub type RewardsEnabled = :: core :: primitive :: bool ; } pub mod remaining_issuance { use super :: runtime_types ; pub type RemainingIssuance = :: core :: primitive :: u128 ; } pub mod proposer_subsidy_points { use super :: runtime_types ; pub type ProposerSubsidyPoints = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_rewards :: RewardPoint < :: core :: primitive :: u32 , :: core :: primitive :: u128 > > ; } pub mod voter_subsidy_points { use super :: runtime_types ; pub type VoterSubsidyPoints = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_rewards :: RewardPoint < :: core :: primitive :: u32 , :: core :: primitive :: u128 > > ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Utilization of blockspace (in bytes) by the normal extrinsics used to adjust issuance"] pub fn avg_blockspace_usage (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: avg_blockspace_usage :: AvgBlockspaceUsage , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Rewards" , "AvgBlockspaceUsage" , () , [88u8 , 172u8 , 170u8 , 52u8 , 209u8 , 41u8 , 68u8 , 43u8 , 197u8 , 9u8 , 63u8 , 224u8 , 26u8 , 184u8 , 187u8 , 62u8 , 238u8 , 152u8 , 147u8 , 116u8 , 25u8 , 100u8 , 182u8 , 182u8 , 192u8 , 213u8 , 198u8 , 163u8 , 84u8 , 192u8 , 103u8 , 114u8 ,]) } # [doc = " Whether rewards are enabled"] pub fn rewards_enabled (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: rewards_enabled :: RewardsEnabled , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Rewards" , "RewardsEnabled" , () , [126u8 , 34u8 , 65u8 , 149u8 , 214u8 , 119u8 , 96u8 , 85u8 , 229u8 , 225u8 , 221u8 , 59u8 , 32u8 , 242u8 , 144u8 , 211u8 , 33u8 , 58u8 , 170u8 , 240u8 , 124u8 , 174u8 , 89u8 , 96u8 , 90u8 , 82u8 , 232u8 , 176u8 , 67u8 , 93u8 , 88u8 , 128u8 ,]) } # [doc = " Tokens left to issue to farmers at any given time"] pub fn remaining_issuance (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: remaining_issuance :: RemainingIssuance , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Rewards" , "RemainingIssuance" , () , [49u8 , 228u8 , 222u8 , 198u8 , 78u8 , 161u8 , 241u8 , 4u8 , 67u8 , 66u8 , 8u8 , 203u8 , 176u8 , 244u8 , 20u8 , 182u8 , 117u8 , 223u8 , 227u8 , 53u8 , 177u8 , 200u8 , 50u8 , 41u8 , 24u8 , 124u8 , 25u8 , 207u8 , 146u8 , 225u8 , 155u8 , 183u8 ,]) } # [doc = " Block proposer subsidy parameters"] pub fn proposer_subsidy_points (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: proposer_subsidy_points :: ProposerSubsidyPoints , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Rewards" , "ProposerSubsidyPoints" , () , [141u8 , 47u8 , 115u8 , 175u8 , 189u8 , 182u8 , 121u8 , 207u8 , 114u8 , 202u8 , 200u8 , 1u8 , 5u8 , 213u8 , 160u8 , 250u8 , 28u8 , 73u8 , 172u8 , 171u8 , 4u8 , 190u8 , 36u8 , 183u8 , 135u8 , 142u8 , 236u8 , 2u8 , 180u8 , 136u8 , 198u8 , 136u8 ,]) } # [doc = " Voter subsidy parameters"] pub fn voter_subsidy_points (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: voter_subsidy_points :: VoterSubsidyPoints , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Rewards" , "VoterSubsidyPoints" , () , [209u8 , 43u8 , 105u8 , 98u8 , 132u8 , 103u8 , 128u8 , 1u8 , 235u8 , 244u8 , 219u8 , 176u8 , 220u8 , 163u8 , 9u8 , 9u8 , 235u8 , 176u8 , 48u8 , 63u8 , 228u8 , 3u8 , 120u8 , 177u8 , 139u8 , 196u8 , 245u8 , 191u8 , 118u8 , 250u8 , 183u8 , 164u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Number of blocks over which to compute average blockspace usage"] pub fn avg_blockspace_usage_num_blocks (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Rewards" , "AvgBlockspaceUsageNumBlocks" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Cost of one byte of blockspace"] pub fn transaction_byte_fee (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Rewards" , "TransactionByteFee" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Max number of reward points"] pub fn max_reward_points (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Rewards" , "MaxRewardPoints" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Tax of the proposer on vote rewards"] pub fn proposer_tax_on_votes (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Rewards" , "ProposerTaxOnVotes" , [164u8 , 110u8 , 117u8 , 122u8 , 72u8 , 90u8 , 119u8 , 208u8 , 1u8 , 32u8 , 41u8 , 194u8 , 15u8 , 8u8 , 186u8 , 163u8 , 188u8 , 228u8 , 141u8 , 195u8 , 18u8 , 61u8 , 131u8 , 127u8 , 204u8 , 184u8 , 78u8 , 66u8 , 209u8 , 119u8 , 67u8 , 74u8 ,]) } } } } pub mod balances { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_balances :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_balances :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] pub struct TransferAllowDeath { pub dest : transfer_allow_death :: Dest , # [codec (compact)] pub value : transfer_allow_death :: Value , } pub mod transfer_allow_death { use super :: runtime_types ; pub type Dest = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Value = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for TransferAllowDeath { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "transfer_allow_death" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"] # [doc = "may be specified."] pub struct ForceTransfer { pub source : force_transfer :: Source , pub dest : force_transfer :: Dest , # [codec (compact)] pub value : force_transfer :: Value , } pub mod force_transfer { use super :: runtime_types ; pub type Source = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Dest = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Value = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceTransfer { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "force_transfer" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"] # [doc = "kill the origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer_allow_death`] instead."] # [doc = ""] # [doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"] pub struct TransferKeepAlive { pub dest : transfer_keep_alive :: Dest , # [codec (compact)] pub value : transfer_keep_alive :: Value , } pub mod transfer_keep_alive { use super :: runtime_types ; pub type Dest = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Value = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for TransferKeepAlive { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "transfer_keep_alive" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true)."] pub struct TransferAll { pub dest : transfer_all :: Dest , pub keep_alive : transfer_all :: KeepAlive , } pub mod transfer_all { use super :: runtime_types ; pub type Dest = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type KeepAlive = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for TransferAll { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "transfer_all" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] pub struct ForceUnreserve { pub who : force_unreserve :: Who , pub amount : force_unreserve :: Amount , } pub mod force_unreserve { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceUnreserve { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "force_unreserve" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Upgrade a specified account."] # [doc = ""] # [doc = "- `origin`: Must be `Signed`."] # [doc = "- `who`: The account to be upgraded."] # [doc = ""] # [doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"] # [doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"] # [doc = "possibility of churn)."] pub struct UpgradeAccounts { pub who : upgrade_accounts :: Who , } pub mod upgrade_accounts { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UpgradeAccounts { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "upgrade_accounts" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the regular balance of a given account."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] pub struct ForceSetBalance { pub who : force_set_balance :: Who , # [codec (compact)] pub new_free : force_set_balance :: NewFree , } pub mod force_set_balance { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type NewFree = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceSetBalance { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "force_set_balance" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Adjust the total issuance in a saturating way."] # [doc = ""] # [doc = "Can only be called by root and always needs a positive `delta`."] # [doc = ""] # [doc = "# Example"] pub struct ForceAdjustTotalIssuance { pub direction : force_adjust_total_issuance :: Direction , # [codec (compact)] pub delta : force_adjust_total_issuance :: Delta , } pub mod force_adjust_total_issuance { use super :: runtime_types ; pub type Direction = runtime_types :: pallet_balances :: types :: AdjustmentDirection ; pub type Delta = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceAdjustTotalIssuance { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "force_adjust_total_issuance" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Burn the specified liquid free balance from the origin account."] # [doc = ""] # [doc = "If the origin's account ends up below the existential deposit as a result"] # [doc = "of the burn and `keep_alive` is false, the account will be reaped."] # [doc = ""] # [doc = "Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,"] # [doc = "this `burn` operation will reduce total issuance by the amount _burned_."] pub struct Burn { # [codec (compact)] pub value : burn :: Value , pub keep_alive : burn :: KeepAlive , } pub mod burn { use super :: runtime_types ; pub type Value = :: core :: primitive :: u128 ; pub type KeepAlive = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Burn { const PALLET : & 'static str = "Balances" ; const CALL : & 'static str = "burn" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] pub fn transfer_allow_death (& self , dest : types :: transfer_allow_death :: Dest , value : types :: transfer_allow_death :: Value ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: TransferAllowDeath > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "transfer_allow_death" , types :: TransferAllowDeath { dest , value , } , [51u8 , 166u8 , 195u8 , 10u8 , 139u8 , 218u8 , 55u8 , 130u8 , 6u8 , 194u8 , 35u8 , 140u8 , 27u8 , 205u8 , 214u8 , 222u8 , 102u8 , 43u8 , 143u8 , 145u8 , 86u8 , 219u8 , 210u8 , 147u8 , 13u8 , 39u8 , 51u8 , 21u8 , 237u8 , 179u8 , 132u8 , 130u8 ,]) } # [doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"] # [doc = "may be specified."] pub fn force_transfer (& self , source : types :: force_transfer :: Source , dest : types :: force_transfer :: Dest , value : types :: force_transfer :: Value ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceTransfer > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "force_transfer" , types :: ForceTransfer { source , dest , value , } , [154u8 , 93u8 , 222u8 , 27u8 , 12u8 , 248u8 , 63u8 , 213u8 , 224u8 , 86u8 , 250u8 , 153u8 , 249u8 , 102u8 , 83u8 , 160u8 , 79u8 , 125u8 , 105u8 , 222u8 , 77u8 , 180u8 , 90u8 , 105u8 , 81u8 , 217u8 , 60u8 , 25u8 , 213u8 , 51u8 , 185u8 , 96u8 ,]) } # [doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"] # [doc = "kill the origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer_allow_death`] instead."] # [doc = ""] # [doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"] pub fn transfer_keep_alive (& self , dest : types :: transfer_keep_alive :: Dest , value : types :: transfer_keep_alive :: Value ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: TransferKeepAlive > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "transfer_keep_alive" , types :: TransferKeepAlive { dest , value , } , [245u8 , 14u8 , 190u8 , 193u8 , 32u8 , 210u8 , 74u8 , 92u8 , 25u8 , 182u8 , 76u8 , 55u8 , 247u8 , 83u8 , 114u8 , 75u8 , 143u8 , 236u8 , 117u8 , 25u8 , 54u8 , 157u8 , 208u8 , 207u8 , 233u8 , 89u8 , 70u8 , 161u8 , 235u8 , 242u8 , 222u8 , 59u8 ,]) } # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true)."] pub fn transfer_all (& self , dest : types :: transfer_all :: Dest , keep_alive : types :: transfer_all :: KeepAlive ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: TransferAll > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "transfer_all" , types :: TransferAll { dest , keep_alive , } , [105u8 , 132u8 , 49u8 , 144u8 , 195u8 , 250u8 , 34u8 , 46u8 , 213u8 , 248u8 , 112u8 , 188u8 , 81u8 , 228u8 , 136u8 , 18u8 , 67u8 , 172u8 , 37u8 , 38u8 , 238u8 , 9u8 , 34u8 , 15u8 , 67u8 , 34u8 , 148u8 , 195u8 , 223u8 , 29u8 , 154u8 , 6u8 ,]) } # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] pub fn force_unreserve (& self , who : types :: force_unreserve :: Who , amount : types :: force_unreserve :: Amount ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceUnreserve > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "force_unreserve" , types :: ForceUnreserve { who , amount , } , [142u8 , 151u8 , 64u8 , 205u8 , 46u8 , 64u8 , 62u8 , 122u8 , 108u8 , 49u8 , 223u8 , 140u8 , 120u8 , 153u8 , 35u8 , 165u8 , 187u8 , 38u8 , 157u8 , 200u8 , 123u8 , 199u8 , 198u8 , 168u8 , 208u8 , 159u8 , 39u8 , 134u8 , 92u8 , 103u8 , 84u8 , 171u8 ,]) } # [doc = "Upgrade a specified account."] # [doc = ""] # [doc = "- `origin`: Must be `Signed`."] # [doc = "- `who`: The account to be upgraded."] # [doc = ""] # [doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"] # [doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"] # [doc = "possibility of churn)."] pub fn upgrade_accounts (& self , who : types :: upgrade_accounts :: Who ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UpgradeAccounts > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "upgrade_accounts" , types :: UpgradeAccounts { who , } , [66u8 , 200u8 , 179u8 , 104u8 , 65u8 , 2u8 , 101u8 , 56u8 , 130u8 , 161u8 , 224u8 , 233u8 , 255u8 , 124u8 , 70u8 , 122u8 , 8u8 , 49u8 , 103u8 , 178u8 , 68u8 , 47u8 , 214u8 , 166u8 , 217u8 , 116u8 , 178u8 , 50u8 , 212u8 , 164u8 , 98u8 , 226u8 ,]) } # [doc = "Set the regular balance of a given account."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] pub fn force_set_balance (& self , who : types :: force_set_balance :: Who , new_free : types :: force_set_balance :: NewFree ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceSetBalance > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "force_set_balance" , types :: ForceSetBalance { who , new_free , } , [114u8 , 229u8 , 59u8 , 204u8 , 180u8 , 83u8 , 17u8 , 4u8 , 59u8 , 4u8 , 55u8 , 39u8 , 151u8 , 196u8 , 124u8 , 60u8 , 209u8 , 65u8 , 193u8 , 11u8 , 44u8 , 164u8 , 116u8 , 93u8 , 169u8 , 30u8 , 199u8 , 165u8 , 55u8 , 231u8 , 223u8 , 43u8 ,]) } # [doc = "Adjust the total issuance in a saturating way."] # [doc = ""] # [doc = "Can only be called by root and always needs a positive `delta`."] # [doc = ""] # [doc = "# Example"] pub fn force_adjust_total_issuance (& self , direction : types :: force_adjust_total_issuance :: Direction , delta : types :: force_adjust_total_issuance :: Delta ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceAdjustTotalIssuance > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "force_adjust_total_issuance" , types :: ForceAdjustTotalIssuance { direction , delta , } , [208u8 , 134u8 , 56u8 , 133u8 , 232u8 , 164u8 , 10u8 , 213u8 , 53u8 , 193u8 , 190u8 , 63u8 , 236u8 , 186u8 , 96u8 , 122u8 , 104u8 , 87u8 , 173u8 , 38u8 , 58u8 , 176u8 , 21u8 , 78u8 , 42u8 , 106u8 , 46u8 , 248u8 , 251u8 , 190u8 , 150u8 , 202u8 ,]) } # [doc = "Burn the specified liquid free balance from the origin account."] # [doc = ""] # [doc = "If the origin's account ends up below the existential deposit as a result"] # [doc = "of the burn and `keep_alive` is false, the account will be reaped."] # [doc = ""] # [doc = "Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,"] # [doc = "this `burn` operation will reduce total issuance by the amount _burned_."] pub fn burn (& self , value : types :: burn :: Value , keep_alive : types :: burn :: KeepAlive ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Burn > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Balances" , "burn" , types :: Burn { value , keep_alive , } , [176u8 , 64u8 , 7u8 , 109u8 , 16u8 , 44u8 , 145u8 , 125u8 , 147u8 , 152u8 , 130u8 , 114u8 , 221u8 , 201u8 , 150u8 , 162u8 , 118u8 , 71u8 , 52u8 , 92u8 , 240u8 , 116u8 , 203u8 , 98u8 , 5u8 , 22u8 , 43u8 , 102u8 , 94u8 , 208u8 , 101u8 , 57u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_balances :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account was created with some free balance."] pub struct Endowed { pub account : endowed :: Account , pub free_balance : endowed :: FreeBalance , } pub mod endowed { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type FreeBalance = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Endowed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Endowed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] pub struct DustLost { pub account : dust_lost :: Account , pub amount : dust_lost :: Amount , } pub mod dust_lost { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DustLost { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "DustLost" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Transfer succeeded."] pub struct Transfer { pub from : transfer :: From , pub to : transfer :: To , pub amount : transfer :: Amount , } pub mod transfer { use super :: runtime_types ; pub type From = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type To = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Transfer { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Transfer" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A balance was set by root."] pub struct BalanceSet { pub who : balance_set :: Who , pub free : balance_set :: Free , } pub mod balance_set { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Free = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BalanceSet { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "BalanceSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was reserved (moved from free to reserved)."] pub struct Reserved { pub who : reserved :: Who , pub amount : reserved :: Amount , } pub mod reserved { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Reserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Reserved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was unreserved (moved from reserved to free)."] pub struct Unreserved { pub who : unreserved :: Who , pub amount : unreserved :: Amount , } pub mod unreserved { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Unreserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Unreserved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] pub struct ReserveRepatriated { pub from : reserve_repatriated :: From , pub to : reserve_repatriated :: To , pub amount : reserve_repatriated :: Amount , pub destination_status : reserve_repatriated :: DestinationStatus , } pub mod reserve_repatriated { use super :: runtime_types ; pub type From = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type To = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; pub type DestinationStatus = runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ReserveRepatriated { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "ReserveRepatriated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was deposited (e.g. for transaction fees)."] pub struct Deposit { pub who : deposit :: Who , pub amount : deposit :: Amount , } pub mod deposit { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Deposit { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] pub struct Withdraw { pub who : withdraw :: Who , pub amount : withdraw :: Amount , } pub mod withdraw { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Withdraw { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Withdraw" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] pub struct Slashed { pub who : slashed :: Who , pub amount : slashed :: Amount , } pub mod slashed { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Slashed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Slashed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was minted into an account."] pub struct Minted { pub who : minted :: Who , pub amount : minted :: Amount , } pub mod minted { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Minted { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Minted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was burned from an account."] pub struct Burned { pub who : burned :: Who , pub amount : burned :: Amount , } pub mod burned { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Burned { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Burned" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was suspended from an account (it can be restored later)."] pub struct Suspended { pub who : suspended :: Who , pub amount : suspended :: Amount , } pub mod suspended { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Suspended { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Suspended" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some amount was restored into an account."] pub struct Restored { pub who : restored :: Who , pub amount : restored :: Amount , } pub mod restored { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Restored { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Restored" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account was upgraded."] pub struct Upgraded { pub who : upgraded :: Who , } pub mod upgraded { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Upgraded { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Upgraded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Total issuance was increased by `amount`, creating a credit to be balanced."] pub struct Issued { pub amount : issued :: Amount , } pub mod issued { use super :: runtime_types ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Issued { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Issued" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Total issuance was decreased by `amount`, creating a debt to be balanced."] pub struct Rescinded { pub amount : rescinded :: Amount , } pub mod rescinded { use super :: runtime_types ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Rescinded { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Rescinded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was locked."] pub struct Locked { pub who : locked :: Who , pub amount : locked :: Amount , } pub mod locked { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Locked { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Locked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was unlocked."] pub struct Unlocked { pub who : unlocked :: Who , pub amount : unlocked :: Amount , } pub mod unlocked { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Unlocked { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Unlocked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was frozen."] pub struct Frozen { pub who : frozen :: Who , pub amount : frozen :: Amount , } pub mod frozen { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Frozen { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Frozen" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some balance was thawed."] pub struct Thawed { pub who : thawed :: Who , pub amount : thawed :: Amount , } pub mod thawed { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Thawed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Thawed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `TotalIssuance` was forcefully changed."] pub struct TotalIssuanceForced { pub old : total_issuance_forced :: Old , pub new : total_issuance_forced :: New , } pub mod total_issuance_forced { use super :: runtime_types ; pub type Old = :: core :: primitive :: u128 ; pub type New = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TotalIssuanceForced { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "TotalIssuanceForced" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod total_issuance { use super :: runtime_types ; pub type TotalIssuance = :: core :: primitive :: u128 ; } pub mod inactive_issuance { use super :: runtime_types ; pub type InactiveIssuance = :: core :: primitive :: u128 ; } pub mod account { use super :: runtime_types ; pub type Account = runtime_types :: pallet_balances :: types :: AccountData < :: core :: primitive :: u128 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod locks { use super :: runtime_types ; pub type Locks = runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: types :: BalanceLock < :: core :: primitive :: u128 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod reserves { use super :: runtime_types ; pub type Reserves = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: types :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod holds { use super :: runtime_types ; pub type Holds = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: frame_support :: traits :: tokens :: misc :: IdAmount < runtime_types :: subspace_runtime :: HoldIdentifierWrapper , :: core :: primitive :: u128 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod freezes { use super :: runtime_types ; pub type Freezes = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: frame_support :: traits :: tokens :: misc :: IdAmount < () , :: core :: primitive :: u128 > > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The total units issued in the system."] pub fn total_issuance (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: total_issuance :: TotalIssuance , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "TotalIssuance" , () , [116u8 , 70u8 , 119u8 , 194u8 , 69u8 , 37u8 , 116u8 , 206u8 , 171u8 , 70u8 , 171u8 , 210u8 , 226u8 , 111u8 , 184u8 , 204u8 , 206u8 , 11u8 , 68u8 , 72u8 , 255u8 , 19u8 , 194u8 , 11u8 , 27u8 , 194u8 , 81u8 , 204u8 , 59u8 , 224u8 , 202u8 , 185u8 ,]) } # [doc = " The total units of outstanding deactivated balance in the system."] pub fn inactive_issuance (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inactive_issuance :: InactiveIssuance , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "InactiveIssuance" , () , [212u8 , 185u8 , 19u8 , 50u8 , 250u8 , 72u8 , 173u8 , 50u8 , 4u8 , 104u8 , 161u8 , 249u8 , 77u8 , 247u8 , 204u8 , 248u8 , 11u8 , 18u8 , 57u8 , 4u8 , 82u8 , 110u8 , 30u8 , 216u8 , 16u8 , 37u8 , 87u8 , 67u8 , 189u8 , 235u8 , 214u8 , 155u8 ,]) } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub fn account_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: account :: Account , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Account" , () , [213u8 , 38u8 , 200u8 , 69u8 , 218u8 , 0u8 , 112u8 , 181u8 , 160u8 , 23u8 , 96u8 , 90u8 , 3u8 , 88u8 , 126u8 , 22u8 , 103u8 , 74u8 , 64u8 , 69u8 , 29u8 , 247u8 , 18u8 , 17u8 , 234u8 , 143u8 , 189u8 , 22u8 , 247u8 , 194u8 , 154u8 , 249u8 ,]) } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub fn account (& self , _0 : types :: account :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: account :: Param0 > , types :: account :: Account , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Account" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [213u8 , 38u8 , 200u8 , 69u8 , 218u8 , 0u8 , 112u8 , 181u8 , 160u8 , 23u8 , 96u8 , 90u8 , 3u8 , 88u8 , 126u8 , 22u8 , 103u8 , 74u8 , 64u8 , 69u8 , 29u8 , 247u8 , 18u8 , 17u8 , 234u8 , 143u8 , 189u8 , 22u8 , 247u8 , 194u8 , 154u8 , 249u8 ,]) } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] # [doc = ""] # [doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn locks_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: locks :: Locks , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Locks" , () , [10u8 , 223u8 , 55u8 , 0u8 , 249u8 , 69u8 , 168u8 , 41u8 , 75u8 , 35u8 , 120u8 , 167u8 , 18u8 , 132u8 , 9u8 , 20u8 , 91u8 , 51u8 , 27u8 , 69u8 , 136u8 , 187u8 , 13u8 , 220u8 , 163u8 , 122u8 , 26u8 , 141u8 , 174u8 , 249u8 , 85u8 , 37u8 ,]) } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] # [doc = ""] # [doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn locks (& self , _0 : types :: locks :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: locks :: Param0 > , types :: locks :: Locks , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Locks" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [10u8 , 223u8 , 55u8 , 0u8 , 249u8 , 69u8 , 168u8 , 41u8 , 75u8 , 35u8 , 120u8 , 167u8 , 18u8 , 132u8 , 9u8 , 20u8 , 91u8 , 51u8 , 27u8 , 69u8 , 136u8 , 187u8 , 13u8 , 220u8 , 163u8 , 122u8 , 26u8 , 141u8 , 174u8 , 249u8 , 85u8 , 37u8 ,]) } # [doc = " Named reserves on some account balances."] # [doc = ""] # [doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn reserves_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: reserves :: Reserves , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Reserves" , () , [112u8 , 10u8 , 241u8 , 77u8 , 64u8 , 187u8 , 106u8 , 159u8 , 13u8 , 153u8 , 140u8 , 178u8 , 182u8 , 50u8 , 1u8 , 55u8 , 149u8 , 92u8 , 196u8 , 229u8 , 170u8 , 106u8 , 193u8 , 88u8 , 255u8 , 244u8 , 2u8 , 193u8 , 62u8 , 235u8 , 204u8 , 91u8 ,]) } # [doc = " Named reserves on some account balances."] # [doc = ""] # [doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn reserves (& self , _0 : types :: reserves :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: reserves :: Param0 > , types :: reserves :: Reserves , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Reserves" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [112u8 , 10u8 , 241u8 , 77u8 , 64u8 , 187u8 , 106u8 , 159u8 , 13u8 , 153u8 , 140u8 , 178u8 , 182u8 , 50u8 , 1u8 , 55u8 , 149u8 , 92u8 , 196u8 , 229u8 , 170u8 , 106u8 , 193u8 , 88u8 , 255u8 , 244u8 , 2u8 , 193u8 , 62u8 , 235u8 , 204u8 , 91u8 ,]) } # [doc = " Holds on account balances."] pub fn holds_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: holds :: Holds , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Holds" , () , [38u8 , 113u8 , 52u8 , 115u8 , 34u8 , 135u8 , 50u8 , 10u8 , 81u8 , 7u8 , 11u8 , 241u8 , 122u8 , 128u8 , 163u8 , 54u8 , 249u8 , 238u8 , 237u8 , 12u8 , 56u8 , 182u8 , 162u8 , 206u8 , 123u8 , 45u8 , 23u8 , 127u8 , 165u8 , 158u8 , 88u8 , 169u8 ,]) } # [doc = " Holds on account balances."] pub fn holds (& self , _0 : types :: holds :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: holds :: Param0 > , types :: holds :: Holds , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Holds" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [38u8 , 113u8 , 52u8 , 115u8 , 34u8 , 135u8 , 50u8 , 10u8 , 81u8 , 7u8 , 11u8 , 241u8 , 122u8 , 128u8 , 163u8 , 54u8 , 249u8 , 238u8 , 237u8 , 12u8 , 56u8 , 182u8 , 162u8 , 206u8 , 123u8 , 45u8 , 23u8 , 127u8 , 165u8 , 158u8 , 88u8 , 169u8 ,]) } # [doc = " Freeze locks on account balances."] pub fn freezes_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: freezes :: Freezes , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Freezes" , () , [69u8 , 49u8 , 165u8 , 76u8 , 135u8 , 142u8 , 179u8 , 118u8 , 50u8 , 109u8 , 53u8 , 112u8 , 110u8 , 94u8 , 30u8 , 93u8 , 173u8 , 38u8 , 27u8 , 142u8 , 19u8 , 5u8 , 163u8 , 4u8 , 68u8 , 218u8 , 179u8 , 224u8 , 118u8 , 218u8 , 115u8 , 64u8 ,]) } # [doc = " Freeze locks on account balances."] pub fn freezes (& self , _0 : types :: freezes :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: freezes :: Param0 > , types :: freezes :: Freezes , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Balances" , "Freezes" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [69u8 , 49u8 , 165u8 , 76u8 , 135u8 , 142u8 , 179u8 , 118u8 , 50u8 , 109u8 , 53u8 , 112u8 , 110u8 , 94u8 , 30u8 , 93u8 , 173u8 , 38u8 , 27u8 , 142u8 , 19u8 , 5u8 , 163u8 , 4u8 , 68u8 , 218u8 , 179u8 , 224u8 , 118u8 , 218u8 , 115u8 , 64u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum amount required to keep an account open. MUST BE GREATER THAN ZERO!"] # [doc = ""] # [doc = " If you *really* need it to be zero, you can enable the feature `insecure_zero_ed` for"] # [doc = " this pallet. However, you do so at your own risk: this will open up a major DoS vector."] # [doc = " In case you have multiple sources of provider references, you may also get unexpected"] # [doc = " behaviour if you set this to zero."] # [doc = ""] # [doc = " Bottom line: Do yourself a favour and make it at least one!"] pub fn existential_deposit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Balances" , "ExistentialDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum number of locks that should exist on an account."] # [doc = " Not strictly enforced, but used for weight estimation."] # [doc = ""] # [doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn max_locks (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Balances" , "MaxLocks" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of named reserves that can exist on an account."] # [doc = ""] # [doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"] pub fn max_reserves (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Balances" , "MaxReserves" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of individual freeze locks that can exist on an account at any time."] pub fn max_freezes (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Balances" , "MaxFreezes" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod transaction_fees { use super :: root_mod ; use super :: runtime_types ; # [doc = "`pallet-transaction-fees` events"] pub type Event = runtime_types :: pallet_transaction_fees :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Storage fees."] pub struct BlockFees { pub who : block_fees :: Who , pub storage : block_fees :: Storage , pub compute : block_fees :: Compute , pub tips : block_fees :: Tips , } pub mod block_fees { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Storage = :: core :: primitive :: u128 ; pub type Compute = :: core :: primitive :: u128 ; pub type Tips = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BlockFees { const PALLET : & 'static str = "TransactionFees" ; const EVENT : & 'static str = "BlockFees" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Fees burned due to equivocated block author or rewards not enabled."] pub struct BurnedBlockFees { pub storage : burned_block_fees :: Storage , pub compute : burned_block_fees :: Compute , pub tips : burned_block_fees :: Tips , } pub mod burned_block_fees { use super :: runtime_types ; pub type Storage = :: core :: primitive :: u128 ; pub type Compute = :: core :: primitive :: u128 ; pub type Tips = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BurnedBlockFees { const PALLET : & 'static str = "TransactionFees" ; const EVENT : & 'static str = "BurnedBlockFees" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod transaction_byte_fee { use super :: runtime_types ; pub type TransactionByteFee = runtime_types :: subspace_runtime_primitives :: BlockTransactionByteFee < :: core :: primitive :: u128 > ; } pub mod is_during_block_execution { use super :: runtime_types ; pub type IsDuringBlockExecution = :: core :: primitive :: bool ; } pub mod block_author { use super :: runtime_types ; pub type BlockAuthor = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod collected_block_fees { use super :: runtime_types ; pub type CollectedBlockFees = runtime_types :: pallet_transaction_fees :: CollectedFees < :: core :: primitive :: u128 > ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The value of `transaction_byte_fee` for both the current and the next block."] # [doc = ""] # [doc = " The `next` value of `transaction_byte_fee` is updated at block finalization and used to"] # [doc = " validate extrinsic to be included in the next block, the value is move to `current` at"] # [doc = " block initialization and used to execute extrinsic in the current block. Together it"] # [doc = " ensure we use the same value for both validating and executing the extrinsic."] # [doc = ""] # [doc = " NOTE: both the `current` and `next` value is set to the default `Balance::max_value` in"] # [doc = " the genesis block which means there will be no signed extrinsic included in block #1."] pub fn transaction_byte_fee (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: transaction_byte_fee :: TransactionByteFee , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TransactionFees" , "TransactionByteFee" , () , [202u8 , 23u8 , 174u8 , 146u8 , 181u8 , 102u8 , 188u8 , 3u8 , 175u8 , 119u8 , 173u8 , 180u8 , 55u8 , 223u8 , 109u8 , 34u8 , 142u8 , 176u8 , 1u8 , 143u8 , 190u8 , 248u8 , 254u8 , 149u8 , 47u8 , 143u8 , 242u8 , 18u8 , 43u8 , 193u8 , 183u8 , 157u8 ,]) } # [doc = " Temporary value (cleared at block finalization) used to determine if the `transaction_byte_fee`"] # [doc = " is used to validate extrinsic or execute extrinsic."] pub fn is_during_block_execution (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: is_during_block_execution :: IsDuringBlockExecution , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TransactionFees" , "IsDuringBlockExecution" , () , [253u8 , 179u8 , 235u8 , 110u8 , 180u8 , 18u8 , 250u8 , 237u8 , 131u8 , 201u8 , 205u8 , 203u8 , 190u8 , 13u8 , 99u8 , 121u8 , 16u8 , 45u8 , 3u8 , 54u8 , 249u8 , 226u8 , 57u8 , 129u8 , 220u8 , 212u8 , 139u8 , 244u8 , 225u8 , 235u8 , 232u8 , 69u8 ,]) } # [doc = " Temporary value (cleared at block finalization) which contains current block author, so we"] # [doc = " can issue fees during block finalization."] pub fn block_author (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_author :: BlockAuthor , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TransactionFees" , "BlockAuthor" , () , [41u8 , 63u8 , 237u8 , 112u8 , 5u8 , 104u8 , 197u8 , 116u8 , 94u8 , 253u8 , 128u8 , 248u8 , 208u8 , 249u8 , 119u8 , 246u8 , 64u8 , 251u8 , 57u8 , 239u8 , 200u8 , 211u8 , 73u8 , 222u8 , 14u8 , 194u8 , 96u8 , 206u8 , 36u8 , 147u8 , 162u8 , 9u8 ,]) } # [doc = " Temporary value (cleared at block finalization) which contains current block fees, so we can"] # [doc = " issue fees during block finalization."] pub fn collected_block_fees (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: collected_block_fees :: CollectedBlockFees , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TransactionFees" , "CollectedBlockFees" , () , [89u8 , 41u8 , 20u8 , 236u8 , 212u8 , 60u8 , 7u8 , 80u8 , 254u8 , 79u8 , 62u8 , 45u8 , 228u8 , 42u8 , 168u8 , 95u8 , 173u8 , 254u8 , 165u8 , 97u8 , 237u8 , 53u8 , 102u8 , 81u8 , 151u8 , 82u8 , 246u8 , 161u8 , 165u8 , 233u8 , 254u8 , 110u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Minimum desired number of replicas of the blockchain to be stored by the network,"] # [doc = " impacts storage fees."] pub fn min_replication_factor (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u16 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("TransactionFees" , "MinReplicationFactor" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } # [doc = " How many credits there is in circulation."] pub fn credit_supply (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("TransactionFees" , "CreditSupply" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " How much space there is on the network."] pub fn total_space_pledged (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("TransactionFees" , "TotalSpacePledged" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " How big is the history of the blockchain in archived state (thus includes erasure"] # [doc = " coding, but not replication)."] pub fn blockchain_history_size (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("TransactionFees" , "BlockchainHistorySize" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } } } } pub mod transaction_payment { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_transaction_payment :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] pub struct TransactionFeePaid { pub who : transaction_fee_paid :: Who , pub actual_fee : transaction_fee_paid :: ActualFee , pub tip : transaction_fee_paid :: Tip , } pub mod transaction_fee_paid { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ActualFee = :: core :: primitive :: u128 ; pub type Tip = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for TransactionFeePaid { const PALLET : & 'static str = "TransactionPayment" ; const EVENT : & 'static str = "TransactionFeePaid" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod next_fee_multiplier { use super :: runtime_types ; pub type NextFeeMultiplier = runtime_types :: sp_arithmetic :: fixed_point :: FixedU128 ; } pub mod storage_version { use super :: runtime_types ; pub type StorageVersion = runtime_types :: pallet_transaction_payment :: Releases ; } } pub struct StorageApi ; impl StorageApi { pub fn next_fee_multiplier (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_fee_multiplier :: NextFeeMultiplier , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TransactionPayment" , "NextFeeMultiplier" , () , [247u8 , 39u8 , 81u8 , 170u8 , 225u8 , 226u8 , 82u8 , 147u8 , 34u8 , 113u8 , 147u8 , 213u8 , 59u8 , 80u8 , 139u8 , 35u8 , 36u8 , 196u8 , 152u8 , 19u8 , 9u8 , 159u8 , 176u8 , 79u8 , 249u8 , 201u8 , 170u8 , 1u8 , 129u8 , 79u8 , 146u8 , 197u8 ,]) } pub fn storage_version (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: storage_version :: StorageVersion , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("TransactionPayment" , "StorageVersion" , () , [105u8 , 243u8 , 158u8 , 241u8 , 159u8 , 231u8 , 253u8 , 6u8 , 4u8 , 32u8 , 85u8 , 178u8 , 126u8 , 31u8 , 203u8 , 134u8 , 154u8 , 38u8 , 122u8 , 155u8 , 150u8 , 251u8 , 174u8 , 15u8 , 74u8 , 134u8 , 216u8 , 244u8 , 168u8 , 175u8 , 158u8 , 144u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " A fee multiplier for `Operational` extrinsics to compute \"virtual tip\" to boost their"] # [doc = " `priority`"] # [doc = ""] # [doc = " This value is multiplied by the `final_fee` to obtain a \"virtual tip\" that is later"] # [doc = " added to a tip component in regular `priority` calculations."] # [doc = " It means that a `Normal` transaction can front-run a similarly-sized `Operational`"] # [doc = " extrinsic (with no tip), by including a tip value greater than the virtual tip."] # [doc = ""] # [doc = " ```rust,ignore"] # [doc = " // For `Normal`"] # [doc = " let priority = priority_calc(tip);"] # [doc = ""] # [doc = " // For `Operational`"] # [doc = " let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;"] # [doc = " let priority = priority_calc(tip + virtual_tip);"] # [doc = " ```"] # [doc = ""] # [doc = " Note that since we use `final_fee` the multiplier applies also to the regular `tip`"] # [doc = " sent with the transaction. So, not only does the transaction get a priority bump based"] # [doc = " on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`"] # [doc = " transactions."] pub fn operational_fee_multiplier (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u8 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("TransactionPayment" , "OperationalFeeMultiplier" , [141u8 , 130u8 , 11u8 , 35u8 , 226u8 , 114u8 , 92u8 , 179u8 , 168u8 , 110u8 , 28u8 , 91u8 , 221u8 , 64u8 , 4u8 , 148u8 , 201u8 , 193u8 , 185u8 , 66u8 , 226u8 , 114u8 , 97u8 , 79u8 , 62u8 , 212u8 , 202u8 , 114u8 , 237u8 , 228u8 , 183u8 , 165u8 ,]) } } } } pub mod utility { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_utility :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_utility :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Send a batch of dispatch calls."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] # [doc = ""] # [doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"] # [doc = "event is deposited. If a call failed and the batch was interrupted, then the"] # [doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"] # [doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"] # [doc = "event is deposited."] pub struct Batch { pub calls : batch :: Calls , } pub mod batch { use super :: runtime_types ; pub type Calls = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_runtime :: RuntimeCall > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Batch { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "batch" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Send a call through an indexed pseudonym of the sender."] # [doc = ""] # [doc = "Filter from origin are passed along. The call will be dispatched with an origin which"] # [doc = "use the same filter as the origin of this call."] # [doc = ""] # [doc = "NOTE: If you need to ensure that any account-based filtering is not honored (i.e."] # [doc = "because you expect `proxy` to have been used prior in the call stack and you do not want"] # [doc = "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`"] # [doc = "in the Multisig pallet instead."] # [doc = ""] # [doc = "NOTE: Prior to version *12, this was called `as_limited_sub`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub struct AsDerivative { pub index : as_derivative :: Index , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < as_derivative :: Call > , } pub mod as_derivative { use super :: runtime_types ; pub type Index = :: core :: primitive :: u16 ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AsDerivative { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "as_derivative" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Send a batch of dispatch calls and atomically execute them."] # [doc = "The whole transaction will rollback and fail if any of the calls failed."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] pub struct BatchAll { pub calls : batch_all :: Calls , } pub mod batch_all { use super :: runtime_types ; pub type Calls = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_runtime :: RuntimeCall > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for BatchAll { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "batch_all" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatches a function call with a provided origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub struct DispatchAs { pub as_origin : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < dispatch_as :: AsOrigin > , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < dispatch_as :: Call > , } pub mod dispatch_as { use super :: runtime_types ; pub type AsOrigin = runtime_types :: subspace_runtime :: OriginCaller ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for DispatchAs { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "dispatch_as" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Send a batch of dispatch calls."] # [doc = "Unlike `batch`, it allows errors and won't interrupt."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatch without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] pub struct ForceBatch { pub calls : force_batch :: Calls , } pub mod force_batch { use super :: runtime_types ; pub type Calls = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_runtime :: RuntimeCall > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceBatch { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "force_batch" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatch a function call with a specified weight."] # [doc = ""] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Root origin to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] pub struct WithWeight { pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < with_weight :: Call > , pub weight : with_weight :: Weight , } pub mod with_weight { use super :: runtime_types ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; pub type Weight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for WithWeight { const PALLET : & 'static str = "Utility" ; const CALL : & 'static str = "with_weight" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Send a batch of dispatch calls."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] # [doc = ""] # [doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"] # [doc = "event is deposited. If a call failed and the batch was interrupted, then the"] # [doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"] # [doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"] # [doc = "event is deposited."] pub fn batch (& self , calls : types :: batch :: Calls ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Batch > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "batch" , types :: Batch { calls , } , [140u8 , 64u8 , 110u8 , 104u8 , 71u8 , 10u8 , 32u8 , 227u8 , 153u8 , 39u8 , 187u8 , 61u8 , 51u8 , 137u8 , 232u8 , 116u8 , 180u8 , 196u8 , 96u8 , 22u8 , 210u8 , 250u8 , 164u8 , 203u8 , 196u8 , 196u8 , 249u8 , 34u8 , 2u8 , 59u8 , 192u8 , 94u8 ,]) } # [doc = "Send a call through an indexed pseudonym of the sender."] # [doc = ""] # [doc = "Filter from origin are passed along. The call will be dispatched with an origin which"] # [doc = "use the same filter as the origin of this call."] # [doc = ""] # [doc = "NOTE: If you need to ensure that any account-based filtering is not honored (i.e."] # [doc = "because you expect `proxy` to have been used prior in the call stack and you do not want"] # [doc = "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`"] # [doc = "in the Multisig pallet instead."] # [doc = ""] # [doc = "NOTE: Prior to version *12, this was called `as_limited_sub`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub fn as_derivative (& self , index : types :: as_derivative :: Index , call : types :: as_derivative :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AsDerivative > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "as_derivative" , types :: AsDerivative { index , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [56u8 , 26u8 , 70u8 , 244u8 , 84u8 , 87u8 , 0u8 , 228u8 , 36u8 , 245u8 , 126u8 , 108u8 , 175u8 , 233u8 , 157u8 , 106u8 , 171u8 , 33u8 , 105u8 , 237u8 , 61u8 , 237u8 , 18u8 , 195u8 , 4u8 , 137u8 , 18u8 , 136u8 , 189u8 , 142u8 , 14u8 , 197u8 ,]) } # [doc = "Send a batch of dispatch calls and atomically execute them."] # [doc = "The whole transaction will rollback and fail if any of the calls failed."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] pub fn batch_all (& self , calls : types :: batch_all :: Calls ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: BatchAll > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "batch_all" , types :: BatchAll { calls , } , [17u8 , 75u8 , 64u8 , 10u8 , 226u8 , 217u8 , 122u8 , 101u8 , 79u8 , 47u8 , 90u8 , 139u8 , 188u8 , 93u8 , 21u8 , 201u8 , 129u8 , 1u8 , 76u8 , 221u8 , 179u8 , 236u8 , 60u8 , 170u8 , 228u8 , 143u8 , 209u8 , 58u8 , 8u8 , 233u8 , 224u8 , 176u8 ,]) } # [doc = "Dispatches a function call with a provided origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn dispatch_as (& self , as_origin : types :: dispatch_as :: AsOrigin , call : types :: dispatch_as :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: DispatchAs > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "dispatch_as" , types :: DispatchAs { as_origin : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (as_origin) , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [97u8 , 78u8 , 144u8 , 166u8 , 102u8 , 248u8 , 71u8 , 12u8 , 85u8 , 181u8 , 154u8 , 4u8 , 121u8 , 43u8 , 193u8 , 1u8 , 161u8 , 207u8 , 228u8 , 31u8 , 150u8 , 6u8 , 230u8 , 1u8 , 197u8 , 196u8 , 96u8 , 54u8 , 158u8 , 130u8 , 165u8 , 32u8 ,]) } # [doc = "Send a batch of dispatch calls."] # [doc = "Unlike `batch`, it allows errors and won't interrupt."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatch without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] pub fn force_batch (& self , calls : types :: force_batch :: Calls ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceBatch > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "force_batch" , types :: ForceBatch { calls , } , [84u8 , 91u8 , 22u8 , 220u8 , 242u8 , 224u8 , 219u8 , 6u8 , 14u8 , 189u8 , 144u8 , 73u8 , 21u8 , 38u8 , 216u8 , 142u8 , 213u8 , 37u8 , 124u8 , 21u8 , 136u8 , 91u8 , 248u8 , 63u8 , 247u8 , 173u8 , 228u8 , 121u8 , 47u8 , 244u8 , 153u8 , 12u8 ,]) } # [doc = "Dispatch a function call with a specified weight."] # [doc = ""] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Root origin to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] pub fn with_weight (& self , call : types :: with_weight :: Call , weight : types :: with_weight :: Weight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: WithWeight > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Utility" , "with_weight" , types :: WithWeight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , weight , } , [102u8 , 21u8 , 255u8 , 197u8 , 165u8 , 246u8 , 248u8 , 51u8 , 4u8 , 38u8 , 185u8 , 198u8 , 49u8 , 238u8 , 49u8 , 54u8 , 185u8 , 98u8 , 60u8 , 218u8 , 96u8 , 218u8 , 155u8 , 179u8 , 178u8 , 129u8 , 101u8 , 100u8 , 104u8 , 237u8 , 88u8 , 1u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_utility :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"] # [doc = "well as the error."] pub struct BatchInterrupted { pub index : batch_interrupted :: Index , pub error : batch_interrupted :: Error , } pub mod batch_interrupted { use super :: runtime_types ; pub type Index = :: core :: primitive :: u32 ; pub type Error = runtime_types :: sp_runtime :: DispatchError ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BatchInterrupted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchInterrupted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Batch of dispatches completed fully with no error."] pub struct BatchCompleted ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BatchCompleted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchCompleted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Batch of dispatches completed but has errors."] pub struct BatchCompletedWithErrors ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BatchCompletedWithErrors { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchCompletedWithErrors" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A single item within a Batch of dispatches has completed with no error."] pub struct ItemCompleted ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ItemCompleted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "ItemCompleted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A single item within a Batch of dispatches has completed with error."] pub struct ItemFailed { pub error : item_failed :: Error , } pub mod item_failed { use super :: runtime_types ; pub type Error = runtime_types :: sp_runtime :: DispatchError ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ItemFailed { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "ItemFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A call was dispatched."] pub struct DispatchedAs { pub result : dispatched_as :: Result , } pub mod dispatched_as { use super :: runtime_types ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DispatchedAs { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "DispatchedAs" ; } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The limit on the number of batched calls."] pub fn batched_calls_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Utility" , "batched_calls_limit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod domains { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_domains :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_domains :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubmitBundle { pub opaque_bundle : submit_bundle :: OpaqueBundle , } pub mod submit_bundle { use super :: runtime_types ; pub type OpaqueBundle = runtime_types :: sp_domains :: Bundle < runtime_types :: sp_runtime :: OpaqueExtrinsic , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: core :: primitive :: u128 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SubmitBundle { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "submit_bundle" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubmitFraudProof { pub fraud_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < submit_fraud_proof :: FraudProof > , } pub mod submit_fraud_proof { use super :: runtime_types ; pub type FraudProof = runtime_types :: sp_domains_fraud_proof :: fraud_proof :: FraudProof < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: subxt :: ext :: subxt_core :: utils :: H256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SubmitFraudProof { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "submit_fraud_proof" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RegisterDomainRuntime { pub runtime_name : register_domain_runtime :: RuntimeName , pub runtime_type : register_domain_runtime :: RuntimeType , pub raw_genesis_storage : register_domain_runtime :: RawGenesisStorage , } pub mod register_domain_runtime { use super :: runtime_types ; pub type RuntimeName = :: subxt :: ext :: subxt_core :: alloc :: string :: String ; pub type RuntimeType = runtime_types :: sp_domains :: RuntimeType ; pub type RawGenesisStorage = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RegisterDomainRuntime { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "register_domain_runtime" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct UpgradeDomainRuntime { pub runtime_id : upgrade_domain_runtime :: RuntimeId , pub raw_genesis_storage : upgrade_domain_runtime :: RawGenesisStorage , } pub mod upgrade_domain_runtime { use super :: runtime_types ; pub type RuntimeId = :: core :: primitive :: u32 ; pub type RawGenesisStorage = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UpgradeDomainRuntime { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "upgrade_domain_runtime" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RegisterOperator { pub domain_id : register_operator :: DomainId , pub amount : register_operator :: Amount , pub config : register_operator :: Config , } pub mod register_operator { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type Amount = :: core :: primitive :: u128 ; pub type Config = runtime_types :: pallet_domains :: staking :: OperatorConfig < :: core :: primitive :: u128 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RegisterOperator { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "register_operator" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct NominateOperator { pub operator_id : nominate_operator :: OperatorId , pub amount : nominate_operator :: Amount , } pub mod nominate_operator { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for NominateOperator { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "nominate_operator" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InstantiateDomain { pub domain_config_params : instantiate_domain :: DomainConfigParams , } pub mod instantiate_domain { use super :: runtime_types ; pub type DomainConfigParams = runtime_types :: pallet_domains :: domain_registry :: DomainConfigParams < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u128 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for InstantiateDomain { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "instantiate_domain" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DeregisterOperator { pub operator_id : deregister_operator :: OperatorId , } pub mod deregister_operator { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for DeregisterOperator { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "deregister_operator" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct WithdrawStake { pub operator_id : withdraw_stake :: OperatorId , pub to_withdraw : withdraw_stake :: ToWithdraw , } pub mod withdraw_stake { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type ToWithdraw = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for WithdrawStake { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "withdraw_stake" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Unlocks the first withdrawal given the unlocking period is complete."] # [doc = "Even if the rest of the withdrawals are out of the unlocking period, the nominator"] # [doc = "should call this extrinsic to unlock each withdrawal"] pub struct UnlockFunds { pub operator_id : unlock_funds :: OperatorId , } pub mod unlock_funds { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UnlockFunds { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "unlock_funds" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Unlocks the nominator under given operator given the unlocking period is complete."] # [doc = "A nominator can initiate their unlock given operator is already deregistered."] pub struct UnlockNominator { pub operator_id : unlock_nominator :: OperatorId , } pub mod unlock_nominator { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UnlockNominator { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "unlock_nominator" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Extrinsic to update domain's operator allow list."] # [doc = "Note:"] # [doc = "- If the previous allowed list is set to specific operators and new allow list is set"] # [doc = "  to `Anyone`, then domain will become permissioned to open for all operators."] # [doc = "- If the previous allowed list is set to `Anyone` or specific operators and the new"] # [doc = "  allow list is set to specific operators, then all the registered not allowed operators"] # [doc = "  will continue to operate until they de-register themselves."] pub struct UpdateDomainOperatorAllowList { pub domain_id : update_domain_operator_allow_list :: DomainId , pub operator_allow_list : update_domain_operator_allow_list :: OperatorAllowList , } pub mod update_domain_operator_allow_list { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type OperatorAllowList = runtime_types :: sp_domains :: OperatorAllowList < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UpdateDomainOperatorAllowList { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "update_domain_operator_allow_list" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Force staking epoch transition for a given domain"] pub struct ForceStakingEpochTransition { pub domain_id : force_staking_epoch_transition :: DomainId , } pub mod force_staking_epoch_transition { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ForceStakingEpochTransition { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "force_staking_epoch_transition" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Update permissioned action allowed by storage by Sudo."] pub struct SetPermissionedActionAllowedBy { pub permissioned_action_allowed_by : set_permissioned_action_allowed_by :: PermissionedActionAllowedBy , } pub mod set_permissioned_action_allowed_by { use super :: runtime_types ; pub type PermissionedActionAllowedBy = runtime_types :: sp_domains :: PermissionedActionAllowedBy < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetPermissionedActionAllowedBy { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "set_permissioned_action_allowed_by" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Submit a domain sudo call."] pub struct SendDomainSudoCall { pub domain_id : send_domain_sudo_call :: DomainId , pub call : send_domain_sudo_call :: Call , } pub mod send_domain_sudo_call { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type Call = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SendDomainSudoCall { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "send_domain_sudo_call" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Freezes a given domain."] # [doc = "A frozen domain does not accept new bundles but accepts fraud proofs."] pub struct FreezeDomain { pub domain_id : freeze_domain :: DomainId , } pub mod freeze_domain { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for FreezeDomain { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "freeze_domain" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Unfreezes a frozen domain."] pub struct UnfreezeDomain { pub domain_id : unfreeze_domain :: DomainId , } pub mod unfreeze_domain { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UnfreezeDomain { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "unfreeze_domain" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Prunes a given execution receipt for given frozen domain."] # [doc = "This call assumes the execution receipt to be bad and implicitly trusts Sudo"] # [doc = "to do the necessary validation of the ER before dispatching this call."] pub struct PruneDomainExecutionReceipt { pub domain_id : prune_domain_execution_receipt :: DomainId , pub bad_receipt_hash : prune_domain_execution_receipt :: BadReceiptHash , } pub mod prune_domain_execution_receipt { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type BadReceiptHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for PruneDomainExecutionReceipt { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "prune_domain_execution_receipt" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Transfer funds from treasury to given account"] pub struct TransferTreasuryFunds { pub account_id : transfer_treasury_funds :: AccountId , pub balance : transfer_treasury_funds :: Balance , } pub mod transfer_treasury_funds { use super :: runtime_types ; pub type AccountId = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Balance = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for TransferTreasuryFunds { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "transfer_treasury_funds" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubmitReceipt { pub singleton_receipt : submit_receipt :: SingletonReceipt , } pub mod submit_receipt { use super :: runtime_types ; pub type SingletonReceipt = runtime_types :: sp_domains :: SealedSingletonReceipt < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: core :: primitive :: u128 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SubmitReceipt { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "submit_receipt" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Submit an EVM domain \"set contract creation allowed by\" call as domain owner or root."] pub struct SendEvmDomainSetContractCreationAllowedByCall { pub domain_id : send_evm_domain_set_contract_creation_allowed_by_call :: DomainId , pub contract_creation_allowed_by : send_evm_domain_set_contract_creation_allowed_by_call :: ContractCreationAllowedBy , } pub mod send_evm_domain_set_contract_creation_allowed_by_call { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type ContractCreationAllowedBy = runtime_types :: sp_domains :: PermissionedActionAllowedBy < :: subxt :: ext :: subxt_core :: utils :: AccountId20 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SendEvmDomainSetContractCreationAllowedByCall { const PALLET : & 'static str = "Domains" ; const CALL : & 'static str = "send_evm_domain_set_contract_creation_allowed_by_call" ; } } pub struct TransactionApi ; impl TransactionApi { pub fn submit_bundle (& self , opaque_bundle : types :: submit_bundle :: OpaqueBundle ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SubmitBundle > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "submit_bundle" , types :: SubmitBundle { opaque_bundle , } , [54u8 , 180u8 , 201u8 , 143u8 , 239u8 , 58u8 , 11u8 , 137u8 , 251u8 , 9u8 , 248u8 , 183u8 , 222u8 , 250u8 , 146u8 , 66u8 , 154u8 , 163u8 , 55u8 , 130u8 , 221u8 , 129u8 , 40u8 , 68u8 , 254u8 , 87u8 , 3u8 , 135u8 , 68u8 , 45u8 , 214u8 , 182u8 ,]) } pub fn submit_fraud_proof (& self , fraud_proof : types :: submit_fraud_proof :: FraudProof ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SubmitFraudProof > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "submit_fraud_proof" , types :: SubmitFraudProof { fraud_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (fraud_proof) , } , [107u8 , 105u8 , 28u8 , 178u8 , 235u8 , 68u8 , 33u8 , 183u8 , 240u8 , 126u8 , 92u8 , 135u8 , 72u8 , 52u8 , 21u8 , 0u8 , 131u8 , 175u8 , 160u8 , 103u8 , 117u8 , 113u8 , 236u8 , 55u8 , 58u8 , 153u8 , 38u8 , 232u8 , 201u8 , 187u8 , 191u8 , 212u8 ,]) } pub fn register_domain_runtime (& self , runtime_name : types :: register_domain_runtime :: RuntimeName , runtime_type : types :: register_domain_runtime :: RuntimeType , raw_genesis_storage : types :: register_domain_runtime :: RawGenesisStorage ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RegisterDomainRuntime > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "register_domain_runtime" , types :: RegisterDomainRuntime { runtime_name , runtime_type , raw_genesis_storage , } , [205u8 , 63u8 , 221u8 , 130u8 , 192u8 , 12u8 , 112u8 , 50u8 , 169u8 , 116u8 , 136u8 , 207u8 , 41u8 , 240u8 , 62u8 , 167u8 , 45u8 , 164u8 , 198u8 , 190u8 , 151u8 , 254u8 , 247u8 , 239u8 , 50u8 , 148u8 , 114u8 , 211u8 , 252u8 , 39u8 , 38u8 , 192u8 ,]) } pub fn upgrade_domain_runtime (& self , runtime_id : types :: upgrade_domain_runtime :: RuntimeId , raw_genesis_storage : types :: upgrade_domain_runtime :: RawGenesisStorage ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UpgradeDomainRuntime > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "upgrade_domain_runtime" , types :: UpgradeDomainRuntime { runtime_id , raw_genesis_storage , } , [217u8 , 14u8 , 211u8 , 217u8 , 103u8 , 73u8 , 64u8 , 26u8 , 252u8 , 19u8 , 90u8 , 73u8 , 115u8 , 70u8 , 48u8 , 19u8 , 48u8 , 37u8 , 152u8 , 43u8 , 168u8 , 41u8 , 68u8 , 123u8 , 110u8 , 125u8 , 110u8 , 211u8 , 58u8 , 44u8 , 158u8 , 58u8 ,]) } pub fn register_operator (& self , domain_id : types :: register_operator :: DomainId , amount : types :: register_operator :: Amount , config : types :: register_operator :: Config ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RegisterOperator > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "register_operator" , types :: RegisterOperator { domain_id , amount , config , } , [3u8 , 203u8 , 105u8 , 198u8 , 227u8 , 122u8 , 25u8 , 8u8 , 31u8 , 227u8 , 51u8 , 169u8 , 214u8 , 147u8 , 13u8 , 128u8 , 43u8 , 179u8 , 75u8 , 224u8 , 179u8 , 91u8 , 225u8 , 146u8 , 109u8 , 129u8 , 217u8 , 190u8 , 62u8 , 5u8 , 80u8 , 132u8 ,]) } pub fn nominate_operator (& self , operator_id : types :: nominate_operator :: OperatorId , amount : types :: nominate_operator :: Amount ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: NominateOperator > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "nominate_operator" , types :: NominateOperator { operator_id , amount , } , [65u8 , 173u8 , 169u8 , 32u8 , 54u8 , 4u8 , 233u8 , 196u8 , 60u8 , 113u8 , 209u8 , 149u8 , 215u8 , 97u8 , 102u8 , 23u8 , 85u8 , 187u8 , 160u8 , 23u8 , 88u8 , 88u8 , 180u8 , 118u8 , 136u8 , 130u8 , 251u8 , 182u8 , 191u8 , 174u8 , 175u8 , 8u8 ,]) } pub fn instantiate_domain (& self , domain_config_params : types :: instantiate_domain :: DomainConfigParams ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: InstantiateDomain > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "instantiate_domain" , types :: InstantiateDomain { domain_config_params , } , [169u8 , 35u8 , 162u8 , 194u8 , 10u8 , 246u8 , 23u8 , 64u8 , 202u8 , 78u8 , 218u8 , 119u8 , 245u8 , 253u8 , 99u8 , 208u8 , 10u8 , 103u8 , 116u8 , 121u8 , 216u8 , 65u8 , 229u8 , 33u8 , 159u8 , 182u8 , 112u8 , 33u8 , 70u8 , 70u8 , 238u8 , 133u8 ,]) } pub fn deregister_operator (& self , operator_id : types :: deregister_operator :: OperatorId ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: DeregisterOperator > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "deregister_operator" , types :: DeregisterOperator { operator_id , } , [217u8 , 130u8 , 77u8 , 56u8 , 230u8 , 106u8 , 160u8 , 222u8 , 129u8 , 70u8 , 254u8 , 98u8 , 242u8 , 87u8 , 159u8 , 15u8 , 213u8 , 67u8 , 208u8 , 83u8 , 75u8 , 143u8 , 4u8 , 20u8 , 237u8 , 87u8 , 220u8 , 138u8 , 138u8 , 38u8 , 143u8 , 215u8 ,]) } pub fn withdraw_stake (& self , operator_id : types :: withdraw_stake :: OperatorId , to_withdraw : types :: withdraw_stake :: ToWithdraw ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: WithdrawStake > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "withdraw_stake" , types :: WithdrawStake { operator_id , to_withdraw , } , [47u8 , 80u8 , 44u8 , 177u8 , 130u8 , 143u8 , 121u8 , 11u8 , 67u8 , 225u8 , 100u8 , 150u8 , 194u8 , 197u8 , 20u8 , 63u8 , 234u8 , 143u8 , 55u8 , 191u8 , 171u8 , 243u8 , 99u8 , 245u8 , 138u8 , 6u8 , 122u8 , 49u8 , 5u8 , 217u8 , 233u8 , 0u8 ,]) } # [doc = "Unlocks the first withdrawal given the unlocking period is complete."] # [doc = "Even if the rest of the withdrawals are out of the unlocking period, the nominator"] # [doc = "should call this extrinsic to unlock each withdrawal"] pub fn unlock_funds (& self , operator_id : types :: unlock_funds :: OperatorId ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UnlockFunds > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "unlock_funds" , types :: UnlockFunds { operator_id , } , [243u8 , 224u8 , 49u8 , 96u8 , 128u8 , 50u8 , 255u8 , 1u8 , 221u8 , 123u8 , 248u8 , 29u8 , 139u8 , 29u8 , 63u8 , 101u8 , 35u8 , 192u8 , 71u8 , 205u8 , 196u8 , 131u8 , 163u8 , 81u8 , 127u8 , 222u8 , 31u8 , 153u8 , 199u8 , 85u8 , 58u8 , 2u8 ,]) } # [doc = "Unlocks the nominator under given operator given the unlocking period is complete."] # [doc = "A nominator can initiate their unlock given operator is already deregistered."] pub fn unlock_nominator (& self , operator_id : types :: unlock_nominator :: OperatorId ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UnlockNominator > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "unlock_nominator" , types :: UnlockNominator { operator_id , } , [136u8 , 180u8 , 77u8 , 228u8 , 207u8 , 26u8 , 90u8 , 219u8 , 43u8 , 246u8 , 118u8 , 115u8 , 194u8 , 97u8 , 168u8 , 84u8 , 186u8 , 131u8 , 123u8 , 122u8 , 118u8 , 101u8 , 92u8 , 244u8 , 145u8 , 199u8 , 204u8 , 147u8 , 90u8 , 220u8 , 155u8 , 114u8 ,]) } # [doc = "Extrinsic to update domain's operator allow list."] # [doc = "Note:"] # [doc = "- If the previous allowed list is set to specific operators and new allow list is set"] # [doc = "  to `Anyone`, then domain will become permissioned to open for all operators."] # [doc = "- If the previous allowed list is set to `Anyone` or specific operators and the new"] # [doc = "  allow list is set to specific operators, then all the registered not allowed operators"] # [doc = "  will continue to operate until they de-register themselves."] pub fn update_domain_operator_allow_list (& self , domain_id : types :: update_domain_operator_allow_list :: DomainId , operator_allow_list : types :: update_domain_operator_allow_list :: OperatorAllowList ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UpdateDomainOperatorAllowList > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "update_domain_operator_allow_list" , types :: UpdateDomainOperatorAllowList { domain_id , operator_allow_list , } , [75u8 , 177u8 , 240u8 , 164u8 , 70u8 , 179u8 , 81u8 , 221u8 , 76u8 , 215u8 , 94u8 , 175u8 , 95u8 , 23u8 , 236u8 , 135u8 , 242u8 , 64u8 , 63u8 , 203u8 , 203u8 , 140u8 , 211u8 , 253u8 , 71u8 , 249u8 , 241u8 , 11u8 , 81u8 , 200u8 , 99u8 , 0u8 ,]) } # [doc = "Force staking epoch transition for a given domain"] pub fn force_staking_epoch_transition (& self , domain_id : types :: force_staking_epoch_transition :: DomainId ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ForceStakingEpochTransition > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "force_staking_epoch_transition" , types :: ForceStakingEpochTransition { domain_id , } , [184u8 , 202u8 , 89u8 , 24u8 , 167u8 , 153u8 , 48u8 , 72u8 , 11u8 , 224u8 , 33u8 , 97u8 , 108u8 , 226u8 , 116u8 , 217u8 , 200u8 , 194u8 , 120u8 , 205u8 , 204u8 , 112u8 , 11u8 , 159u8 , 176u8 , 194u8 , 155u8 , 134u8 , 39u8 , 194u8 , 37u8 , 164u8 ,]) } # [doc = "Update permissioned action allowed by storage by Sudo."] pub fn set_permissioned_action_allowed_by (& self , permissioned_action_allowed_by : types :: set_permissioned_action_allowed_by :: PermissionedActionAllowedBy ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetPermissionedActionAllowedBy > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "set_permissioned_action_allowed_by" , types :: SetPermissionedActionAllowedBy { permissioned_action_allowed_by , } , [4u8 , 116u8 , 82u8 , 14u8 , 132u8 , 224u8 , 39u8 , 88u8 , 251u8 , 219u8 , 140u8 , 65u8 , 184u8 , 80u8 , 128u8 , 136u8 , 166u8 , 222u8 , 8u8 , 197u8 , 12u8 , 83u8 , 123u8 , 56u8 , 143u8 , 119u8 , 195u8 , 103u8 , 211u8 , 49u8 , 93u8 , 176u8 ,]) } # [doc = "Submit a domain sudo call."] pub fn send_domain_sudo_call (& self , domain_id : types :: send_domain_sudo_call :: DomainId , call : types :: send_domain_sudo_call :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SendDomainSudoCall > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "send_domain_sudo_call" , types :: SendDomainSudoCall { domain_id , call , } , [72u8 , 43u8 , 177u8 , 131u8 , 36u8 , 163u8 , 61u8 , 244u8 , 72u8 , 209u8 , 139u8 , 224u8 , 7u8 , 220u8 , 93u8 , 114u8 , 65u8 , 89u8 , 18u8 , 144u8 , 224u8 , 65u8 , 169u8 , 100u8 , 147u8 , 179u8 , 158u8 , 214u8 , 117u8 , 80u8 , 196u8 , 165u8 ,]) } # [doc = "Freezes a given domain."] # [doc = "A frozen domain does not accept new bundles but accepts fraud proofs."] pub fn freeze_domain (& self , domain_id : types :: freeze_domain :: DomainId ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: FreezeDomain > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "freeze_domain" , types :: FreezeDomain { domain_id , } , [6u8 , 98u8 , 127u8 , 249u8 , 231u8 , 60u8 , 112u8 , 63u8 , 31u8 , 218u8 , 159u8 , 123u8 , 60u8 , 242u8 , 168u8 , 36u8 , 66u8 , 43u8 , 82u8 , 22u8 , 244u8 , 138u8 , 252u8 , 14u8 , 139u8 , 160u8 , 60u8 , 162u8 , 83u8 , 237u8 , 152u8 , 4u8 ,]) } # [doc = "Unfreezes a frozen domain."] pub fn unfreeze_domain (& self , domain_id : types :: unfreeze_domain :: DomainId ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UnfreezeDomain > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "unfreeze_domain" , types :: UnfreezeDomain { domain_id , } , [4u8 , 223u8 , 122u8 , 103u8 , 98u8 , 58u8 , 79u8 , 201u8 , 1u8 , 232u8 , 55u8 , 79u8 , 203u8 , 117u8 , 221u8 , 243u8 , 35u8 , 127u8 , 180u8 , 46u8 , 178u8 , 142u8 , 146u8 , 74u8 , 41u8 , 230u8 , 174u8 , 90u8 , 255u8 , 33u8 , 117u8 , 190u8 ,]) } # [doc = "Prunes a given execution receipt for given frozen domain."] # [doc = "This call assumes the execution receipt to be bad and implicitly trusts Sudo"] # [doc = "to do the necessary validation of the ER before dispatching this call."] pub fn prune_domain_execution_receipt (& self , domain_id : types :: prune_domain_execution_receipt :: DomainId , bad_receipt_hash : types :: prune_domain_execution_receipt :: BadReceiptHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: PruneDomainExecutionReceipt > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "prune_domain_execution_receipt" , types :: PruneDomainExecutionReceipt { domain_id , bad_receipt_hash , } , [70u8 , 180u8 , 47u8 , 34u8 , 216u8 , 107u8 , 230u8 , 17u8 , 44u8 , 137u8 , 53u8 , 169u8 , 152u8 , 141u8 , 221u8 , 83u8 , 18u8 , 46u8 , 169u8 , 56u8 , 173u8 , 61u8 , 218u8 , 100u8 , 181u8 , 52u8 , 130u8 , 213u8 , 172u8 , 9u8 , 198u8 , 163u8 ,]) } # [doc = "Transfer funds from treasury to given account"] pub fn transfer_treasury_funds (& self , account_id : types :: transfer_treasury_funds :: AccountId , balance : types :: transfer_treasury_funds :: Balance ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: TransferTreasuryFunds > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "transfer_treasury_funds" , types :: TransferTreasuryFunds { account_id , balance , } , [168u8 , 244u8 , 215u8 , 163u8 , 184u8 , 234u8 , 156u8 , 18u8 , 242u8 , 108u8 , 133u8 , 120u8 , 74u8 , 61u8 , 167u8 , 158u8 , 90u8 , 106u8 , 107u8 , 89u8 , 96u8 , 157u8 , 248u8 , 188u8 , 158u8 , 34u8 , 191u8 , 250u8 , 223u8 , 32u8 , 93u8 , 29u8 ,]) } pub fn submit_receipt (& self , singleton_receipt : types :: submit_receipt :: SingletonReceipt ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SubmitReceipt > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "submit_receipt" , types :: SubmitReceipt { singleton_receipt , } , [76u8 , 249u8 , 130u8 , 173u8 , 170u8 , 75u8 , 176u8 , 159u8 , 12u8 , 135u8 , 0u8 , 52u8 , 171u8 , 158u8 , 211u8 , 35u8 , 144u8 , 36u8 , 132u8 , 158u8 , 14u8 , 65u8 , 197u8 , 55u8 , 145u8 , 95u8 , 93u8 , 189u8 , 224u8 , 164u8 , 40u8 , 18u8 ,]) } # [doc = "Submit an EVM domain \"set contract creation allowed by\" call as domain owner or root."] pub fn send_evm_domain_set_contract_creation_allowed_by_call (& self , domain_id : types :: send_evm_domain_set_contract_creation_allowed_by_call :: DomainId , contract_creation_allowed_by : types :: send_evm_domain_set_contract_creation_allowed_by_call :: ContractCreationAllowedBy ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SendEvmDomainSetContractCreationAllowedByCall > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Domains" , "send_evm_domain_set_contract_creation_allowed_by_call" , types :: SendEvmDomainSetContractCreationAllowedByCall { domain_id , contract_creation_allowed_by , } , [50u8 , 199u8 , 66u8 , 109u8 , 29u8 , 110u8 , 6u8 , 227u8 , 142u8 , 191u8 , 123u8 , 129u8 , 90u8 , 76u8 , 76u8 , 7u8 , 145u8 , 91u8 , 144u8 , 68u8 , 150u8 , 61u8 , 177u8 , 146u8 , 67u8 , 225u8 , 120u8 , 215u8 , 159u8 , 90u8 , 117u8 , 224u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_domains :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A domain bundle was included."] pub struct BundleStored { pub domain_id : bundle_stored :: DomainId , pub bundle_hash : bundle_stored :: BundleHash , pub bundle_author : bundle_stored :: BundleAuthor , } pub mod bundle_stored { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type BundleHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type BundleAuthor = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for BundleStored { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "BundleStored" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainRuntimeCreated { pub runtime_id : domain_runtime_created :: RuntimeId , pub runtime_type : domain_runtime_created :: RuntimeType , } pub mod domain_runtime_created { use super :: runtime_types ; pub type RuntimeId = :: core :: primitive :: u32 ; pub type RuntimeType = runtime_types :: sp_domains :: RuntimeType ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DomainRuntimeCreated { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "DomainRuntimeCreated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainRuntimeUpgradeScheduled { pub runtime_id : domain_runtime_upgrade_scheduled :: RuntimeId , pub scheduled_at : domain_runtime_upgrade_scheduled :: ScheduledAt , } pub mod domain_runtime_upgrade_scheduled { use super :: runtime_types ; pub type RuntimeId = :: core :: primitive :: u32 ; pub type ScheduledAt = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DomainRuntimeUpgradeScheduled { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "DomainRuntimeUpgradeScheduled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainRuntimeUpgraded { pub runtime_id : domain_runtime_upgraded :: RuntimeId , } pub mod domain_runtime_upgraded { use super :: runtime_types ; pub type RuntimeId = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DomainRuntimeUpgraded { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "DomainRuntimeUpgraded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorRegistered { pub operator_id : operator_registered :: OperatorId , pub domain_id : operator_registered :: DomainId , } pub mod operator_registered { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OperatorRegistered { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "OperatorRegistered" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct NominatedStakedUnlocked { pub operator_id : nominated_staked_unlocked :: OperatorId , pub nominator_id : nominated_staked_unlocked :: NominatorId , pub unlocked_amount : nominated_staked_unlocked :: UnlockedAmount , } pub mod nominated_staked_unlocked { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type NominatorId = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type UnlockedAmount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NominatedStakedUnlocked { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "NominatedStakedUnlocked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StorageFeeUnlocked { pub operator_id : storage_fee_unlocked :: OperatorId , pub nominator_id : storage_fee_unlocked :: NominatorId , pub storage_fee : storage_fee_unlocked :: StorageFee , } pub mod storage_fee_unlocked { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type NominatorId = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type StorageFee = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for StorageFeeUnlocked { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "StorageFeeUnlocked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorNominated { pub operator_id : operator_nominated :: OperatorId , pub nominator_id : operator_nominated :: NominatorId , pub amount : operator_nominated :: Amount , } pub mod operator_nominated { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type NominatorId = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OperatorNominated { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "OperatorNominated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainInstantiated { pub domain_id : domain_instantiated :: DomainId , } pub mod domain_instantiated { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DomainInstantiated { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "DomainInstantiated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorSwitchedDomain { pub old_domain_id : operator_switched_domain :: OldDomainId , pub new_domain_id : operator_switched_domain :: NewDomainId , } pub mod operator_switched_domain { use super :: runtime_types ; pub type OldDomainId = runtime_types :: sp_domains :: DomainId ; pub type NewDomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OperatorSwitchedDomain { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "OperatorSwitchedDomain" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorDeregistered { pub operator_id : operator_deregistered :: OperatorId , } pub mod operator_deregistered { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OperatorDeregistered { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "OperatorDeregistered" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct NominatorUnlocked { pub operator_id : nominator_unlocked :: OperatorId , pub nominator_id : nominator_unlocked :: NominatorId , } pub mod nominator_unlocked { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type NominatorId = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NominatorUnlocked { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "NominatorUnlocked" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct WithdrewStake { pub operator_id : withdrew_stake :: OperatorId , pub nominator_id : withdrew_stake :: NominatorId , } pub mod withdrew_stake { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type NominatorId = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for WithdrewStake { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "WithdrewStake" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PreferredOperator { pub operator_id : preferred_operator :: OperatorId , pub nominator_id : preferred_operator :: NominatorId , } pub mod preferred_operator { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type NominatorId = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PreferredOperator { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "PreferredOperator" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorRewarded { pub source : operator_rewarded :: Source , pub operator_id : operator_rewarded :: OperatorId , pub reward : operator_rewarded :: Reward , } pub mod operator_rewarded { use super :: runtime_types ; pub type Source = runtime_types :: sp_domains :: OperatorRewardSource < :: core :: primitive :: u32 > ; pub type OperatorId = :: core :: primitive :: u64 ; pub type Reward = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OperatorRewarded { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "OperatorRewarded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorTaxCollected { pub operator_id : operator_tax_collected :: OperatorId , pub tax : operator_tax_collected :: Tax , } pub mod operator_tax_collected { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type Tax = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OperatorTaxCollected { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "OperatorTaxCollected" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainEpochCompleted { pub domain_id : domain_epoch_completed :: DomainId , pub completed_epoch_index : domain_epoch_completed :: CompletedEpochIndex , } pub mod domain_epoch_completed { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type CompletedEpochIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DomainEpochCompleted { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "DomainEpochCompleted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ForceDomainEpochTransition { pub domain_id : force_domain_epoch_transition :: DomainId , pub completed_epoch_index : force_domain_epoch_transition :: CompletedEpochIndex , } pub mod force_domain_epoch_transition { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type CompletedEpochIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ForceDomainEpochTransition { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "ForceDomainEpochTransition" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FraudProofProcessed { pub domain_id : fraud_proof_processed :: DomainId , pub new_head_receipt_number : fraud_proof_processed :: NewHeadReceiptNumber , } pub mod fraud_proof_processed { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type NewHeadReceiptNumber = :: core :: option :: Option < :: core :: primitive :: u32 > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for FraudProofProcessed { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "FraudProofProcessed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainOperatorAllowListUpdated { pub domain_id : domain_operator_allow_list_updated :: DomainId , } pub mod domain_operator_allow_list_updated { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DomainOperatorAllowListUpdated { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "DomainOperatorAllowListUpdated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorSlashed { pub operator_id : operator_slashed :: OperatorId , pub reason : operator_slashed :: Reason , } pub mod operator_slashed { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type Reason = runtime_types :: pallet_domains :: pallet :: SlashedReason < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OperatorSlashed { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "OperatorSlashed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StorageFeeDeposited { pub operator_id : storage_fee_deposited :: OperatorId , pub nominator_id : storage_fee_deposited :: NominatorId , pub amount : storage_fee_deposited :: Amount , } pub mod storage_fee_deposited { use super :: runtime_types ; pub type OperatorId = :: core :: primitive :: u64 ; pub type NominatorId = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for StorageFeeDeposited { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "StorageFeeDeposited" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainFrozen { pub domain_id : domain_frozen :: DomainId , } pub mod domain_frozen { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DomainFrozen { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "DomainFrozen" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainUnfrozen { pub domain_id : domain_unfrozen :: DomainId , } pub mod domain_unfrozen { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for DomainUnfrozen { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "DomainUnfrozen" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PrunedExecutionReceipt { pub domain_id : pruned_execution_receipt :: DomainId , pub new_head_receipt_number : pruned_execution_receipt :: NewHeadReceiptNumber , } pub mod pruned_execution_receipt { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type NewHeadReceiptNumber = :: core :: option :: Option < :: core :: primitive :: u32 > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PrunedExecutionReceipt { const PALLET : & 'static str = "Domains" ; const EVENT : & 'static str = "PrunedExecutionReceipt" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod successful_bundles { use super :: runtime_types ; pub type SuccessfulBundles = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod next_runtime_id { use super :: runtime_types ; pub type NextRuntimeId = :: core :: primitive :: u32 ; } pub mod next_evm_chain_id { use super :: runtime_types ; pub type NextEvmChainId = :: core :: primitive :: u64 ; } pub mod runtime_registry { use super :: runtime_types ; pub type RuntimeRegistry = runtime_types :: sp_domains :: RuntimeObject < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod scheduled_runtime_upgrades { use super :: runtime_types ; pub type ScheduledRuntimeUpgrades = runtime_types :: pallet_domains :: runtime_registry :: ScheduledRuntimeUpgrade < :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub type Param0 = :: core :: primitive :: u32 ; pub type Param1 = :: core :: primitive :: u32 ; } pub mod next_operator_id { use super :: runtime_types ; pub type NextOperatorId = :: core :: primitive :: u64 ; } pub mod operator_id_owner { use super :: runtime_types ; pub type OperatorIdOwner = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param0 = :: core :: primitive :: u64 ; } pub mod domain_staking_summary { use super :: runtime_types ; pub type DomainStakingSummary = runtime_types :: pallet_domains :: staking :: StakingSummary < :: core :: primitive :: u64 , :: core :: primitive :: u128 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod operators { use super :: runtime_types ; pub type Operators = runtime_types :: pallet_domains :: staking :: Operator < :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 > ; pub type Param0 = :: core :: primitive :: u64 ; } pub mod operator_highest_slot { use super :: runtime_types ; pub type OperatorHighestSlot = :: core :: primitive :: u64 ; pub type Param0 = :: core :: primitive :: u64 ; } pub mod operator_bundle_slot { use super :: runtime_types ; pub type OperatorBundleSlot = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > ; pub type Param0 = :: core :: primitive :: u64 ; } pub mod operator_epoch_share_price { use super :: runtime_types ; pub type OperatorEpochSharePrice = runtime_types :: pallet_domains :: staking :: SharePrice ; pub type Param0 = :: core :: primitive :: u64 ; pub type Param1 = runtime_types :: pallet_domains :: staking :: DomainEpoch ; } pub mod deposits { use super :: runtime_types ; pub type Deposits = runtime_types :: pallet_domains :: staking :: Deposit < :: core :: primitive :: u128 , :: core :: primitive :: u128 > ; pub type Param0 = :: core :: primitive :: u64 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod withdrawals { use super :: runtime_types ; pub type Withdrawals = runtime_types :: pallet_domains :: staking :: Withdrawal < :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; pub type Param0 = :: core :: primitive :: u64 ; pub type Param1 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod deposit_on_hold { use super :: runtime_types ; pub type DepositOnHold = :: core :: primitive :: u128 ; pub type Param0 = (:: core :: primitive :: u64 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) ; } pub mod pending_slashes { use super :: runtime_types ; pub type PendingSlashes = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod pending_staking_operation_count { use super :: runtime_types ; pub type PendingStakingOperationCount = :: core :: primitive :: u32 ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod next_domain_id { use super :: runtime_types ; pub type NextDomainId = runtime_types :: sp_domains :: DomainId ; } pub mod domain_registry { use super :: runtime_types ; pub type DomainRegistry = runtime_types :: pallet_domains :: domain_registry :: DomainObject < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u128 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod block_tree { use super :: runtime_types ; pub type BlockTree = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; pub type Param1 = :: core :: primitive :: u32 ; } pub mod block_tree_nodes { use super :: runtime_types ; pub type BlockTreeNodes = runtime_types :: pallet_domains :: block_tree :: BlockTreeNode < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u128 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod head_receipt_number { use super :: runtime_types ; pub type HeadReceiptNumber = :: core :: primitive :: u32 ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod new_added_head_receipt { use super :: runtime_types ; pub type NewAddedHeadReceipt = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod consensus_block_hash { use super :: runtime_types ; pub type ConsensusBlockHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; pub type Param1 = :: core :: primitive :: u32 ; } pub mod execution_inbox { use super :: runtime_types ; pub type ExecutionInbox = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: BundleDigest < :: subxt :: ext :: subxt_core :: utils :: H256 > > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; pub type Param1 = :: core :: primitive :: u32 ; pub type Param2 = :: core :: primitive :: u32 ; } pub mod inboxed_bundle_author { use super :: runtime_types ; pub type InboxedBundleAuthor = :: core :: primitive :: u64 ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod head_domain_number { use super :: runtime_types ; pub type HeadDomainNumber = :: core :: primitive :: u32 ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod last_epoch_staking_distribution { use super :: runtime_types ; pub type LastEpochStakingDistribution = runtime_types :: pallet_domains :: ElectionVerificationParams < :: core :: primitive :: u128 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod latest_confirmed_domain_execution_receipt { use super :: runtime_types ; pub type LatestConfirmedDomainExecutionReceipt = runtime_types :: sp_domains :: ExecutionReceipt < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u128 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod domain_genesis_block_execution_receipt { use super :: runtime_types ; pub type DomainGenesisBlockExecutionReceipt = runtime_types :: sp_domains :: ExecutionReceipt < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u128 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod latest_submitted_er { use super :: runtime_types ; pub type LatestSubmittedEr = :: core :: primitive :: u32 ; pub type Param0 = (runtime_types :: sp_domains :: DomainId , :: core :: primitive :: u64 ,) ; } pub mod permissioned_action_allowed_by { use super :: runtime_types ; pub type PermissionedActionAllowedBy = runtime_types :: sp_domains :: PermissionedActionAllowedBy < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } pub mod accumulated_treasury_funds { use super :: runtime_types ; pub type AccumulatedTreasuryFunds = :: core :: primitive :: u128 ; } pub mod domain_runtime_upgrade_records { use super :: runtime_types ; pub type DomainRuntimeUpgradeRecords = :: subxt :: ext :: subxt_core :: utils :: KeyedVec < :: core :: primitive :: u32 , runtime_types :: pallet_domains :: runtime_registry :: DomainRuntimeUpgradeEntry < :: subxt :: ext :: subxt_core :: utils :: H256 > > ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod domain_runtime_upgrades { use super :: runtime_types ; pub type DomainRuntimeUpgrades = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u32 > ; } pub mod domain_sudo_calls { use super :: runtime_types ; pub type DomainSudoCalls = runtime_types :: sp_domains :: DomainSudoCall ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod frozen_domains { use super :: runtime_types ; pub type FrozenDomains = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: DomainId > ; } pub mod evm_domain_contract_creation_allowed_by_calls { use super :: runtime_types ; pub type EvmDomainContractCreationAllowedByCalls = runtime_types :: sp_domains :: EvmDomainContractCreationAllowedByCall ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod skip_balance_checks { use super :: runtime_types ; pub type SkipBalanceChecks = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: DomainId > ; } pub mod domain_chain_rewards { use super :: runtime_types ; pub type DomainChainRewards = :: core :: primitive :: u128 ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod invalid_bundle_authors { use super :: runtime_types ; pub type InvalidBundleAuthors = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod deregistered_operators { use super :: runtime_types ; pub type DeregisteredOperators = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod allowed_default_share_price_epoch { use super :: runtime_types ; pub type AllowedDefaultSharePriceEpoch = runtime_types :: pallet_domains :: staking :: DomainEpoch ; } pub mod domain_tx_range_state { use super :: runtime_types ; pub type DomainTxRangeState = runtime_types :: pallet_domains :: pallet :: TxRangeState ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod block_inherent_extrinsic_data { use super :: runtime_types ; pub type BlockInherentExtrinsicData = runtime_types :: sp_domains_fraud_proof :: storage_proof :: InherentExtrinsicData ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Bundles submitted successfully in current block."] pub fn successful_bundles_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: successful_bundles :: SuccessfulBundles , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "SuccessfulBundles" , () , [55u8 , 113u8 , 140u8 , 124u8 , 133u8 , 1u8 , 38u8 , 238u8 , 160u8 , 153u8 , 62u8 , 136u8 , 54u8 , 243u8 , 185u8 , 99u8 , 120u8 , 166u8 , 62u8 , 169u8 , 39u8 , 12u8 , 66u8 , 148u8 , 142u8 , 68u8 , 149u8 , 135u8 , 42u8 , 180u8 , 203u8 , 203u8 ,]) } # [doc = " Bundles submitted successfully in current block."] pub fn successful_bundles (& self , _0 : types :: successful_bundles :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: successful_bundles :: Param0 > , types :: successful_bundles :: SuccessfulBundles , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "SuccessfulBundles" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [55u8 , 113u8 , 140u8 , 124u8 , 133u8 , 1u8 , 38u8 , 238u8 , 160u8 , 153u8 , 62u8 , 136u8 , 54u8 , 243u8 , 185u8 , 99u8 , 120u8 , 166u8 , 62u8 , 169u8 , 39u8 , 12u8 , 66u8 , 148u8 , 142u8 , 68u8 , 149u8 , 135u8 , 42u8 , 180u8 , 203u8 , 203u8 ,]) } # [doc = " Stores the next runtime id."] pub fn next_runtime_id (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_runtime_id :: NextRuntimeId , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "NextRuntimeId" , () , [178u8 , 75u8 , 115u8 , 46u8 , 215u8 , 251u8 , 33u8 , 182u8 , 14u8 , 186u8 , 181u8 , 160u8 , 106u8 , 45u8 , 150u8 , 153u8 , 248u8 , 204u8 , 2u8 , 181u8 , 232u8 , 126u8 , 76u8 , 156u8 , 71u8 , 142u8 , 92u8 , 122u8 , 85u8 , 36u8 , 82u8 , 125u8 ,]) } # [doc = " Stores the next evm chain id."] pub fn next_evm_chain_id (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_evm_chain_id :: NextEvmChainId , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "NextEVMChainId" , () , [224u8 , 111u8 , 118u8 , 252u8 , 119u8 , 206u8 , 144u8 , 201u8 , 151u8 , 154u8 , 114u8 , 5u8 , 35u8 , 206u8 , 200u8 , 67u8 , 97u8 , 234u8 , 129u8 , 233u8 , 174u8 , 110u8 , 225u8 , 37u8 , 236u8 , 232u8 , 123u8 , 229u8 , 105u8 , 98u8 , 48u8 , 130u8 ,]) } pub fn runtime_registry_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: runtime_registry :: RuntimeRegistry , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "RuntimeRegistry" , () , [205u8 , 184u8 , 198u8 , 113u8 , 13u8 , 148u8 , 96u8 , 12u8 , 154u8 , 55u8 , 12u8 , 143u8 , 4u8 , 203u8 , 68u8 , 244u8 , 165u8 , 207u8 , 248u8 , 239u8 , 119u8 , 92u8 , 157u8 , 34u8 , 249u8 , 181u8 , 183u8 , 43u8 , 4u8 , 119u8 , 175u8 , 63u8 ,]) } pub fn runtime_registry (& self , _0 : types :: runtime_registry :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: runtime_registry :: Param0 > , types :: runtime_registry :: RuntimeRegistry , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "RuntimeRegistry" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [205u8 , 184u8 , 198u8 , 113u8 , 13u8 , 148u8 , 96u8 , 12u8 , 154u8 , 55u8 , 12u8 , 143u8 , 4u8 , 203u8 , 68u8 , 244u8 , 165u8 , 207u8 , 248u8 , 239u8 , 119u8 , 92u8 , 157u8 , 34u8 , 249u8 , 181u8 , 183u8 , 43u8 , 4u8 , 119u8 , 175u8 , 63u8 ,]) } pub fn scheduled_runtime_upgrades_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: scheduled_runtime_upgrades :: ScheduledRuntimeUpgrades , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ScheduledRuntimeUpgrades" , () , [171u8 , 69u8 , 61u8 , 89u8 , 235u8 , 243u8 , 123u8 , 242u8 , 171u8 , 237u8 , 66u8 , 171u8 , 221u8 , 36u8 , 20u8 , 139u8 , 97u8 , 25u8 , 64u8 , 101u8 , 3u8 , 46u8 , 203u8 , 17u8 , 93u8 , 92u8 , 79u8 , 68u8 , 86u8 , 35u8 , 17u8 , 63u8 ,]) } pub fn scheduled_runtime_upgrades_iter1 (& self , _0 : types :: scheduled_runtime_upgrades :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: scheduled_runtime_upgrades :: Param0 > , types :: scheduled_runtime_upgrades :: ScheduledRuntimeUpgrades , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ScheduledRuntimeUpgrades" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [171u8 , 69u8 , 61u8 , 89u8 , 235u8 , 243u8 , 123u8 , 242u8 , 171u8 , 237u8 , 66u8 , 171u8 , 221u8 , 36u8 , 20u8 , 139u8 , 97u8 , 25u8 , 64u8 , 101u8 , 3u8 , 46u8 , 203u8 , 17u8 , 93u8 , 92u8 , 79u8 , 68u8 , 86u8 , 35u8 , 17u8 , 63u8 ,]) } pub fn scheduled_runtime_upgrades (& self , _0 : types :: scheduled_runtime_upgrades :: Param0 , _1 : types :: scheduled_runtime_upgrades :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: scheduled_runtime_upgrades :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: scheduled_runtime_upgrades :: Param1 > ,) , types :: scheduled_runtime_upgrades :: ScheduledRuntimeUpgrades , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ScheduledRuntimeUpgrades" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [171u8 , 69u8 , 61u8 , 89u8 , 235u8 , 243u8 , 123u8 , 242u8 , 171u8 , 237u8 , 66u8 , 171u8 , 221u8 , 36u8 , 20u8 , 139u8 , 97u8 , 25u8 , 64u8 , 101u8 , 3u8 , 46u8 , 203u8 , 17u8 , 93u8 , 92u8 , 79u8 , 68u8 , 86u8 , 35u8 , 17u8 , 63u8 ,]) } pub fn next_operator_id (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_operator_id :: NextOperatorId , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "NextOperatorId" , () , [205u8 , 248u8 , 122u8 , 172u8 , 110u8 , 215u8 , 173u8 , 30u8 , 136u8 , 53u8 , 122u8 , 39u8 , 116u8 , 50u8 , 129u8 , 153u8 , 77u8 , 17u8 , 224u8 , 115u8 , 102u8 , 72u8 , 238u8 , 93u8 , 50u8 , 58u8 , 112u8 , 154u8 , 61u8 , 16u8 , 156u8 , 118u8 ,]) } pub fn operator_id_owner_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: operator_id_owner :: OperatorIdOwner , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorIdOwner" , () , [177u8 , 211u8 , 38u8 , 200u8 , 157u8 , 120u8 , 252u8 , 184u8 , 177u8 , 153u8 , 95u8 , 65u8 , 201u8 , 168u8 , 137u8 , 138u8 , 208u8 , 240u8 , 133u8 , 142u8 , 28u8 , 240u8 , 49u8 , 229u8 , 55u8 , 52u8 , 112u8 , 170u8 , 151u8 , 243u8 , 135u8 , 77u8 ,]) } pub fn operator_id_owner (& self , _0 : types :: operator_id_owner :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: operator_id_owner :: Param0 > , types :: operator_id_owner :: OperatorIdOwner , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorIdOwner" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [177u8 , 211u8 , 38u8 , 200u8 , 157u8 , 120u8 , 252u8 , 184u8 , 177u8 , 153u8 , 95u8 , 65u8 , 201u8 , 168u8 , 137u8 , 138u8 , 208u8 , 240u8 , 133u8 , 142u8 , 28u8 , 240u8 , 49u8 , 229u8 , 55u8 , 52u8 , 112u8 , 170u8 , 151u8 , 243u8 , 135u8 , 77u8 ,]) } pub fn domain_staking_summary_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_staking_summary :: DomainStakingSummary , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainStakingSummary" , () , [114u8 , 206u8 , 148u8 , 10u8 , 217u8 , 196u8 , 210u8 , 145u8 , 234u8 , 117u8 , 226u8 , 217u8 , 63u8 , 128u8 , 94u8 , 103u8 , 61u8 , 38u8 , 29u8 , 188u8 , 111u8 , 77u8 , 178u8 , 58u8 , 71u8 , 107u8 , 31u8 , 67u8 , 156u8 , 64u8 , 182u8 , 53u8 ,]) } pub fn domain_staking_summary (& self , _0 : types :: domain_staking_summary :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_staking_summary :: Param0 > , types :: domain_staking_summary :: DomainStakingSummary , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainStakingSummary" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [114u8 , 206u8 , 148u8 , 10u8 , 217u8 , 196u8 , 210u8 , 145u8 , 234u8 , 117u8 , 226u8 , 217u8 , 63u8 , 128u8 , 94u8 , 103u8 , 61u8 , 38u8 , 29u8 , 188u8 , 111u8 , 77u8 , 178u8 , 58u8 , 71u8 , 107u8 , 31u8 , 67u8 , 156u8 , 64u8 , 182u8 , 53u8 ,]) } # [doc = " List of all registered operators and their configuration."] pub fn operators_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: operators :: Operators , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "Operators" , () , [93u8 , 90u8 , 155u8 , 31u8 , 144u8 , 105u8 , 48u8 , 57u8 , 102u8 , 198u8 , 150u8 , 146u8 , 142u8 , 167u8 , 165u8 , 126u8 , 126u8 , 148u8 , 249u8 , 106u8 , 187u8 , 104u8 , 167u8 , 213u8 , 117u8 , 38u8 , 170u8 , 135u8 , 249u8 , 54u8 , 123u8 , 45u8 ,]) } # [doc = " List of all registered operators and their configuration."] pub fn operators (& self , _0 : types :: operators :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: operators :: Param0 > , types :: operators :: Operators , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "Operators" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [93u8 , 90u8 , 155u8 , 31u8 , 144u8 , 105u8 , 48u8 , 57u8 , 102u8 , 198u8 , 150u8 , 146u8 , 142u8 , 167u8 , 165u8 , 126u8 , 126u8 , 148u8 , 249u8 , 106u8 , 187u8 , 104u8 , 167u8 , 213u8 , 117u8 , 38u8 , 170u8 , 135u8 , 249u8 , 54u8 , 123u8 , 45u8 ,]) } # [doc = " The highest slot of the bundle submitted by an operator"] pub fn operator_highest_slot_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: operator_highest_slot :: OperatorHighestSlot , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorHighestSlot" , () , [97u8 , 12u8 , 106u8 , 77u8 , 70u8 , 161u8 , 110u8 , 101u8 , 118u8 , 174u8 , 222u8 , 217u8 , 197u8 , 238u8 , 232u8 , 102u8 , 34u8 , 41u8 , 237u8 , 232u8 , 17u8 , 11u8 , 239u8 , 202u8 , 147u8 , 78u8 , 201u8 , 48u8 , 155u8 , 106u8 , 12u8 , 54u8 ,]) } # [doc = " The highest slot of the bundle submitted by an operator"] pub fn operator_highest_slot (& self , _0 : types :: operator_highest_slot :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: operator_highest_slot :: Param0 > , types :: operator_highest_slot :: OperatorHighestSlot , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorHighestSlot" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [97u8 , 12u8 , 106u8 , 77u8 , 70u8 , 161u8 , 110u8 , 101u8 , 118u8 , 174u8 , 222u8 , 217u8 , 197u8 , 238u8 , 232u8 , 102u8 , 34u8 , 41u8 , 237u8 , 232u8 , 17u8 , 11u8 , 239u8 , 202u8 , 147u8 , 78u8 , 201u8 , 48u8 , 155u8 , 106u8 , 12u8 , 54u8 ,]) } # [doc = " The set of slot of the bundle submitted by an operator in the current block, cleared at the"] # [doc = " next block initialization"] pub fn operator_bundle_slot_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: operator_bundle_slot :: OperatorBundleSlot , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorBundleSlot" , () , [100u8 , 120u8 , 43u8 , 206u8 , 20u8 , 244u8 , 10u8 , 243u8 , 234u8 , 169u8 , 64u8 , 249u8 , 121u8 , 160u8 , 147u8 , 19u8 , 186u8 , 68u8 , 87u8 , 226u8 , 229u8 , 86u8 , 156u8 , 248u8 , 98u8 , 191u8 , 69u8 , 90u8 , 115u8 , 63u8 , 129u8 , 252u8 ,]) } # [doc = " The set of slot of the bundle submitted by an operator in the current block, cleared at the"] # [doc = " next block initialization"] pub fn operator_bundle_slot (& self , _0 : types :: operator_bundle_slot :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: operator_bundle_slot :: Param0 > , types :: operator_bundle_slot :: OperatorBundleSlot , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorBundleSlot" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [100u8 , 120u8 , 43u8 , 206u8 , 20u8 , 244u8 , 10u8 , 243u8 , 234u8 , 169u8 , 64u8 , 249u8 , 121u8 , 160u8 , 147u8 , 19u8 , 186u8 , 68u8 , 87u8 , 226u8 , 229u8 , 86u8 , 156u8 , 248u8 , 98u8 , 191u8 , 69u8 , 90u8 , 115u8 , 63u8 , 129u8 , 252u8 ,]) } # [doc = " Share price for the operator pool at the end of Domain epoch."] pub fn operator_epoch_share_price_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: operator_epoch_share_price :: OperatorEpochSharePrice , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorEpochSharePrice" , () , [60u8 , 110u8 , 175u8 , 153u8 , 190u8 , 30u8 , 141u8 , 90u8 , 238u8 , 156u8 , 6u8 , 122u8 , 241u8 , 152u8 , 3u8 , 147u8 , 130u8 , 193u8 , 142u8 , 176u8 , 38u8 , 50u8 , 237u8 , 195u8 , 176u8 , 68u8 , 151u8 , 244u8 , 76u8 , 18u8 , 11u8 , 223u8 ,]) } # [doc = " Share price for the operator pool at the end of Domain epoch."] pub fn operator_epoch_share_price_iter1 (& self , _0 : types :: operator_epoch_share_price :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: operator_epoch_share_price :: Param0 > , types :: operator_epoch_share_price :: OperatorEpochSharePrice , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorEpochSharePrice" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [60u8 , 110u8 , 175u8 , 153u8 , 190u8 , 30u8 , 141u8 , 90u8 , 238u8 , 156u8 , 6u8 , 122u8 , 241u8 , 152u8 , 3u8 , 147u8 , 130u8 , 193u8 , 142u8 , 176u8 , 38u8 , 50u8 , 237u8 , 195u8 , 176u8 , 68u8 , 151u8 , 244u8 , 76u8 , 18u8 , 11u8 , 223u8 ,]) } # [doc = " Share price for the operator pool at the end of Domain epoch."] pub fn operator_epoch_share_price (& self , _0 : types :: operator_epoch_share_price :: Param0 , _1 : types :: operator_epoch_share_price :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: operator_epoch_share_price :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: operator_epoch_share_price :: Param1 > ,) , types :: operator_epoch_share_price :: OperatorEpochSharePrice , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "OperatorEpochSharePrice" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [60u8 , 110u8 , 175u8 , 153u8 , 190u8 , 30u8 , 141u8 , 90u8 , 238u8 , 156u8 , 6u8 , 122u8 , 241u8 , 152u8 , 3u8 , 147u8 , 130u8 , 193u8 , 142u8 , 176u8 , 38u8 , 50u8 , 237u8 , 195u8 , 176u8 , 68u8 , 151u8 , 244u8 , 76u8 , 18u8 , 11u8 , 223u8 ,]) } # [doc = " List of all deposits for given Operator."] pub fn deposits_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: deposits :: Deposits , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "Deposits" , () , [67u8 , 6u8 , 217u8 , 194u8 , 122u8 , 245u8 , 215u8 , 145u8 , 211u8 , 46u8 , 6u8 , 103u8 , 227u8 , 28u8 , 2u8 , 22u8 , 137u8 , 150u8 , 193u8 , 31u8 , 112u8 , 194u8 , 187u8 , 164u8 , 151u8 , 198u8 , 244u8 , 53u8 , 162u8 , 178u8 , 122u8 , 217u8 ,]) } # [doc = " List of all deposits for given Operator."] pub fn deposits_iter1 (& self , _0 : types :: deposits :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deposits :: Param0 > , types :: deposits :: Deposits , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "Deposits" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [67u8 , 6u8 , 217u8 , 194u8 , 122u8 , 245u8 , 215u8 , 145u8 , 211u8 , 46u8 , 6u8 , 103u8 , 227u8 , 28u8 , 2u8 , 22u8 , 137u8 , 150u8 , 193u8 , 31u8 , 112u8 , 194u8 , 187u8 , 164u8 , 151u8 , 198u8 , 244u8 , 53u8 , 162u8 , 178u8 , 122u8 , 217u8 ,]) } # [doc = " List of all deposits for given Operator."] pub fn deposits (& self , _0 : types :: deposits :: Param0 , _1 : types :: deposits :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deposits :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deposits :: Param1 > ,) , types :: deposits :: Deposits , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "Deposits" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [67u8 , 6u8 , 217u8 , 194u8 , 122u8 , 245u8 , 215u8 , 145u8 , 211u8 , 46u8 , 6u8 , 103u8 , 227u8 , 28u8 , 2u8 , 22u8 , 137u8 , 150u8 , 193u8 , 31u8 , 112u8 , 194u8 , 187u8 , 164u8 , 151u8 , 198u8 , 244u8 , 53u8 , 162u8 , 178u8 , 122u8 , 217u8 ,]) } # [doc = " List of all withdrawals for a given operator."] pub fn withdrawals_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: withdrawals :: Withdrawals , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "Withdrawals" , () , [97u8 , 185u8 , 246u8 , 91u8 , 72u8 , 170u8 , 146u8 , 174u8 , 189u8 , 41u8 , 72u8 , 103u8 , 188u8 , 150u8 , 27u8 , 179u8 , 167u8 , 248u8 , 200u8 , 15u8 , 196u8 , 133u8 , 54u8 , 79u8 , 75u8 , 5u8 , 223u8 , 242u8 , 202u8 , 174u8 , 16u8 , 172u8 ,]) } # [doc = " List of all withdrawals for a given operator."] pub fn withdrawals_iter1 (& self , _0 : types :: withdrawals :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: withdrawals :: Param0 > , types :: withdrawals :: Withdrawals , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "Withdrawals" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [97u8 , 185u8 , 246u8 , 91u8 , 72u8 , 170u8 , 146u8 , 174u8 , 189u8 , 41u8 , 72u8 , 103u8 , 188u8 , 150u8 , 27u8 , 179u8 , 167u8 , 248u8 , 200u8 , 15u8 , 196u8 , 133u8 , 54u8 , 79u8 , 75u8 , 5u8 , 223u8 , 242u8 , 202u8 , 174u8 , 16u8 , 172u8 ,]) } # [doc = " List of all withdrawals for a given operator."] pub fn withdrawals (& self , _0 : types :: withdrawals :: Param0 , _1 : types :: withdrawals :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: withdrawals :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: withdrawals :: Param1 > ,) , types :: withdrawals :: Withdrawals , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "Withdrawals" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [97u8 , 185u8 , 246u8 , 91u8 , 72u8 , 170u8 , 146u8 , 174u8 , 189u8 , 41u8 , 72u8 , 103u8 , 188u8 , 150u8 , 27u8 , 179u8 , 167u8 , 248u8 , 200u8 , 15u8 , 196u8 , 133u8 , 54u8 , 79u8 , 75u8 , 5u8 , 223u8 , 242u8 , 202u8 , 174u8 , 16u8 , 172u8 ,]) } # [doc = " The amount of balance the nominator hold for a given operator"] pub fn deposit_on_hold_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: deposit_on_hold :: DepositOnHold , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DepositOnHold" , () , [247u8 , 128u8 , 27u8 , 218u8 , 84u8 , 206u8 , 125u8 , 2u8 , 144u8 , 84u8 , 9u8 , 142u8 , 59u8 , 15u8 , 108u8 , 253u8 , 203u8 , 116u8 , 191u8 , 29u8 , 76u8 , 171u8 , 249u8 , 167u8 , 99u8 , 56u8 , 253u8 , 174u8 , 212u8 , 37u8 , 24u8 , 75u8 ,]) } # [doc = " The amount of balance the nominator hold for a given operator"] pub fn deposit_on_hold (& self , _0 : types :: deposit_on_hold :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deposit_on_hold :: Param0 > , types :: deposit_on_hold :: DepositOnHold , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DepositOnHold" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [247u8 , 128u8 , 27u8 , 218u8 , 84u8 , 206u8 , 125u8 , 2u8 , 144u8 , 84u8 , 9u8 , 142u8 , 59u8 , 15u8 , 108u8 , 253u8 , 203u8 , 116u8 , 191u8 , 29u8 , 76u8 , 171u8 , 249u8 , 167u8 , 99u8 , 56u8 , 253u8 , 174u8 , 212u8 , 37u8 , 24u8 , 75u8 ,]) } # [doc = " A list operators who were slashed during the current epoch associated with the domain."] # [doc = " When the epoch for a given domain is complete, operator total stake is moved to treasury and"] # [doc = " then deleted."] pub fn pending_slashes_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pending_slashes :: PendingSlashes , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "PendingSlashes" , () , [12u8 , 253u8 , 111u8 , 122u8 , 228u8 , 82u8 , 28u8 , 232u8 , 169u8 , 59u8 , 61u8 , 53u8 , 178u8 , 64u8 , 116u8 , 202u8 , 244u8 , 244u8 , 66u8 , 241u8 , 144u8 , 129u8 , 22u8 , 79u8 , 20u8 , 70u8 , 148u8 , 157u8 , 69u8 , 104u8 , 246u8 , 241u8 ,]) } # [doc = " A list operators who were slashed during the current epoch associated with the domain."] # [doc = " When the epoch for a given domain is complete, operator total stake is moved to treasury and"] # [doc = " then deleted."] pub fn pending_slashes (& self , _0 : types :: pending_slashes :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: pending_slashes :: Param0 > , types :: pending_slashes :: PendingSlashes , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "PendingSlashes" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [12u8 , 253u8 , 111u8 , 122u8 , 228u8 , 82u8 , 28u8 , 232u8 , 169u8 , 59u8 , 61u8 , 53u8 , 178u8 , 64u8 , 116u8 , 202u8 , 244u8 , 244u8 , 66u8 , 241u8 , 144u8 , 129u8 , 22u8 , 79u8 , 20u8 , 70u8 , 148u8 , 157u8 , 69u8 , 104u8 , 246u8 , 241u8 ,]) } # [doc = " The pending staking operation count of the current epoch, it should not larger than"] # [doc = " `MaxPendingStakingOperation` and will be resetted to 0 upon epoch transition."] pub fn pending_staking_operation_count_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: pending_staking_operation_count :: PendingStakingOperationCount , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "PendingStakingOperationCount" , () , [242u8 , 22u8 , 154u8 , 55u8 , 94u8 , 241u8 , 244u8 , 197u8 , 97u8 , 95u8 , 79u8 , 15u8 , 3u8 , 246u8 , 60u8 , 251u8 , 187u8 , 166u8 , 208u8 , 249u8 , 118u8 , 40u8 , 47u8 , 183u8 , 15u8 , 175u8 , 254u8 , 72u8 , 90u8 , 26u8 , 243u8 , 42u8 ,]) } # [doc = " The pending staking operation count of the current epoch, it should not larger than"] # [doc = " `MaxPendingStakingOperation` and will be resetted to 0 upon epoch transition."] pub fn pending_staking_operation_count (& self , _0 : types :: pending_staking_operation_count :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: pending_staking_operation_count :: Param0 > , types :: pending_staking_operation_count :: PendingStakingOperationCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "PendingStakingOperationCount" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [242u8 , 22u8 , 154u8 , 55u8 , 94u8 , 241u8 , 244u8 , 197u8 , 97u8 , 95u8 , 79u8 , 15u8 , 3u8 , 246u8 , 60u8 , 251u8 , 187u8 , 166u8 , 208u8 , 249u8 , 118u8 , 40u8 , 47u8 , 183u8 , 15u8 , 175u8 , 254u8 , 72u8 , 90u8 , 26u8 , 243u8 , 42u8 ,]) } # [doc = " Stores the next domain id."] pub fn next_domain_id (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_domain_id :: NextDomainId , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "NextDomainId" , () , [123u8 , 160u8 , 66u8 , 12u8 , 52u8 , 231u8 , 153u8 , 139u8 , 218u8 , 137u8 , 48u8 , 5u8 , 34u8 , 74u8 , 205u8 , 212u8 , 86u8 , 192u8 , 177u8 , 226u8 , 37u8 , 90u8 , 235u8 , 221u8 , 244u8 , 137u8 , 250u8 , 104u8 , 99u8 , 31u8 , 244u8 , 64u8 ,]) } # [doc = " The domain registry"] pub fn domain_registry_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_registry :: DomainRegistry , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainRegistry" , () , [19u8 , 51u8 , 142u8 , 43u8 , 122u8 , 6u8 , 57u8 , 61u8 , 239u8 , 13u8 , 129u8 , 77u8 , 157u8 , 195u8 , 71u8 , 245u8 , 217u8 , 112u8 , 135u8 , 250u8 , 38u8 , 20u8 , 176u8 , 9u8 , 68u8 , 250u8 , 38u8 , 175u8 , 254u8 , 233u8 , 197u8 , 159u8 ,]) } # [doc = " The domain registry"] pub fn domain_registry (& self , _0 : types :: domain_registry :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_registry :: Param0 > , types :: domain_registry :: DomainRegistry , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainRegistry" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [19u8 , 51u8 , 142u8 , 43u8 , 122u8 , 6u8 , 57u8 , 61u8 , 239u8 , 13u8 , 129u8 , 77u8 , 157u8 , 195u8 , 71u8 , 245u8 , 217u8 , 112u8 , 135u8 , 250u8 , 38u8 , 20u8 , 176u8 , 9u8 , 68u8 , 250u8 , 38u8 , 175u8 , 254u8 , 233u8 , 197u8 , 159u8 ,]) } # [doc = " The domain block tree, map (`domain_id`, `domain_block_number`) to the hash of ER,"] # [doc = " which can be used get the block tree node in `BlockTreeNodes`"] pub fn block_tree_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_tree :: BlockTree , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "BlockTree" , () , [13u8 , 101u8 , 129u8 , 121u8 , 75u8 , 174u8 , 61u8 , 223u8 , 197u8 , 182u8 , 223u8 , 242u8 , 165u8 , 237u8 , 202u8 , 102u8 , 82u8 , 79u8 , 68u8 , 38u8 , 168u8 , 46u8 , 180u8 , 226u8 , 113u8 , 141u8 , 235u8 , 158u8 , 237u8 , 119u8 , 96u8 , 80u8 ,]) } # [doc = " The domain block tree, map (`domain_id`, `domain_block_number`) to the hash of ER,"] # [doc = " which can be used get the block tree node in `BlockTreeNodes`"] pub fn block_tree_iter1 (& self , _0 : types :: block_tree :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_tree :: Param0 > , types :: block_tree :: BlockTree , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "BlockTree" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [13u8 , 101u8 , 129u8 , 121u8 , 75u8 , 174u8 , 61u8 , 223u8 , 197u8 , 182u8 , 223u8 , 242u8 , 165u8 , 237u8 , 202u8 , 102u8 , 82u8 , 79u8 , 68u8 , 38u8 , 168u8 , 46u8 , 180u8 , 226u8 , 113u8 , 141u8 , 235u8 , 158u8 , 237u8 , 119u8 , 96u8 , 80u8 ,]) } # [doc = " The domain block tree, map (`domain_id`, `domain_block_number`) to the hash of ER,"] # [doc = " which can be used get the block tree node in `BlockTreeNodes`"] pub fn block_tree (& self , _0 : types :: block_tree :: Param0 , _1 : types :: block_tree :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_tree :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_tree :: Param1 > ,) , types :: block_tree :: BlockTree , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "BlockTree" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [13u8 , 101u8 , 129u8 , 121u8 , 75u8 , 174u8 , 61u8 , 223u8 , 197u8 , 182u8 , 223u8 , 242u8 , 165u8 , 237u8 , 202u8 , 102u8 , 82u8 , 79u8 , 68u8 , 38u8 , 168u8 , 46u8 , 180u8 , 226u8 , 113u8 , 141u8 , 235u8 , 158u8 , 237u8 , 119u8 , 96u8 , 80u8 ,]) } # [doc = " Mapping of block tree node hash to the node, each node represent a domain block"] pub fn block_tree_nodes_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_tree_nodes :: BlockTreeNodes , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "BlockTreeNodes" , () , [218u8 , 59u8 , 130u8 , 49u8 , 83u8 , 135u8 , 247u8 , 167u8 , 100u8 , 229u8 , 209u8 , 2u8 , 255u8 , 238u8 , 129u8 , 74u8 , 96u8 , 111u8 , 243u8 , 86u8 , 157u8 , 72u8 , 214u8 , 137u8 , 235u8 , 118u8 , 252u8 , 21u8 , 99u8 , 207u8 , 170u8 , 58u8 ,]) } # [doc = " Mapping of block tree node hash to the node, each node represent a domain block"] pub fn block_tree_nodes (& self , _0 : types :: block_tree_nodes :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: block_tree_nodes :: Param0 > , types :: block_tree_nodes :: BlockTreeNodes , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "BlockTreeNodes" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [218u8 , 59u8 , 130u8 , 49u8 , 83u8 , 135u8 , 247u8 , 167u8 , 100u8 , 229u8 , 209u8 , 2u8 , 255u8 , 238u8 , 129u8 , 74u8 , 96u8 , 111u8 , 243u8 , 86u8 , 157u8 , 72u8 , 214u8 , 137u8 , 235u8 , 118u8 , 252u8 , 21u8 , 99u8 , 207u8 , 170u8 , 58u8 ,]) } # [doc = " The head receipt number of each domain"] pub fn head_receipt_number_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: head_receipt_number :: HeadReceiptNumber , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "HeadReceiptNumber" , () , [15u8 , 253u8 , 236u8 , 2u8 , 79u8 , 54u8 , 121u8 , 80u8 , 20u8 , 102u8 , 116u8 , 143u8 , 137u8 , 58u8 , 97u8 , 103u8 , 118u8 , 194u8 , 136u8 , 159u8 , 117u8 , 195u8 , 143u8 , 115u8 , 214u8 , 184u8 , 190u8 , 59u8 , 152u8 , 86u8 , 161u8 , 15u8 ,]) } # [doc = " The head receipt number of each domain"] pub fn head_receipt_number (& self , _0 : types :: head_receipt_number :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: head_receipt_number :: Param0 > , types :: head_receipt_number :: HeadReceiptNumber , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "HeadReceiptNumber" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [15u8 , 253u8 , 236u8 , 2u8 , 79u8 , 54u8 , 121u8 , 80u8 , 20u8 , 102u8 , 116u8 , 143u8 , 137u8 , 58u8 , 97u8 , 103u8 , 118u8 , 194u8 , 136u8 , 159u8 , 117u8 , 195u8 , 143u8 , 115u8 , 214u8 , 184u8 , 190u8 , 59u8 , 152u8 , 86u8 , 161u8 , 15u8 ,]) } # [doc = " The hash of the new head receipt added in the current consensus block"] # [doc = ""] # [doc = " Temporary storage only exist during block execution"] pub fn new_added_head_receipt_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: new_added_head_receipt :: NewAddedHeadReceipt , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "NewAddedHeadReceipt" , () , [28u8 , 239u8 , 201u8 , 170u8 , 3u8 , 123u8 , 176u8 , 85u8 , 135u8 , 133u8 , 2u8 , 41u8 , 202u8 , 209u8 , 28u8 , 50u8 , 48u8 , 206u8 , 175u8 , 248u8 , 13u8 , 112u8 , 109u8 , 94u8 , 111u8 , 69u8 , 105u8 , 216u8 , 67u8 , 64u8 , 222u8 , 94u8 ,]) } # [doc = " The hash of the new head receipt added in the current consensus block"] # [doc = ""] # [doc = " Temporary storage only exist during block execution"] pub fn new_added_head_receipt (& self , _0 : types :: new_added_head_receipt :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: new_added_head_receipt :: Param0 > , types :: new_added_head_receipt :: NewAddedHeadReceipt , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "NewAddedHeadReceipt" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [28u8 , 239u8 , 201u8 , 170u8 , 3u8 , 123u8 , 176u8 , 85u8 , 135u8 , 133u8 , 2u8 , 41u8 , 202u8 , 209u8 , 28u8 , 50u8 , 48u8 , 206u8 , 175u8 , 248u8 , 13u8 , 112u8 , 109u8 , 94u8 , 111u8 , 69u8 , 105u8 , 216u8 , 67u8 , 64u8 , 222u8 , 94u8 ,]) } # [doc = " Map of consensus block hashes."] # [doc = ""] # [doc = " The consensus block hash used to verify ER, only store the consensus block hash for a domain"] # [doc = " if that consensus block contains bundle of the domain, the hash will be pruned when the ER"] # [doc = " that point to the consensus block is pruned."] pub fn consensus_block_hash_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: consensus_block_hash :: ConsensusBlockHash , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ConsensusBlockHash" , () , [173u8 , 109u8 , 126u8 , 211u8 , 31u8 , 184u8 , 21u8 , 234u8 , 38u8 , 34u8 , 151u8 , 127u8 , 40u8 , 251u8 , 197u8 , 26u8 , 236u8 , 98u8 , 134u8 , 65u8 , 196u8 , 109u8 , 140u8 , 211u8 , 102u8 , 223u8 , 246u8 , 185u8 , 156u8 , 63u8 , 198u8 , 122u8 ,]) } # [doc = " Map of consensus block hashes."] # [doc = ""] # [doc = " The consensus block hash used to verify ER, only store the consensus block hash for a domain"] # [doc = " if that consensus block contains bundle of the domain, the hash will be pruned when the ER"] # [doc = " that point to the consensus block is pruned."] pub fn consensus_block_hash_iter1 (& self , _0 : types :: consensus_block_hash :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: consensus_block_hash :: Param0 > , types :: consensus_block_hash :: ConsensusBlockHash , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ConsensusBlockHash" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [173u8 , 109u8 , 126u8 , 211u8 , 31u8 , 184u8 , 21u8 , 234u8 , 38u8 , 34u8 , 151u8 , 127u8 , 40u8 , 251u8 , 197u8 , 26u8 , 236u8 , 98u8 , 134u8 , 65u8 , 196u8 , 109u8 , 140u8 , 211u8 , 102u8 , 223u8 , 246u8 , 185u8 , 156u8 , 63u8 , 198u8 , 122u8 ,]) } # [doc = " Map of consensus block hashes."] # [doc = ""] # [doc = " The consensus block hash used to verify ER, only store the consensus block hash for a domain"] # [doc = " if that consensus block contains bundle of the domain, the hash will be pruned when the ER"] # [doc = " that point to the consensus block is pruned."] pub fn consensus_block_hash (& self , _0 : types :: consensus_block_hash :: Param0 , _1 : types :: consensus_block_hash :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: consensus_block_hash :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: consensus_block_hash :: Param1 > ,) , types :: consensus_block_hash :: ConsensusBlockHash , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ConsensusBlockHash" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [173u8 , 109u8 , 126u8 , 211u8 , 31u8 , 184u8 , 21u8 , 234u8 , 38u8 , 34u8 , 151u8 , 127u8 , 40u8 , 251u8 , 197u8 , 26u8 , 236u8 , 98u8 , 134u8 , 65u8 , 196u8 , 109u8 , 140u8 , 211u8 , 102u8 , 223u8 , 246u8 , 185u8 , 156u8 , 63u8 , 198u8 , 122u8 ,]) } # [doc = " A set of `BundleDigest` from all bundles that successfully submitted to the consensus block,"] # [doc = " these bundles will be used to construct the domain block and `ExecutionInbox` is used to:"] # [doc = ""] # [doc = " 1. Ensure subsequent ERs of that domain block include all pre-validated extrinsic bundles"] # [doc = " 2. Index the `InboxedBundleAuthor` and pruned its value when the corresponding `ExecutionInbox` is pruned"] pub fn execution_inbox_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: execution_inbox :: ExecutionInbox , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ExecutionInbox" , () , [13u8 , 133u8 , 160u8 , 222u8 , 192u8 , 248u8 , 149u8 , 201u8 , 30u8 , 12u8 , 132u8 , 110u8 , 108u8 , 216u8 , 219u8 , 149u8 , 194u8 , 40u8 , 124u8 , 160u8 , 170u8 , 253u8 , 239u8 , 115u8 , 205u8 , 135u8 , 9u8 , 135u8 , 209u8 , 27u8 , 9u8 , 92u8 ,]) } # [doc = " A set of `BundleDigest` from all bundles that successfully submitted to the consensus block,"] # [doc = " these bundles will be used to construct the domain block and `ExecutionInbox` is used to:"] # [doc = ""] # [doc = " 1. Ensure subsequent ERs of that domain block include all pre-validated extrinsic bundles"] # [doc = " 2. Index the `InboxedBundleAuthor` and pruned its value when the corresponding `ExecutionInbox` is pruned"] pub fn execution_inbox_iter1 (& self , _0 : types :: execution_inbox :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: execution_inbox :: Param0 > , types :: execution_inbox :: ExecutionInbox , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ExecutionInbox" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [13u8 , 133u8 , 160u8 , 222u8 , 192u8 , 248u8 , 149u8 , 201u8 , 30u8 , 12u8 , 132u8 , 110u8 , 108u8 , 216u8 , 219u8 , 149u8 , 194u8 , 40u8 , 124u8 , 160u8 , 170u8 , 253u8 , 239u8 , 115u8 , 205u8 , 135u8 , 9u8 , 135u8 , 209u8 , 27u8 , 9u8 , 92u8 ,]) } # [doc = " A set of `BundleDigest` from all bundles that successfully submitted to the consensus block,"] # [doc = " these bundles will be used to construct the domain block and `ExecutionInbox` is used to:"] # [doc = ""] # [doc = " 1. Ensure subsequent ERs of that domain block include all pre-validated extrinsic bundles"] # [doc = " 2. Index the `InboxedBundleAuthor` and pruned its value when the corresponding `ExecutionInbox` is pruned"] pub fn execution_inbox_iter2 (& self , _0 : types :: execution_inbox :: Param0 , _1 : types :: execution_inbox :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: execution_inbox :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: execution_inbox :: Param1 > ,) , types :: execution_inbox :: ExecutionInbox , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ExecutionInbox" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [13u8 , 133u8 , 160u8 , 222u8 , 192u8 , 248u8 , 149u8 , 201u8 , 30u8 , 12u8 , 132u8 , 110u8 , 108u8 , 216u8 , 219u8 , 149u8 , 194u8 , 40u8 , 124u8 , 160u8 , 170u8 , 253u8 , 239u8 , 115u8 , 205u8 , 135u8 , 9u8 , 135u8 , 209u8 , 27u8 , 9u8 , 92u8 ,]) } # [doc = " A set of `BundleDigest` from all bundles that successfully submitted to the consensus block,"] # [doc = " these bundles will be used to construct the domain block and `ExecutionInbox` is used to:"] # [doc = ""] # [doc = " 1. Ensure subsequent ERs of that domain block include all pre-validated extrinsic bundles"] # [doc = " 2. Index the `InboxedBundleAuthor` and pruned its value when the corresponding `ExecutionInbox` is pruned"] pub fn execution_inbox (& self , _0 : types :: execution_inbox :: Param0 , _1 : types :: execution_inbox :: Param1 , _2 : types :: execution_inbox :: Param2 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: execution_inbox :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: execution_inbox :: Param1 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: execution_inbox :: Param2 > ,) , types :: execution_inbox :: ExecutionInbox , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "ExecutionInbox" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_2) ,) , [13u8 , 133u8 , 160u8 , 222u8 , 192u8 , 248u8 , 149u8 , 201u8 , 30u8 , 12u8 , 132u8 , 110u8 , 108u8 , 216u8 , 219u8 , 149u8 , 194u8 , 40u8 , 124u8 , 160u8 , 170u8 , 253u8 , 239u8 , 115u8 , 205u8 , 135u8 , 9u8 , 135u8 , 209u8 , 27u8 , 9u8 , 92u8 ,]) } # [doc = " A mapping of `bundle_header_hash` -> `bundle_author` for all the successfully submitted bundles of"] # [doc = " the last `BlockTreePruningDepth` domain blocks. Used to verify the invalid bundle fraud proof and"] # [doc = " slash malicious operator who have submitted invalid bundle."] pub fn inboxed_bundle_author_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inboxed_bundle_author :: InboxedBundleAuthor , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "InboxedBundleAuthor" , () , [29u8 , 220u8 , 235u8 , 236u8 , 105u8 , 243u8 , 19u8 , 12u8 , 247u8 , 11u8 , 86u8 , 164u8 , 130u8 , 185u8 , 117u8 , 192u8 , 231u8 , 155u8 , 50u8 , 252u8 , 15u8 , 131u8 , 96u8 , 160u8 , 54u8 , 103u8 , 104u8 , 23u8 , 210u8 , 27u8 , 188u8 , 214u8 ,]) } # [doc = " A mapping of `bundle_header_hash` -> `bundle_author` for all the successfully submitted bundles of"] # [doc = " the last `BlockTreePruningDepth` domain blocks. Used to verify the invalid bundle fraud proof and"] # [doc = " slash malicious operator who have submitted invalid bundle."] pub fn inboxed_bundle_author (& self , _0 : types :: inboxed_bundle_author :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: inboxed_bundle_author :: Param0 > , types :: inboxed_bundle_author :: InboxedBundleAuthor , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "InboxedBundleAuthor" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [29u8 , 220u8 , 235u8 , 236u8 , 105u8 , 243u8 , 19u8 , 12u8 , 247u8 , 11u8 , 86u8 , 164u8 , 130u8 , 185u8 , 117u8 , 192u8 , 231u8 , 155u8 , 50u8 , 252u8 , 15u8 , 131u8 , 96u8 , 160u8 , 54u8 , 103u8 , 104u8 , 23u8 , 210u8 , 27u8 , 188u8 , 214u8 ,]) } # [doc = " The block number of the best domain block, increase by one when the first bundle of the domain is"] # [doc = " successfully submitted to current consensus block, which mean a new domain block with this block"] # [doc = " number will be produce. Used as a pointer in `ExecutionInbox` to identify the current under building"] # [doc = " domain block, also used as a mapping of consensus block number to domain block number."] pub fn head_domain_number_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: head_domain_number :: HeadDomainNumber , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "HeadDomainNumber" , () , [253u8 , 97u8 , 131u8 , 117u8 , 188u8 , 61u8 , 88u8 , 97u8 , 249u8 , 33u8 , 185u8 , 107u8 , 251u8 , 235u8 , 81u8 , 122u8 , 124u8 , 173u8 , 141u8 , 228u8 , 237u8 , 244u8 , 5u8 , 135u8 , 80u8 , 134u8 , 76u8 , 209u8 , 56u8 , 170u8 , 10u8 , 147u8 ,]) } # [doc = " The block number of the best domain block, increase by one when the first bundle of the domain is"] # [doc = " successfully submitted to current consensus block, which mean a new domain block with this block"] # [doc = " number will be produce. Used as a pointer in `ExecutionInbox` to identify the current under building"] # [doc = " domain block, also used as a mapping of consensus block number to domain block number."] pub fn head_domain_number (& self , _0 : types :: head_domain_number :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: head_domain_number :: Param0 > , types :: head_domain_number :: HeadDomainNumber , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "HeadDomainNumber" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [253u8 , 97u8 , 131u8 , 117u8 , 188u8 , 61u8 , 88u8 , 97u8 , 249u8 , 33u8 , 185u8 , 107u8 , 251u8 , 235u8 , 81u8 , 122u8 , 124u8 , 173u8 , 141u8 , 228u8 , 237u8 , 244u8 , 5u8 , 135u8 , 80u8 , 134u8 , 76u8 , 209u8 , 56u8 , 170u8 , 10u8 , 147u8 ,]) } # [doc = " A temporary storage to hold any previous epoch details for a given domain"] # [doc = " if the epoch transitioned in this block so that all the submitted bundles"] # [doc = " within this block are verified."] # [doc = " TODO: The storage is cleared on block finalization that means this storage is already cleared when"] # [doc = " verifying the `submit_bundle` extrinsic and not used at all"] pub fn last_epoch_staking_distribution_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_epoch_staking_distribution :: LastEpochStakingDistribution , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "LastEpochStakingDistribution" , () , [175u8 , 94u8 , 154u8 , 190u8 , 227u8 , 84u8 , 24u8 , 210u8 , 23u8 , 98u8 , 242u8 , 212u8 , 219u8 , 94u8 , 158u8 , 56u8 , 234u8 , 80u8 , 115u8 , 83u8 , 249u8 , 31u8 , 213u8 , 122u8 , 107u8 , 234u8 , 34u8 , 13u8 , 56u8 , 52u8 , 203u8 , 217u8 ,]) } # [doc = " A temporary storage to hold any previous epoch details for a given domain"] # [doc = " if the epoch transitioned in this block so that all the submitted bundles"] # [doc = " within this block are verified."] # [doc = " TODO: The storage is cleared on block finalization that means this storage is already cleared when"] # [doc = " verifying the `submit_bundle` extrinsic and not used at all"] pub fn last_epoch_staking_distribution (& self , _0 : types :: last_epoch_staking_distribution :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: last_epoch_staking_distribution :: Param0 > , types :: last_epoch_staking_distribution :: LastEpochStakingDistribution , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "LastEpochStakingDistribution" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [175u8 , 94u8 , 154u8 , 190u8 , 227u8 , 84u8 , 24u8 , 210u8 , 23u8 , 98u8 , 242u8 , 212u8 , 219u8 , 94u8 , 158u8 , 56u8 , 234u8 , 80u8 , 115u8 , 83u8 , 249u8 , 31u8 , 213u8 , 122u8 , 107u8 , 234u8 , 34u8 , 13u8 , 56u8 , 52u8 , 203u8 , 217u8 ,]) } # [doc = " Storage to hold all the domain's latest confirmed block."] pub fn latest_confirmed_domain_execution_receipt_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: latest_confirmed_domain_execution_receipt :: LatestConfirmedDomainExecutionReceipt , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "LatestConfirmedDomainExecutionReceipt" , () , [83u8 , 13u8 , 121u8 , 11u8 , 230u8 , 132u8 , 102u8 , 238u8 , 137u8 , 9u8 , 63u8 , 64u8 , 223u8 , 157u8 , 190u8 , 163u8 , 114u8 , 32u8 , 83u8 , 117u8 , 140u8 , 173u8 , 227u8 , 22u8 , 74u8 , 212u8 , 39u8 , 180u8 , 224u8 , 145u8 , 65u8 , 46u8 ,]) } # [doc = " Storage to hold all the domain's latest confirmed block."] pub fn latest_confirmed_domain_execution_receipt (& self , _0 : types :: latest_confirmed_domain_execution_receipt :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: latest_confirmed_domain_execution_receipt :: Param0 > , types :: latest_confirmed_domain_execution_receipt :: LatestConfirmedDomainExecutionReceipt , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "LatestConfirmedDomainExecutionReceipt" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [83u8 , 13u8 , 121u8 , 11u8 , 230u8 , 132u8 , 102u8 , 238u8 , 137u8 , 9u8 , 63u8 , 64u8 , 223u8 , 157u8 , 190u8 , 163u8 , 114u8 , 32u8 , 83u8 , 117u8 , 140u8 , 173u8 , 227u8 , 22u8 , 74u8 , 212u8 , 39u8 , 180u8 , 224u8 , 145u8 , 65u8 , 46u8 ,]) } # [doc = " Storage to hold all the domain's genesis execution receipt."] pub fn domain_genesis_block_execution_receipt_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_genesis_block_execution_receipt :: DomainGenesisBlockExecutionReceipt , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainGenesisBlockExecutionReceipt" , () , [187u8 , 22u8 , 241u8 , 207u8 , 116u8 , 131u8 , 101u8 , 143u8 , 246u8 , 217u8 , 184u8 , 42u8 , 206u8 , 151u8 , 112u8 , 55u8 , 52u8 , 75u8 , 22u8 , 149u8 , 67u8 , 19u8 , 148u8 , 91u8 , 165u8 , 80u8 , 70u8 , 221u8 , 191u8 , 165u8 , 57u8 , 105u8 ,]) } # [doc = " Storage to hold all the domain's genesis execution receipt."] pub fn domain_genesis_block_execution_receipt (& self , _0 : types :: domain_genesis_block_execution_receipt :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_genesis_block_execution_receipt :: Param0 > , types :: domain_genesis_block_execution_receipt :: DomainGenesisBlockExecutionReceipt , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainGenesisBlockExecutionReceipt" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [187u8 , 22u8 , 241u8 , 207u8 , 116u8 , 131u8 , 101u8 , 143u8 , 246u8 , 217u8 , 184u8 , 42u8 , 206u8 , 151u8 , 112u8 , 55u8 , 52u8 , 75u8 , 22u8 , 149u8 , 67u8 , 19u8 , 148u8 , 91u8 , 165u8 , 80u8 , 70u8 , 221u8 , 191u8 , 165u8 , 57u8 , 105u8 ,]) } # [doc = " The latest ER submitted by the operator for a given domain. It is used to determine if the operator"] # [doc = " has submitted bad ER and is pending to slash."] # [doc = ""] # [doc = " The storage item of a given `(domain_id, operator_id)` will be pruned after either:"] # [doc = " - All the ERs submitted by the operator for this domain are confirmed and pruned"] # [doc = " - All the bad ERs submitted by the operator for this domain are pruned and the operator is slashed"] pub fn latest_submitted_er_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: latest_submitted_er :: LatestSubmittedEr , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "LatestSubmittedER" , () , [158u8 , 167u8 , 52u8 , 39u8 , 2u8 , 33u8 , 77u8 , 173u8 , 112u8 , 125u8 , 0u8 , 232u8 , 128u8 , 198u8 , 76u8 , 224u8 , 225u8 , 115u8 , 197u8 , 237u8 , 7u8 , 108u8 , 67u8 , 253u8 , 196u8 , 86u8 , 46u8 , 179u8 , 118u8 , 176u8 , 225u8 , 33u8 ,]) } # [doc = " The latest ER submitted by the operator for a given domain. It is used to determine if the operator"] # [doc = " has submitted bad ER and is pending to slash."] # [doc = ""] # [doc = " The storage item of a given `(domain_id, operator_id)` will be pruned after either:"] # [doc = " - All the ERs submitted by the operator for this domain are confirmed and pruned"] # [doc = " - All the bad ERs submitted by the operator for this domain are pruned and the operator is slashed"] pub fn latest_submitted_er (& self , _0 : types :: latest_submitted_er :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: latest_submitted_er :: Param0 > , types :: latest_submitted_er :: LatestSubmittedEr , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "LatestSubmittedER" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [158u8 , 167u8 , 52u8 , 39u8 , 2u8 , 33u8 , 77u8 , 173u8 , 112u8 , 125u8 , 0u8 , 232u8 , 128u8 , 198u8 , 76u8 , 224u8 , 225u8 , 115u8 , 197u8 , 237u8 , 7u8 , 108u8 , 67u8 , 253u8 , 196u8 , 86u8 , 46u8 , 179u8 , 118u8 , 176u8 , 225u8 , 33u8 ,]) } # [doc = " Storage for PermissionedActions for domain instantiation and other permissioned calls."] pub fn permissioned_action_allowed_by (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: permissioned_action_allowed_by :: PermissionedActionAllowedBy , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "PermissionedActionAllowedBy" , () , [52u8 , 155u8 , 229u8 , 228u8 , 221u8 , 194u8 , 64u8 , 161u8 , 225u8 , 70u8 , 96u8 , 178u8 , 136u8 , 236u8 , 24u8 , 102u8 , 219u8 , 216u8 , 252u8 , 61u8 , 239u8 , 126u8 , 75u8 , 96u8 , 253u8 , 101u8 , 3u8 , 122u8 , 67u8 , 97u8 , 48u8 , 124u8 ,]) } # [doc = " Accumulate treasury funds temporarily until the funds are above Existential deposit."] # [doc = " We do this to ensure minting small amounts into treasury would not fail."] pub fn accumulated_treasury_funds (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: accumulated_treasury_funds :: AccumulatedTreasuryFunds , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "AccumulatedTreasuryFunds" , () , [194u8 , 135u8 , 43u8 , 206u8 , 31u8 , 225u8 , 120u8 , 211u8 , 145u8 , 31u8 , 63u8 , 97u8 , 33u8 , 145u8 , 201u8 , 168u8 , 180u8 , 21u8 , 26u8 , 90u8 , 111u8 , 100u8 , 17u8 , 240u8 , 197u8 , 210u8 , 9u8 , 166u8 , 4u8 , 173u8 , 51u8 , 141u8 ,]) } # [doc = " Storage used to keep track of which consensus block each domain runtime upgrade happens in."] pub fn domain_runtime_upgrade_records_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_runtime_upgrade_records :: DomainRuntimeUpgradeRecords , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainRuntimeUpgradeRecords" , () , [78u8 , 173u8 , 43u8 , 178u8 , 120u8 , 145u8 , 139u8 , 4u8 , 249u8 , 30u8 , 214u8 , 119u8 , 197u8 , 161u8 , 81u8 , 118u8 , 137u8 , 121u8 , 100u8 , 19u8 , 126u8 , 104u8 , 89u8 , 116u8 , 67u8 , 67u8 , 10u8 , 234u8 , 46u8 , 32u8 , 197u8 , 243u8 ,]) } # [doc = " Storage used to keep track of which consensus block each domain runtime upgrade happens in."] pub fn domain_runtime_upgrade_records (& self , _0 : types :: domain_runtime_upgrade_records :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_runtime_upgrade_records :: Param0 > , types :: domain_runtime_upgrade_records :: DomainRuntimeUpgradeRecords , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainRuntimeUpgradeRecords" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [78u8 , 173u8 , 43u8 , 178u8 , 120u8 , 145u8 , 139u8 , 4u8 , 249u8 , 30u8 , 214u8 , 119u8 , 197u8 , 161u8 , 81u8 , 118u8 , 137u8 , 121u8 , 100u8 , 19u8 , 126u8 , 104u8 , 89u8 , 116u8 , 67u8 , 67u8 , 10u8 , 234u8 , 46u8 , 32u8 , 197u8 , 243u8 ,]) } # [doc = " Temporary storage to keep track of domain runtime upgrades which happened in the parent"] # [doc = " block. Cleared in the current block's initialization."] pub fn domain_runtime_upgrades (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_runtime_upgrades :: DomainRuntimeUpgrades , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainRuntimeUpgrades" , () , [86u8 , 151u8 , 35u8 , 109u8 , 30u8 , 220u8 , 125u8 , 245u8 , 31u8 , 152u8 , 171u8 , 253u8 , 193u8 , 82u8 , 2u8 , 155u8 , 247u8 , 44u8 , 199u8 , 93u8 , 191u8 , 204u8 , 51u8 , 85u8 , 182u8 , 16u8 , 188u8 , 193u8 , 127u8 , 5u8 , 194u8 , 164u8 ,]) } # [doc = " Temporary storage to hold the sudo calls meant for domains."] # [doc = ""] # [doc = " Storage is cleared when there are any successful bundles in the next block."] # [doc = " Only one sudo call is allowed per domain per consensus block."] pub fn domain_sudo_calls_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_sudo_calls :: DomainSudoCalls , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainSudoCalls" , () , [83u8 , 100u8 , 42u8 , 36u8 , 61u8 , 51u8 , 253u8 , 190u8 , 208u8 , 230u8 , 234u8 , 123u8 , 19u8 , 164u8 , 111u8 , 166u8 , 35u8 , 240u8 , 201u8 , 99u8 , 129u8 , 75u8 , 66u8 , 165u8 , 42u8 , 194u8 , 29u8 , 147u8 , 157u8 , 148u8 , 30u8 , 64u8 ,]) } # [doc = " Temporary storage to hold the sudo calls meant for domains."] # [doc = ""] # [doc = " Storage is cleared when there are any successful bundles in the next block."] # [doc = " Only one sudo call is allowed per domain per consensus block."] pub fn domain_sudo_calls (& self , _0 : types :: domain_sudo_calls :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_sudo_calls :: Param0 > , types :: domain_sudo_calls :: DomainSudoCalls , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainSudoCalls" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [83u8 , 100u8 , 42u8 , 36u8 , 61u8 , 51u8 , 253u8 , 190u8 , 208u8 , 230u8 , 234u8 , 123u8 , 19u8 , 164u8 , 111u8 , 166u8 , 35u8 , 240u8 , 201u8 , 99u8 , 129u8 , 75u8 , 66u8 , 165u8 , 42u8 , 194u8 , 29u8 , 147u8 , 157u8 , 148u8 , 30u8 , 64u8 ,]) } # [doc = " Storage that hold a list of all frozen domains."] # [doc = ""] # [doc = " A frozen domain does not accept the bundles but does accept a fraud proof."] pub fn frozen_domains (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: frozen_domains :: FrozenDomains , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "FrozenDomains" , () , [85u8 , 212u8 , 4u8 , 198u8 , 152u8 , 130u8 , 70u8 , 97u8 , 223u8 , 246u8 , 188u8 , 154u8 , 176u8 , 22u8 , 251u8 , 161u8 , 178u8 , 175u8 , 73u8 , 102u8 , 117u8 , 39u8 , 244u8 , 10u8 , 166u8 , 37u8 , 132u8 , 243u8 , 185u8 , 132u8 , 94u8 , 202u8 ,]) } # [doc = " Temporary storage to hold the \"set contract creation allowed by\" calls meant for EVM Domains."] # [doc = ""] # [doc = " Storage is cleared when there are any successful bundles in the next block."] # [doc = " Only one of these calls is allowed per domain per consensus block."] pub fn evm_domain_contract_creation_allowed_by_calls_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: evm_domain_contract_creation_allowed_by_calls :: EvmDomainContractCreationAllowedByCalls , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "EvmDomainContractCreationAllowedByCalls" , () , [143u8 , 178u8 , 193u8 , 232u8 , 213u8 , 151u8 , 172u8 , 58u8 , 198u8 , 51u8 , 162u8 , 70u8 , 249u8 , 11u8 , 200u8 , 218u8 , 42u8 , 17u8 , 196u8 , 129u8 , 7u8 , 104u8 , 177u8 , 50u8 , 132u8 , 79u8 , 198u8 , 151u8 , 179u8 , 33u8 , 99u8 , 214u8 ,]) } # [doc = " Temporary storage to hold the \"set contract creation allowed by\" calls meant for EVM Domains."] # [doc = ""] # [doc = " Storage is cleared when there are any successful bundles in the next block."] # [doc = " Only one of these calls is allowed per domain per consensus block."] pub fn evm_domain_contract_creation_allowed_by_calls (& self , _0 : types :: evm_domain_contract_creation_allowed_by_calls :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: evm_domain_contract_creation_allowed_by_calls :: Param0 > , types :: evm_domain_contract_creation_allowed_by_calls :: EvmDomainContractCreationAllowedByCalls , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "EvmDomainContractCreationAllowedByCalls" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [143u8 , 178u8 , 193u8 , 232u8 , 213u8 , 151u8 , 172u8 , 58u8 , 198u8 , 51u8 , 162u8 , 70u8 , 249u8 , 11u8 , 200u8 , 218u8 , 42u8 , 17u8 , 196u8 , 129u8 , 7u8 , 104u8 , 177u8 , 50u8 , 132u8 , 79u8 , 198u8 , 151u8 , 179u8 , 33u8 , 99u8 , 214u8 ,]) } # [doc = " TODO: remove once https://github.com/autonomys/subspace/issues/3466 is resolved"] # [doc = " Storage that hold a list of all domains for which balance checks are ignored."] pub fn skip_balance_checks (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: skip_balance_checks :: SkipBalanceChecks , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "SkipBalanceChecks" , () , [146u8 , 73u8 , 225u8 , 98u8 , 243u8 , 94u8 , 66u8 , 100u8 , 169u8 , 235u8 , 81u8 , 23u8 , 77u8 , 231u8 , 137u8 , 101u8 , 235u8 , 208u8 , 52u8 , 83u8 , 155u8 , 221u8 , 119u8 , 160u8 , 196u8 , 62u8 , 192u8 , 177u8 , 252u8 , 199u8 , 145u8 , 18u8 ,]) } # [doc = " Storage for chain rewards specific to each domain."] # [doc = " These rewards to equally distributed to active operators during epoch migration."] pub fn domain_chain_rewards_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_chain_rewards :: DomainChainRewards , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainChainRewards" , () , [215u8 , 55u8 , 66u8 , 194u8 , 21u8 , 35u8 , 172u8 , 150u8 , 231u8 , 223u8 , 232u8 , 21u8 , 109u8 , 177u8 , 63u8 , 93u8 , 6u8 , 252u8 , 193u8 , 225u8 , 56u8 , 72u8 , 181u8 , 127u8 , 158u8 , 155u8 , 127u8 , 143u8 , 9u8 , 103u8 , 45u8 , 42u8 ,]) } # [doc = " Storage for chain rewards specific to each domain."] # [doc = " These rewards to equally distributed to active operators during epoch migration."] pub fn domain_chain_rewards (& self , _0 : types :: domain_chain_rewards :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_chain_rewards :: Param0 > , types :: domain_chain_rewards :: DomainChainRewards , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainChainRewards" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [215u8 , 55u8 , 66u8 , 194u8 , 21u8 , 35u8 , 172u8 , 150u8 , 231u8 , 223u8 , 232u8 , 21u8 , 109u8 , 177u8 , 63u8 , 93u8 , 6u8 , 252u8 , 193u8 , 225u8 , 56u8 , 72u8 , 181u8 , 127u8 , 158u8 , 155u8 , 127u8 , 143u8 , 9u8 , 103u8 , 45u8 , 42u8 ,]) } # [doc = " Storage for operators who are marked as invalid bundle authors in the current epoch."] # [doc = " Will be cleared once epoch is transitioned."] pub fn invalid_bundle_authors_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: invalid_bundle_authors :: InvalidBundleAuthors , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "InvalidBundleAuthors" , () , [31u8 , 114u8 , 218u8 , 162u8 , 99u8 , 245u8 , 186u8 , 48u8 , 6u8 , 38u8 , 127u8 , 218u8 , 222u8 , 166u8 , 119u8 , 179u8 , 72u8 , 215u8 , 107u8 , 185u8 , 222u8 , 199u8 , 28u8 , 3u8 , 39u8 , 234u8 , 48u8 , 207u8 , 71u8 , 161u8 , 36u8 , 48u8 ,]) } # [doc = " Storage for operators who are marked as invalid bundle authors in the current epoch."] # [doc = " Will be cleared once epoch is transitioned."] pub fn invalid_bundle_authors (& self , _0 : types :: invalid_bundle_authors :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: invalid_bundle_authors :: Param0 > , types :: invalid_bundle_authors :: InvalidBundleAuthors , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "InvalidBundleAuthors" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [31u8 , 114u8 , 218u8 , 162u8 , 99u8 , 245u8 , 186u8 , 48u8 , 6u8 , 38u8 , 127u8 , 218u8 , 222u8 , 166u8 , 119u8 , 179u8 , 72u8 , 215u8 , 107u8 , 185u8 , 222u8 , 199u8 , 28u8 , 3u8 , 39u8 , 234u8 , 48u8 , 207u8 , 71u8 , 161u8 , 36u8 , 48u8 ,]) } # [doc = " Storage for operators who de-registered in the current epoch."] # [doc = " Will be cleared once epoch is transitioned."] pub fn deregistered_operators_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: deregistered_operators :: DeregisteredOperators , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DeregisteredOperators" , () , [108u8 , 254u8 , 177u8 , 25u8 , 103u8 , 164u8 , 208u8 , 200u8 , 95u8 , 149u8 , 125u8 , 60u8 , 4u8 , 220u8 , 197u8 , 231u8 , 45u8 , 229u8 , 50u8 , 134u8 , 13u8 , 68u8 , 254u8 , 74u8 , 99u8 , 17u8 , 32u8 , 44u8 , 200u8 , 90u8 , 47u8 , 229u8 ,]) } # [doc = " Storage for operators who de-registered in the current epoch."] # [doc = " Will be cleared once epoch is transitioned."] pub fn deregistered_operators (& self , _0 : types :: deregistered_operators :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deregistered_operators :: Param0 > , types :: deregistered_operators :: DeregisteredOperators , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DeregisteredOperators" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [108u8 , 254u8 , 177u8 , 25u8 , 103u8 , 164u8 , 208u8 , 200u8 , 95u8 , 149u8 , 125u8 , 60u8 , 4u8 , 220u8 , 197u8 , 231u8 , 45u8 , 229u8 , 50u8 , 134u8 , 13u8 , 68u8 , 254u8 , 74u8 , 99u8 , 17u8 , 32u8 , 44u8 , 200u8 , 90u8 , 47u8 , 229u8 ,]) } # [doc = " Storage that hold a domain epoch, for epoch that happen before it, the share price may"] # [doc = " be missing due to https://github.com/autonomys/subspace/pull/3661, in this case, we"] # [doc = " use the current share price as the default."] pub fn allowed_default_share_price_epoch (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: allowed_default_share_price_epoch :: AllowedDefaultSharePriceEpoch , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "AllowedDefaultSharePriceEpoch" , () , [40u8 , 211u8 , 53u8 , 168u8 , 21u8 , 249u8 , 170u8 , 77u8 , 226u8 , 195u8 , 164u8 , 178u8 , 83u8 , 15u8 , 103u8 , 85u8 , 171u8 , 112u8 , 200u8 , 82u8 , 231u8 , 50u8 , 70u8 , 116u8 , 183u8 , 120u8 , 161u8 , 232u8 , 161u8 , 23u8 , 4u8 , 48u8 ,]) } pub fn domain_tx_range_state_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_tx_range_state :: DomainTxRangeState , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainTxRangeState" , () , [219u8 , 201u8 , 236u8 , 105u8 , 14u8 , 31u8 , 156u8 , 225u8 , 127u8 , 64u8 , 65u8 , 80u8 , 186u8 , 163u8 , 103u8 , 108u8 , 179u8 , 174u8 , 157u8 , 82u8 , 212u8 , 74u8 , 252u8 , 248u8 , 233u8 , 119u8 , 191u8 , 167u8 , 189u8 , 125u8 , 119u8 , 145u8 ,]) } pub fn domain_tx_range_state (& self , _0 : types :: domain_tx_range_state :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_tx_range_state :: Param0 > , types :: domain_tx_range_state :: DomainTxRangeState , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "DomainTxRangeState" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [219u8 , 201u8 , 236u8 , 105u8 , 14u8 , 31u8 , 156u8 , 225u8 , 127u8 , 64u8 , 65u8 , 80u8 , 186u8 , 163u8 , 103u8 , 108u8 , 179u8 , 174u8 , 157u8 , 82u8 , 212u8 , 74u8 , 252u8 , 248u8 , 233u8 , 119u8 , 191u8 , 167u8 , 189u8 , 125u8 , 119u8 , 145u8 ,]) } # [doc = " Combined fraud proof data for the InvalidInherentExtrinsic fraud proof"] pub fn block_inherent_extrinsic_data (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: block_inherent_extrinsic_data :: BlockInherentExtrinsicData , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Domains" , "BlockInherentExtrinsicData" , () , [12u8 , 73u8 , 138u8 , 99u8 , 7u8 , 50u8 , 176u8 , 28u8 , 84u8 , 194u8 , 43u8 , 44u8 , 60u8 , 228u8 , 180u8 , 100u8 , 91u8 , 245u8 , 81u8 , 211u8 , 187u8 , 107u8 , 84u8 , 57u8 , 155u8 , 167u8 , 138u8 , 118u8 , 178u8 , 99u8 , 149u8 , 233u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Same with `pallet_subspace::Config::ConfirmationDepthK`."] pub fn confirmation_depth_k (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "ConfirmationDepthK" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The block tree pruning depth."] pub fn block_tree_pruning_depth (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "BlockTreePruningDepth" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Consensus chain slot probability."] pub fn consensus_slot_probability (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "ConsensusSlotProbability" , [152u8 , 117u8 , 175u8 , 148u8 , 25u8 , 87u8 , 115u8 , 153u8 , 72u8 , 53u8 , 134u8 , 19u8 , 201u8 , 134u8 , 181u8 , 104u8 , 87u8 , 173u8 , 243u8 , 49u8 , 245u8 , 144u8 , 230u8 , 40u8 , 29u8 , 192u8 , 234u8 , 1u8 , 180u8 , 183u8 , 251u8 , 20u8 ,]) } # [doc = " The maximum block size limit for all domain."] pub fn max_domain_block_size (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "MaxDomainBlockSize" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum block weight limit for all domain."] pub fn max_domain_block_weight (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_weights :: weight_v2 :: Weight > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "MaxDomainBlockWeight" , [149u8 , 252u8 , 129u8 , 80u8 , 169u8 , 36u8 , 79u8 , 127u8 , 240u8 , 156u8 , 56u8 , 202u8 , 219u8 , 86u8 , 5u8 , 65u8 , 245u8 , 148u8 , 138u8 , 243u8 , 210u8 , 128u8 , 234u8 , 216u8 , 240u8 , 219u8 , 123u8 , 235u8 , 21u8 , 158u8 , 237u8 , 112u8 ,]) } # [doc = " The maximum domain name length limit for all domain."] pub fn max_domain_name_length (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "MaxDomainNameLength" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The amount of fund to be locked up for the domain instance creator."] pub fn domain_instantiation_deposit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "DomainInstantiationDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Initial domain tx range value."] pub fn initial_domain_tx_range (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "InitialDomainTxRange" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Domain tx range is adjusted after every DomainTxRangeAdjustmentInterval blocks."] pub fn domain_tx_range_adjustment_interval (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u64 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "DomainTxRangeAdjustmentInterval" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Minimum operator stake required to become operator of a domain."] pub fn min_operator_stake (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "MinOperatorStake" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Minimum nominator stake required to nominate and operator."] pub fn min_nominator_stake (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "MinNominatorStake" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Minimum number of blocks after which any finalized withdrawals are released to nominators."] pub fn stake_withdrawal_locking_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "StakeWithdrawalLockingPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Domain epoch transition interval"] pub fn stake_epoch_duration (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "StakeEpochDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Treasury account."] pub fn treasury_account (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "TreasuryAccount" , [115u8 , 233u8 , 13u8 , 223u8 , 88u8 , 20u8 , 202u8 , 139u8 , 153u8 , 28u8 , 155u8 , 157u8 , 224u8 , 66u8 , 3u8 , 250u8 , 23u8 , 53u8 , 88u8 , 168u8 , 211u8 , 204u8 , 122u8 , 166u8 , 248u8 , 23u8 , 174u8 , 225u8 , 99u8 , 108u8 , 89u8 , 135u8 ,]) } # [doc = " The maximum number of pending staking operation that can perform upon epoch transition."] pub fn max_pending_staking_operation (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "MaxPendingStakingOperation" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The pallet-domains's pallet id."] pub fn pallet_id (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: frame_support :: PalletId > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "PalletId" , [56u8 , 243u8 , 53u8 , 83u8 , 154u8 , 179u8 , 170u8 , 80u8 , 133u8 , 173u8 , 61u8 , 161u8 , 47u8 , 225u8 , 146u8 , 21u8 , 50u8 , 229u8 , 248u8 , 27u8 , 104u8 , 58u8 , 129u8 , 197u8 , 102u8 , 160u8 , 168u8 , 205u8 , 154u8 , 42u8 , 217u8 , 53u8 ,]) } # [doc = " How many block a bundle should still consider as valid after produced"] pub fn bundle_longevity (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "BundleLongevity" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The max number of withdrawals per nominator that may exist at any time,"] # [doc = " once this limit is reached, the nominator need to unlock the withdrawal"] # [doc = " before requesting new withdrawal."] pub fn withdrawal_limit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Domains" , "WithdrawalLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod runtime_configs { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_runtime_configs :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Change enable domains state."] pub struct SetEnableDomains { pub enable_domains : set_enable_domains :: EnableDomains , } pub mod set_enable_domains { use super :: runtime_types ; pub type EnableDomains = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetEnableDomains { const PALLET : & 'static str = "RuntimeConfigs" ; const CALL : & 'static str = "set_enable_domains" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Enable or disable dynamic cost of storage."] pub struct SetEnableDynamicCostOfStorage { pub enable_dynamic_cost_of_storage : set_enable_dynamic_cost_of_storage :: EnableDynamicCostOfStorage , } pub mod set_enable_dynamic_cost_of_storage { use super :: runtime_types ; pub type EnableDynamicCostOfStorage = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetEnableDynamicCostOfStorage { const PALLET : & 'static str = "RuntimeConfigs" ; const CALL : & 'static str = "set_enable_dynamic_cost_of_storage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Enable or disable balance transfers for all users."] pub struct SetEnableBalanceTransfers { pub enable_balance_transfers : set_enable_balance_transfers :: EnableBalanceTransfers , } pub mod set_enable_balance_transfers { use super :: runtime_types ; pub type EnableBalanceTransfers = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetEnableBalanceTransfers { const PALLET : & 'static str = "RuntimeConfigs" ; const CALL : & 'static str = "set_enable_balance_transfers" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Change enable domains state."] pub fn set_enable_domains (& self , enable_domains : types :: set_enable_domains :: EnableDomains ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetEnableDomains > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("RuntimeConfigs" , "set_enable_domains" , types :: SetEnableDomains { enable_domains , } , [140u8 , 121u8 , 92u8 , 62u8 , 0u8 , 178u8 , 103u8 , 153u8 , 77u8 , 224u8 , 7u8 , 8u8 , 104u8 , 25u8 , 71u8 , 115u8 , 197u8 , 209u8 , 32u8 , 164u8 , 63u8 , 66u8 , 151u8 , 55u8 , 8u8 , 79u8 , 209u8 , 136u8 , 116u8 , 144u8 , 193u8 , 103u8 ,]) } # [doc = "Enable or disable dynamic cost of storage."] pub fn set_enable_dynamic_cost_of_storage (& self , enable_dynamic_cost_of_storage : types :: set_enable_dynamic_cost_of_storage :: EnableDynamicCostOfStorage ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetEnableDynamicCostOfStorage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("RuntimeConfigs" , "set_enable_dynamic_cost_of_storage" , types :: SetEnableDynamicCostOfStorage { enable_dynamic_cost_of_storage , } , [70u8 , 13u8 , 216u8 , 17u8 , 49u8 , 27u8 , 233u8 , 33u8 , 250u8 , 125u8 , 140u8 , 220u8 , 226u8 , 192u8 , 193u8 , 40u8 , 202u8 , 115u8 , 100u8 , 211u8 , 254u8 , 176u8 , 45u8 , 14u8 , 208u8 , 139u8 , 215u8 , 216u8 , 197u8 , 148u8 , 83u8 , 232u8 ,]) } # [doc = "Enable or disable balance transfers for all users."] pub fn set_enable_balance_transfers (& self , enable_balance_transfers : types :: set_enable_balance_transfers :: EnableBalanceTransfers ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetEnableBalanceTransfers > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("RuntimeConfigs" , "set_enable_balance_transfers" , types :: SetEnableBalanceTransfers { enable_balance_transfers , } , [52u8 , 40u8 , 130u8 , 30u8 , 116u8 , 226u8 , 198u8 , 50u8 , 0u8 , 95u8 , 15u8 , 104u8 , 74u8 , 250u8 , 228u8 , 199u8 , 80u8 , 180u8 , 59u8 , 87u8 , 42u8 , 35u8 , 113u8 , 19u8 , 83u8 , 230u8 , 48u8 , 201u8 , 84u8 , 95u8 , 187u8 , 106u8 ,]) } } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod enable_domains { use super :: runtime_types ; pub type EnableDomains = :: core :: primitive :: bool ; } pub mod enable_dynamic_cost_of_storage { use super :: runtime_types ; pub type EnableDynamicCostOfStorage = :: core :: primitive :: bool ; } pub mod enable_balance_transfers { use super :: runtime_types ; pub type EnableBalanceTransfers = :: core :: primitive :: bool ; } pub mod confirmation_depth_k { use super :: runtime_types ; pub type ConfirmationDepthK = :: core :: primitive :: u32 ; } pub mod council_democracy_config { use super :: runtime_types ; pub type CouncilDemocracyConfig = runtime_types :: subspace_runtime_primitives :: CouncilDemocracyConfigParams < :: core :: primitive :: u32 > ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Whether to enable calls in pallet-domains."] pub fn enable_domains (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: enable_domains :: EnableDomains , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("RuntimeConfigs" , "EnableDomains" , () , [6u8 , 168u8 , 17u8 , 119u8 , 219u8 , 222u8 , 160u8 , 254u8 , 125u8 , 115u8 , 248u8 , 154u8 , 232u8 , 127u8 , 138u8 , 185u8 , 122u8 , 246u8 , 198u8 , 150u8 , 157u8 , 207u8 , 133u8 , 84u8 , 172u8 , 221u8 , 196u8 , 112u8 , 95u8 , 89u8 , 187u8 , 152u8 ,]) } # [doc = " Whether to enable dynamic cost of storage."] pub fn enable_dynamic_cost_of_storage (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: enable_dynamic_cost_of_storage :: EnableDynamicCostOfStorage , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("RuntimeConfigs" , "EnableDynamicCostOfStorage" , () , [236u8 , 199u8 , 77u8 , 107u8 , 198u8 , 121u8 , 209u8 , 66u8 , 63u8 , 230u8 , 5u8 , 4u8 , 209u8 , 201u8 , 207u8 , 40u8 , 70u8 , 128u8 , 218u8 , 249u8 , 111u8 , 74u8 , 207u8 , 235u8 , 28u8 , 58u8 , 27u8 , 33u8 , 26u8 , 1u8 , 111u8 , 46u8 ,]) } # [doc = " Whether to enable balances transfers."] pub fn enable_balance_transfers (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: enable_balance_transfers :: EnableBalanceTransfers , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("RuntimeConfigs" , "EnableBalanceTransfers" , () , [1u8 , 47u8 , 248u8 , 71u8 , 34u8 , 183u8 , 215u8 , 29u8 , 154u8 , 191u8 , 205u8 , 58u8 , 32u8 , 69u8 , 136u8 , 82u8 , 57u8 , 234u8 , 60u8 , 28u8 , 6u8 , 179u8 , 233u8 , 110u8 , 186u8 , 38u8 , 86u8 , 82u8 , 81u8 , 134u8 , 16u8 , 213u8 ,]) } pub fn confirmation_depth_k (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: confirmation_depth_k :: ConfirmationDepthK , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("RuntimeConfigs" , "ConfirmationDepthK" , () , [58u8 , 65u8 , 241u8 , 250u8 , 125u8 , 102u8 , 30u8 , 6u8 , 245u8 , 207u8 , 1u8 , 92u8 , 69u8 , 241u8 , 15u8 , 115u8 , 23u8 , 141u8 , 223u8 , 245u8 , 157u8 , 9u8 , 200u8 , 61u8 , 193u8 , 134u8 , 119u8 , 187u8 , 190u8 , 180u8 , 97u8 , 97u8 ,]) } pub fn council_democracy_config (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: council_democracy_config :: CouncilDemocracyConfig , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("RuntimeConfigs" , "CouncilDemocracyConfig" , () , [200u8 , 48u8 , 63u8 , 106u8 , 231u8 , 214u8 , 72u8 , 179u8 , 50u8 , 104u8 , 140u8 , 115u8 , 163u8 , 72u8 , 129u8 , 67u8 , 41u8 , 177u8 , 197u8 , 164u8 , 217u8 , 95u8 , 86u8 , 146u8 , 77u8 , 116u8 , 66u8 , 148u8 , 147u8 , 37u8 , 37u8 , 13u8 ,]) } } } } pub mod mmr { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod root_hash { use super :: runtime_types ; pub type RootHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod number_of_leaves { use super :: runtime_types ; pub type NumberOfLeaves = :: core :: primitive :: u64 ; } pub mod nodes { use super :: runtime_types ; pub type Nodes = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param0 = :: core :: primitive :: u64 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Latest MMR Root hash."] pub fn root_hash (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: root_hash :: RootHash , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Mmr" , "RootHash" , () , [111u8 , 206u8 , 173u8 , 92u8 , 67u8 , 49u8 , 150u8 , 113u8 , 90u8 , 245u8 , 38u8 , 254u8 , 76u8 , 250u8 , 167u8 , 66u8 , 130u8 , 129u8 , 251u8 , 220u8 , 172u8 , 229u8 , 162u8 , 251u8 , 36u8 , 227u8 , 43u8 , 189u8 , 7u8 , 106u8 , 23u8 , 13u8 ,]) } # [doc = " Current size of the MMR (number of leaves)."] pub fn number_of_leaves (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: number_of_leaves :: NumberOfLeaves , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Mmr" , "NumberOfLeaves" , () , [123u8 , 58u8 , 149u8 , 174u8 , 85u8 , 45u8 , 20u8 , 115u8 , 241u8 , 0u8 , 51u8 , 174u8 , 234u8 , 60u8 , 230u8 , 59u8 , 237u8 , 144u8 , 170u8 , 32u8 , 4u8 , 0u8 , 34u8 , 163u8 , 238u8 , 205u8 , 93u8 , 208u8 , 53u8 , 38u8 , 141u8 , 195u8 ,]) } # [doc = " Hashes of the nodes in the MMR."] # [doc = ""] # [doc = " Note this collection only contains MMR peaks, the inner nodes (and leaves)"] # [doc = " are pruned and only stored in the Offchain DB."] pub fn nodes_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: nodes :: Nodes , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Mmr" , "Nodes" , () , [27u8 , 84u8 , 41u8 , 195u8 , 146u8 , 81u8 , 211u8 , 189u8 , 63u8 , 125u8 , 173u8 , 206u8 , 69u8 , 198u8 , 202u8 , 213u8 , 89u8 , 31u8 , 89u8 , 177u8 , 76u8 , 154u8 , 249u8 , 197u8 , 133u8 , 78u8 , 142u8 , 71u8 , 183u8 , 3u8 , 132u8 , 25u8 ,]) } # [doc = " Hashes of the nodes in the MMR."] # [doc = ""] # [doc = " Note this collection only contains MMR peaks, the inner nodes (and leaves)"] # [doc = " are pruned and only stored in the Offchain DB."] pub fn nodes (& self , _0 : types :: nodes :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: nodes :: Param0 > , types :: nodes :: Nodes , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Mmr" , "Nodes" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [27u8 , 84u8 , 41u8 , 195u8 , 146u8 , 81u8 , 211u8 , 189u8 , 63u8 , 125u8 , 173u8 , 206u8 , 69u8 , 198u8 , 202u8 , 213u8 , 89u8 , 31u8 , 89u8 , 177u8 , 76u8 , 154u8 , 249u8 , 197u8 , 133u8 , 78u8 , 142u8 , 71u8 , 183u8 , 3u8 , 132u8 , 25u8 ,]) } } } } pub mod subspace_mmr { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod mmr_root_hashes { use super :: runtime_types ; pub type MmrRootHashes = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param0 = :: core :: primitive :: u32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Map of block numbers to mmr root hashes."] pub fn mmr_root_hashes_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: mmr_root_hashes :: MmrRootHashes , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubspaceMmr" , "MmrRootHashes" , () , [140u8 , 183u8 , 201u8 , 9u8 , 97u8 , 33u8 , 219u8 , 214u8 , 156u8 , 10u8 , 103u8 , 185u8 , 227u8 , 2u8 , 152u8 , 99u8 , 118u8 , 62u8 , 21u8 , 124u8 , 70u8 , 129u8 , 165u8 , 69u8 , 147u8 , 236u8 , 34u8 , 67u8 , 82u8 , 161u8 , 29u8 , 175u8 ,]) } # [doc = " Map of block numbers to mmr root hashes."] pub fn mmr_root_hashes (& self , _0 : types :: mmr_root_hashes :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: mmr_root_hashes :: Param0 > , types :: mmr_root_hashes :: MmrRootHashes , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("SubspaceMmr" , "MmrRootHashes" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [140u8 , 183u8 , 201u8 , 9u8 , 97u8 , 33u8 , 219u8 , 214u8 , 156u8 , 10u8 , 103u8 , 185u8 , 227u8 , 2u8 , 152u8 , 99u8 , 118u8 , 62u8 , 21u8 , 124u8 , 70u8 , 129u8 , 165u8 , 69u8 , 147u8 , 236u8 , 34u8 , 67u8 , 82u8 , 161u8 , 29u8 , 175u8 ,]) } } } } pub mod messenger { use super :: root_mod ; use super :: runtime_types ; # [doc = "`pallet-messenger` errors"] pub type Error = runtime_types :: pallet_messenger :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_messenger :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A new Channel is initiated with a foreign chain."] # [doc = "Next Channel ID is used to assign the new channel."] # [doc = "Channel is set to initiated and do not accept or receive any messages."] pub struct InitiateChannel { pub dst_chain_id : initiate_channel :: DstChainId , } pub mod initiate_channel { use super :: runtime_types ; pub type DstChainId = runtime_types :: sp_domains :: ChainId ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for InitiateChannel { const PALLET : & 'static str = "Messenger" ; const CALL : & 'static str = "initiate_channel" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An open channel is closed with a foreign chain."] # [doc = "Channel is set to Closed and do not accept or receive any messages."] pub struct CloseChannel { pub chain_id : close_channel :: ChainId , pub channel_id : close_channel :: ChannelId , } pub mod close_channel { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CloseChannel { const PALLET : & 'static str = "Messenger" ; const CALL : & 'static str = "close_channel" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Receives an Inbox message that needs to be validated and processed."] pub struct RelayMessage { pub msg : relay_message :: Msg , } pub mod relay_message { use super :: runtime_types ; pub type Msg = runtime_types :: sp_messenger :: messages :: CrossDomainMessage < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: H256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RelayMessage { const PALLET : & 'static str = "Messenger" ; const CALL : & 'static str = "relay_message" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Receives a response from the dst_chain for a message in Outbox."] pub struct RelayMessageResponse { pub msg : relay_message_response :: Msg , } pub mod relay_message_response { use super :: runtime_types ; pub type Msg = runtime_types :: sp_messenger :: messages :: CrossDomainMessage < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: H256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RelayMessageResponse { const PALLET : & 'static str = "Messenger" ; const CALL : & 'static str = "relay_message_response" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A call to update consensus chain allow list."] pub struct UpdateConsensusChainAllowlist { pub update : update_consensus_chain_allowlist :: Update , } pub mod update_consensus_chain_allowlist { use super :: runtime_types ; pub type Update = runtime_types :: pallet_messenger :: ChainAllowlistUpdate ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UpdateConsensusChainAllowlist { const PALLET : & 'static str = "Messenger" ; const CALL : & 'static str = "update_consensus_chain_allowlist" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A call to initiate chain allowlist update on domains"] pub struct InitiateDomainUpdateChainAllowlist { pub domain_id : initiate_domain_update_chain_allowlist :: DomainId , pub update : initiate_domain_update_chain_allowlist :: Update , } pub mod initiate_domain_update_chain_allowlist { use super :: runtime_types ; pub type DomainId = runtime_types :: sp_domains :: DomainId ; pub type Update = runtime_types :: pallet_messenger :: ChainAllowlistUpdate ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for InitiateDomainUpdateChainAllowlist { const PALLET : & 'static str = "Messenger" ; const CALL : & 'static str = "initiate_domain_update_chain_allowlist" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An inherent call to update allowlist for domain."] pub struct UpdateDomainAllowlist { pub updates : update_domain_allowlist :: Updates , } pub mod update_domain_allowlist { use super :: runtime_types ; pub type Updates = runtime_types :: sp_domains :: DomainAllowlistUpdates ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UpdateDomainAllowlist { const PALLET : & 'static str = "Messenger" ; const CALL : & 'static str = "update_domain_allowlist" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "A new Channel is initiated with a foreign chain."] # [doc = "Next Channel ID is used to assign the new channel."] # [doc = "Channel is set to initiated and do not accept or receive any messages."] pub fn initiate_channel (& self , dst_chain_id : types :: initiate_channel :: DstChainId ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: InitiateChannel > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Messenger" , "initiate_channel" , types :: InitiateChannel { dst_chain_id , } , [3u8 , 253u8 , 122u8 , 75u8 , 194u8 , 215u8 , 85u8 , 80u8 , 187u8 , 101u8 , 190u8 , 64u8 , 223u8 , 133u8 , 235u8 , 65u8 , 57u8 , 118u8 , 243u8 , 198u8 , 227u8 , 114u8 , 211u8 , 131u8 , 142u8 , 143u8 , 206u8 , 100u8 , 74u8 , 222u8 , 131u8 , 44u8 ,]) } # [doc = "An open channel is closed with a foreign chain."] # [doc = "Channel is set to Closed and do not accept or receive any messages."] pub fn close_channel (& self , chain_id : types :: close_channel :: ChainId , channel_id : types :: close_channel :: ChannelId ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CloseChannel > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Messenger" , "close_channel" , types :: CloseChannel { chain_id , channel_id , } , [226u8 , 30u8 , 196u8 , 235u8 , 43u8 , 244u8 , 122u8 , 87u8 , 214u8 , 2u8 , 51u8 , 250u8 , 127u8 , 252u8 , 117u8 , 91u8 , 36u8 , 250u8 , 84u8 , 34u8 , 115u8 , 172u8 , 222u8 , 243u8 , 53u8 , 69u8 , 110u8 , 119u8 , 194u8 , 191u8 , 36u8 , 32u8 ,]) } # [doc = "Receives an Inbox message that needs to be validated and processed."] pub fn relay_message (& self , msg : types :: relay_message :: Msg ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RelayMessage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Messenger" , "relay_message" , types :: RelayMessage { msg , } , [196u8 , 165u8 , 138u8 , 207u8 , 137u8 , 249u8 , 108u8 , 91u8 , 78u8 , 125u8 , 27u8 , 88u8 , 220u8 , 171u8 , 153u8 , 234u8 , 101u8 , 82u8 , 28u8 , 43u8 , 61u8 , 180u8 , 240u8 , 3u8 , 120u8 , 40u8 , 237u8 , 184u8 , 125u8 , 109u8 , 76u8 , 156u8 ,]) } # [doc = "Receives a response from the dst_chain for a message in Outbox."] pub fn relay_message_response (& self , msg : types :: relay_message_response :: Msg ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RelayMessageResponse > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Messenger" , "relay_message_response" , types :: RelayMessageResponse { msg , } , [77u8 , 68u8 , 246u8 , 161u8 , 5u8 , 43u8 , 54u8 , 227u8 , 208u8 , 161u8 , 178u8 , 188u8 , 2u8 , 51u8 , 203u8 , 220u8 , 30u8 , 228u8 , 38u8 , 10u8 , 241u8 , 148u8 , 61u8 , 134u8 , 6u8 , 75u8 , 35u8 , 114u8 , 152u8 , 90u8 , 188u8 , 234u8 ,]) } # [doc = "A call to update consensus chain allow list."] pub fn update_consensus_chain_allowlist (& self , update : types :: update_consensus_chain_allowlist :: Update ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UpdateConsensusChainAllowlist > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Messenger" , "update_consensus_chain_allowlist" , types :: UpdateConsensusChainAllowlist { update , } , [129u8 , 150u8 , 86u8 , 232u8 , 205u8 , 2u8 , 178u8 , 175u8 , 211u8 , 28u8 , 157u8 , 215u8 , 55u8 , 143u8 , 130u8 , 143u8 , 63u8 , 92u8 , 26u8 , 76u8 , 146u8 , 217u8 , 234u8 , 150u8 , 113u8 , 161u8 , 207u8 , 240u8 , 215u8 , 44u8 , 253u8 , 39u8 ,]) } # [doc = "A call to initiate chain allowlist update on domains"] pub fn initiate_domain_update_chain_allowlist (& self , domain_id : types :: initiate_domain_update_chain_allowlist :: DomainId , update : types :: initiate_domain_update_chain_allowlist :: Update ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: InitiateDomainUpdateChainAllowlist > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Messenger" , "initiate_domain_update_chain_allowlist" , types :: InitiateDomainUpdateChainAllowlist { domain_id , update , } , [218u8 , 84u8 , 17u8 , 27u8 , 42u8 , 181u8 , 162u8 , 51u8 , 222u8 , 249u8 , 204u8 , 168u8 , 187u8 , 191u8 , 163u8 , 45u8 , 229u8 , 88u8 , 189u8 , 167u8 , 54u8 , 247u8 , 217u8 , 215u8 , 106u8 , 60u8 , 186u8 , 8u8 , 23u8 , 38u8 , 32u8 , 36u8 ,]) } # [doc = "An inherent call to update allowlist for domain."] pub fn update_domain_allowlist (& self , updates : types :: update_domain_allowlist :: Updates ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UpdateDomainAllowlist > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Messenger" , "update_domain_allowlist" , types :: UpdateDomainAllowlist { updates , } , [144u8 , 202u8 , 71u8 , 98u8 , 39u8 , 97u8 , 255u8 , 162u8 , 109u8 , 175u8 , 250u8 , 203u8 , 0u8 , 146u8 , 123u8 , 175u8 , 176u8 , 231u8 , 109u8 , 3u8 , 30u8 , 160u8 , 72u8 , 37u8 , 195u8 , 61u8 , 202u8 , 101u8 , 7u8 , 165u8 , 8u8 , 253u8 ,]) } } } # [doc = "`pallet-messenger` events"] pub type Event = runtime_types :: pallet_messenger :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a channel between two chains is initiated."] pub struct ChannelInitiated { pub chain_id : channel_initiated :: ChainId , pub channel_id : channel_initiated :: ChannelId , } pub mod channel_initiated { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ChannelInitiated { const PALLET : & 'static str = "Messenger" ; const EVENT : & 'static str = "ChannelInitiated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a channel between two chains is closed."] pub struct ChannelClosed { pub chain_id : channel_closed :: ChainId , pub channel_id : channel_closed :: ChannelId , } pub mod channel_closed { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ChannelClosed { const PALLET : & 'static str = "Messenger" ; const EVENT : & 'static str = "ChannelClosed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a channel between two chain is open."] pub struct ChannelOpen { pub chain_id : channel_open :: ChainId , pub channel_id : channel_open :: ChannelId , } pub mod channel_open { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ChannelOpen { const PALLET : & 'static str = "Messenger" ; const EVENT : & 'static str = "ChannelOpen" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a new message is added to the outbox."] pub struct OutboxMessage { pub chain_id : outbox_message :: ChainId , pub channel_id : outbox_message :: ChannelId , pub nonce : outbox_message :: Nonce , } pub mod outbox_message { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub type Nonce = runtime_types :: primitive_types :: U256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OutboxMessage { const PALLET : & 'static str = "Messenger" ; const EVENT : & 'static str = "OutboxMessage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a message response is available for Outbox message."] pub struct OutboxMessageResponse { pub chain_id : outbox_message_response :: ChainId , pub channel_id : outbox_message_response :: ChannelId , pub nonce : outbox_message_response :: Nonce , } pub mod outbox_message_response { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub type Nonce = runtime_types :: primitive_types :: U256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OutboxMessageResponse { const PALLET : & 'static str = "Messenger" ; const EVENT : & 'static str = "OutboxMessageResponse" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits outbox message result."] pub struct OutboxMessageResult { pub chain_id : outbox_message_result :: ChainId , pub channel_id : outbox_message_result :: ChannelId , pub nonce : outbox_message_result :: Nonce , pub result : outbox_message_result :: Result , } pub mod outbox_message_result { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub type Nonce = runtime_types :: primitive_types :: U256 ; pub type Result = runtime_types :: pallet_messenger :: OutboxMessageResult ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OutboxMessageResult { const PALLET : & 'static str = "Messenger" ; const EVENT : & 'static str = "OutboxMessageResult" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a new inbox message is validated and added to Inbox."] pub struct InboxMessage { pub chain_id : inbox_message :: ChainId , pub channel_id : inbox_message :: ChannelId , pub nonce : inbox_message :: Nonce , } pub mod inbox_message { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub type Nonce = runtime_types :: primitive_types :: U256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for InboxMessage { const PALLET : & 'static str = "Messenger" ; const EVENT : & 'static str = "InboxMessage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a message response is available for Inbox message."] pub struct InboxMessageResponse { pub chain_id : inbox_message_response :: ChainId , pub channel_id : inbox_message_response :: ChannelId , pub nonce : inbox_message_response :: Nonce , } pub mod inbox_message_response { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type ChannelId = runtime_types :: primitive_types :: U256 ; pub type Nonce = runtime_types :: primitive_types :: U256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for InboxMessageResponse { const PALLET : & 'static str = "Messenger" ; const EVENT : & 'static str = "InboxMessageResponse" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod next_channel_id { use super :: runtime_types ; pub type NextChannelId = runtime_types :: primitive_types :: U256 ; pub type Param0 = runtime_types :: sp_domains :: ChainId ; } pub mod channels { use super :: runtime_types ; pub type Channels = runtime_types :: sp_messenger :: messages :: Channel < :: core :: primitive :: u128 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Param0 = runtime_types :: sp_domains :: ChainId ; pub type Param1 = runtime_types :: primitive_types :: U256 ; } pub mod inbox { use super :: runtime_types ; pub type Inbox = runtime_types :: sp_messenger :: messages :: Message < :: core :: primitive :: u128 > ; } pub mod inbox_fee { use super :: runtime_types ; pub type InboxFee = :: core :: primitive :: u128 ; pub type Param0 = (runtime_types :: sp_domains :: ChainId , (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ,) ; } pub mod outbox_fee { use super :: runtime_types ; pub type OutboxFee = :: core :: primitive :: u128 ; pub type Param0 = (runtime_types :: sp_domains :: ChainId , (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ,) ; } pub mod inbox_responses { use super :: runtime_types ; pub type InboxResponses = runtime_types :: sp_messenger :: messages :: Message < :: core :: primitive :: u128 > ; pub type Param0 = (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; } pub mod outbox { use super :: runtime_types ; pub type Outbox = runtime_types :: sp_messenger :: messages :: Message < :: core :: primitive :: u128 > ; pub type Param0 = (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; } pub mod outbox_message_count { use super :: runtime_types ; pub type OutboxMessageCount = :: core :: primitive :: u32 ; pub type Param0 = (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 ,) ; } pub mod outbox_responses { use super :: runtime_types ; pub type OutboxResponses = runtime_types :: sp_messenger :: messages :: Message < :: core :: primitive :: u128 > ; } pub mod outbox_message_weight_tags { use super :: runtime_types ; pub type OutboxMessageWeightTags = runtime_types :: sp_messenger :: messages :: MessageWeightTag ; pub type Param0 = (runtime_types :: sp_domains :: ChainId , (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ,) ; } pub mod inbox_response_message_weight_tags { use super :: runtime_types ; pub type InboxResponseMessageWeightTags = runtime_types :: sp_messenger :: messages :: MessageWeightTag ; pub type Param0 = (runtime_types :: sp_domains :: ChainId , (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ,) ; } pub mod chain_allowlist { use super :: runtime_types ; pub type ChainAllowlist = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: ChainId > ; } pub mod domain_chain_allowlist_update { use super :: runtime_types ; pub type DomainChainAllowlistUpdate = runtime_types :: sp_domains :: DomainAllowlistUpdates ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod updated_channels { use super :: runtime_types ; pub type UpdatedChannels = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 ,) > ; } pub mod inbox_fees_on_hold { use super :: runtime_types ; pub type InboxFeesOnHold = :: core :: primitive :: u128 ; } pub mod outbox_fees_on_hold { use super :: runtime_types ; pub type OutboxFeesOnHold = :: core :: primitive :: u128 ; } pub mod inbox_fees_on_hold_start_at { use super :: runtime_types ; pub type InboxFeesOnHoldStartAt = runtime_types :: primitive_types :: U256 ; pub type Param0 = runtime_types :: primitive_types :: U256 ; } pub mod outbox_fees_on_hold_start_at { use super :: runtime_types ; pub type OutboxFeesOnHoldStartAt = runtime_types :: primitive_types :: U256 ; pub type Param0 = runtime_types :: primitive_types :: U256 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " Stores the next channel id for a foreign chain."] pub fn next_channel_id_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_channel_id :: NextChannelId , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "NextChannelId" , () , [162u8 , 173u8 , 60u8 , 99u8 , 86u8 , 92u8 , 233u8 , 45u8 , 231u8 , 46u8 , 178u8 , 201u8 , 180u8 , 133u8 , 130u8 , 20u8 , 2u8 , 104u8 , 33u8 , 180u8 , 169u8 , 207u8 , 233u8 , 116u8 , 138u8 , 182u8 , 2u8 , 129u8 , 88u8 , 169u8 , 144u8 , 4u8 ,]) } # [doc = " Stores the next channel id for a foreign chain."] pub fn next_channel_id (& self , _0 : types :: next_channel_id :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: next_channel_id :: Param0 > , types :: next_channel_id :: NextChannelId , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "NextChannelId" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [162u8 , 173u8 , 60u8 , 99u8 , 86u8 , 92u8 , 233u8 , 45u8 , 231u8 , 46u8 , 178u8 , 201u8 , 180u8 , 133u8 , 130u8 , 20u8 , 2u8 , 104u8 , 33u8 , 180u8 , 169u8 , 207u8 , 233u8 , 116u8 , 138u8 , 182u8 , 2u8 , 129u8 , 88u8 , 169u8 , 144u8 , 4u8 ,]) } # [doc = " Stores channel config between two chains."] # [doc = " Key points to the foreign chain wrt own chain's storage name space"] pub fn channels_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: channels :: Channels , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "Channels" , () , [193u8 , 11u8 , 193u8 , 29u8 , 22u8 , 194u8 , 210u8 , 197u8 , 175u8 , 180u8 , 247u8 , 179u8 , 252u8 , 101u8 , 190u8 , 208u8 , 191u8 , 237u8 , 96u8 , 171u8 , 73u8 , 109u8 , 190u8 , 190u8 , 103u8 , 51u8 , 21u8 , 99u8 , 171u8 , 122u8 , 235u8 , 93u8 ,]) } # [doc = " Stores channel config between two chains."] # [doc = " Key points to the foreign chain wrt own chain's storage name space"] pub fn channels_iter1 (& self , _0 : types :: channels :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: channels :: Param0 > , types :: channels :: Channels , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "Channels" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [193u8 , 11u8 , 193u8 , 29u8 , 22u8 , 194u8 , 210u8 , 197u8 , 175u8 , 180u8 , 247u8 , 179u8 , 252u8 , 101u8 , 190u8 , 208u8 , 191u8 , 237u8 , 96u8 , 171u8 , 73u8 , 109u8 , 190u8 , 190u8 , 103u8 , 51u8 , 21u8 , 99u8 , 171u8 , 122u8 , 235u8 , 93u8 ,]) } # [doc = " Stores channel config between two chains."] # [doc = " Key points to the foreign chain wrt own chain's storage name space"] pub fn channels (& self , _0 : types :: channels :: Param0 , _1 : types :: channels :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: channels :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: channels :: Param1 > ,) , types :: channels :: Channels , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "Channels" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [193u8 , 11u8 , 193u8 , 29u8 , 22u8 , 194u8 , 210u8 , 197u8 , 175u8 , 180u8 , 247u8 , 179u8 , 252u8 , 101u8 , 190u8 , 208u8 , 191u8 , 237u8 , 96u8 , 171u8 , 73u8 , 109u8 , 190u8 , 190u8 , 103u8 , 51u8 , 21u8 , 99u8 , 171u8 , 122u8 , 235u8 , 93u8 ,]) } # [doc = " A temporary storage for storing decoded inbox message between `pre_dispatch_relay_message`"] # [doc = " and `relay_message`."] pub fn inbox (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inbox :: Inbox , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "Inbox" , () , [160u8 , 0u8 , 232u8 , 1u8 , 26u8 , 59u8 , 221u8 , 202u8 , 90u8 , 60u8 , 16u8 , 95u8 , 194u8 , 110u8 , 201u8 , 247u8 , 124u8 , 203u8 , 13u8 , 40u8 , 153u8 , 235u8 , 189u8 , 79u8 , 12u8 , 242u8 , 204u8 , 223u8 , 167u8 , 123u8 , 92u8 , 173u8 ,]) } # [doc = " A temporary storage of fees for executing an inbox message."] # [doc = " The storage is cleared when the acknowledgement of inbox response is received"] # [doc = " from the src_chain."] pub fn inbox_fee_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inbox_fee :: InboxFee , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxFee" , () , [177u8 , 239u8 , 102u8 , 141u8 , 221u8 , 228u8 , 216u8 , 191u8 , 249u8 , 243u8 , 237u8 , 78u8 , 236u8 , 98u8 , 246u8 , 106u8 , 89u8 , 9u8 , 110u8 , 36u8 , 124u8 , 159u8 , 242u8 , 46u8 , 66u8 , 100u8 , 127u8 , 200u8 , 26u8 , 32u8 , 176u8 , 149u8 ,]) } # [doc = " A temporary storage of fees for executing an inbox message."] # [doc = " The storage is cleared when the acknowledgement of inbox response is received"] # [doc = " from the src_chain."] pub fn inbox_fee (& self , _0 : types :: inbox_fee :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: inbox_fee :: Param0 > , types :: inbox_fee :: InboxFee , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxFee" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [177u8 , 239u8 , 102u8 , 141u8 , 221u8 , 228u8 , 216u8 , 191u8 , 249u8 , 243u8 , 237u8 , 78u8 , 236u8 , 98u8 , 246u8 , 106u8 , 89u8 , 9u8 , 110u8 , 36u8 , 124u8 , 159u8 , 242u8 , 46u8 , 66u8 , 100u8 , 127u8 , 200u8 , 26u8 , 32u8 , 176u8 , 149u8 ,]) } # [doc = " A temporary storage of fees for executing an outbox message and its response from dst_chain."] # [doc = " The storage is cleared when src_chain receives the response from dst_chain."] pub fn outbox_fee_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: outbox_fee :: OutboxFee , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxFee" , () , [10u8 , 21u8 , 119u8 , 236u8 , 50u8 , 194u8 , 227u8 , 34u8 , 83u8 , 64u8 , 130u8 , 0u8 , 252u8 , 152u8 , 92u8 , 60u8 , 19u8 , 87u8 , 30u8 , 171u8 , 189u8 , 151u8 , 83u8 , 195u8 , 59u8 , 82u8 , 64u8 , 76u8 , 205u8 , 48u8 , 172u8 , 219u8 ,]) } # [doc = " A temporary storage of fees for executing an outbox message and its response from dst_chain."] # [doc = " The storage is cleared when src_chain receives the response from dst_chain."] pub fn outbox_fee (& self , _0 : types :: outbox_fee :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: outbox_fee :: Param0 > , types :: outbox_fee :: OutboxFee , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxFee" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [10u8 , 21u8 , 119u8 , 236u8 , 50u8 , 194u8 , 227u8 , 34u8 , 83u8 , 64u8 , 130u8 , 0u8 , 252u8 , 152u8 , 92u8 , 60u8 , 19u8 , 87u8 , 30u8 , 171u8 , 189u8 , 151u8 , 83u8 , 195u8 , 59u8 , 82u8 , 64u8 , 76u8 , 205u8 , 48u8 , 172u8 , 219u8 ,]) } # [doc = " Stores the message responses of the incoming processed responses."] # [doc = " Used by the dst_chains to verify the message response."] pub fn inbox_responses_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inbox_responses :: InboxResponses , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxResponses" , () , [6u8 , 131u8 , 76u8 , 84u8 , 88u8 , 129u8 , 99u8 , 44u8 , 242u8 , 210u8 , 116u8 , 193u8 , 219u8 , 143u8 , 242u8 , 169u8 , 144u8 , 108u8 , 19u8 , 57u8 , 101u8 , 6u8 , 179u8 , 149u8 , 233u8 , 143u8 , 236u8 , 180u8 , 151u8 , 27u8 , 167u8 , 151u8 ,]) } # [doc = " Stores the message responses of the incoming processed responses."] # [doc = " Used by the dst_chains to verify the message response."] pub fn inbox_responses (& self , _0 : types :: inbox_responses :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: inbox_responses :: Param0 > , types :: inbox_responses :: InboxResponses , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxResponses" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [6u8 , 131u8 , 76u8 , 84u8 , 88u8 , 129u8 , 99u8 , 44u8 , 242u8 , 210u8 , 116u8 , 193u8 , 219u8 , 143u8 , 242u8 , 169u8 , 144u8 , 108u8 , 19u8 , 57u8 , 101u8 , 6u8 , 179u8 , 149u8 , 233u8 , 143u8 , 236u8 , 180u8 , 151u8 , 27u8 , 167u8 , 151u8 ,]) } # [doc = " Stores the outgoing messages that are awaiting message responses from the dst_chain."] # [doc = " Messages are processed in the outbox nonce order of chain's channel."] pub fn outbox_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: outbox :: Outbox , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "Outbox" , () , [169u8 , 251u8 , 50u8 , 194u8 , 70u8 , 115u8 , 39u8 , 136u8 , 96u8 , 159u8 , 73u8 , 2u8 , 24u8 , 0u8 , 238u8 , 51u8 , 149u8 , 237u8 , 58u8 , 27u8 , 97u8 , 173u8 , 234u8 , 44u8 , 210u8 , 124u8 , 193u8 , 234u8 , 72u8 , 20u8 , 169u8 , 6u8 ,]) } # [doc = " Stores the outgoing messages that are awaiting message responses from the dst_chain."] # [doc = " Messages are processed in the outbox nonce order of chain's channel."] pub fn outbox (& self , _0 : types :: outbox :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: outbox :: Param0 > , types :: outbox :: Outbox , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "Outbox" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [169u8 , 251u8 , 50u8 , 194u8 , 70u8 , 115u8 , 39u8 , 136u8 , 96u8 , 159u8 , 73u8 , 2u8 , 24u8 , 0u8 , 238u8 , 51u8 , 149u8 , 237u8 , 58u8 , 27u8 , 97u8 , 173u8 , 234u8 , 44u8 , 210u8 , 124u8 , 193u8 , 234u8 , 72u8 , 20u8 , 169u8 , 6u8 ,]) } # [doc = " Stores the outgoing messages count that are awaiting message responses from the dst_chain."] pub fn outbox_message_count_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: outbox_message_count :: OutboxMessageCount , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxMessageCount" , () , [220u8 , 39u8 , 198u8 , 108u8 , 182u8 , 103u8 , 91u8 , 155u8 , 90u8 , 182u8 , 135u8 , 32u8 , 31u8 , 51u8 , 136u8 , 201u8 , 153u8 , 101u8 , 166u8 , 96u8 , 214u8 , 67u8 , 99u8 , 87u8 , 133u8 , 116u8 , 45u8 , 156u8 , 149u8 , 232u8 , 80u8 , 248u8 ,]) } # [doc = " Stores the outgoing messages count that are awaiting message responses from the dst_chain."] pub fn outbox_message_count (& self , _0 : types :: outbox_message_count :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: outbox_message_count :: Param0 > , types :: outbox_message_count :: OutboxMessageCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxMessageCount" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [220u8 , 39u8 , 198u8 , 108u8 , 182u8 , 103u8 , 91u8 , 155u8 , 90u8 , 182u8 , 135u8 , 32u8 , 31u8 , 51u8 , 136u8 , 201u8 , 153u8 , 101u8 , 166u8 , 96u8 , 214u8 , 67u8 , 99u8 , 87u8 , 133u8 , 116u8 , 45u8 , 156u8 , 149u8 , 232u8 , 80u8 , 248u8 ,]) } # [doc = " A temporary storage for storing decoded outbox response message between `pre_dispatch_relay_message_response`"] # [doc = " and `relay_message_response`."] pub fn outbox_responses (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: outbox_responses :: OutboxResponses , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxResponses" , () , [110u8 , 161u8 , 34u8 , 101u8 , 86u8 , 152u8 , 52u8 , 148u8 , 143u8 , 123u8 , 66u8 , 106u8 , 146u8 , 131u8 , 251u8 , 110u8 , 180u8 , 136u8 , 88u8 , 30u8 , 2u8 , 104u8 , 66u8 , 189u8 , 51u8 , 123u8 , 118u8 , 23u8 , 69u8 , 149u8 , 46u8 , 147u8 ,]) } # [doc = " Storage to store the weight tags for all the outbox messages."] pub fn outbox_message_weight_tags_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: outbox_message_weight_tags :: OutboxMessageWeightTags , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxMessageWeightTags" , () , [187u8 , 237u8 , 182u8 , 248u8 , 35u8 , 4u8 , 5u8 , 153u8 , 179u8 , 191u8 , 5u8 , 60u8 , 240u8 , 185u8 , 79u8 , 65u8 , 79u8 , 44u8 , 167u8 , 248u8 , 223u8 , 250u8 , 83u8 , 118u8 , 176u8 , 9u8 , 7u8 , 246u8 , 233u8 , 167u8 , 22u8 , 133u8 ,]) } # [doc = " Storage to store the weight tags for all the outbox messages."] pub fn outbox_message_weight_tags (& self , _0 : types :: outbox_message_weight_tags :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: outbox_message_weight_tags :: Param0 > , types :: outbox_message_weight_tags :: OutboxMessageWeightTags , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxMessageWeightTags" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [187u8 , 237u8 , 182u8 , 248u8 , 35u8 , 4u8 , 5u8 , 153u8 , 179u8 , 191u8 , 5u8 , 60u8 , 240u8 , 185u8 , 79u8 , 65u8 , 79u8 , 44u8 , 167u8 , 248u8 , 223u8 , 250u8 , 83u8 , 118u8 , 176u8 , 9u8 , 7u8 , 246u8 , 233u8 , 167u8 , 22u8 , 133u8 ,]) } # [doc = " Storage to store the weight tags for all the inbox responses messages."] pub fn inbox_response_message_weight_tags_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inbox_response_message_weight_tags :: InboxResponseMessageWeightTags , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxResponseMessageWeightTags" , () , [152u8 , 87u8 , 67u8 , 146u8 , 140u8 , 121u8 , 65u8 , 90u8 , 132u8 , 221u8 , 39u8 , 27u8 , 12u8 , 148u8 , 101u8 , 196u8 , 66u8 , 124u8 , 50u8 , 238u8 , 11u8 , 178u8 , 48u8 , 26u8 , 143u8 , 175u8 , 185u8 , 102u8 , 171u8 , 135u8 , 207u8 , 19u8 ,]) } # [doc = " Storage to store the weight tags for all the inbox responses messages."] pub fn inbox_response_message_weight_tags (& self , _0 : types :: inbox_response_message_weight_tags :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: inbox_response_message_weight_tags :: Param0 > , types :: inbox_response_message_weight_tags :: InboxResponseMessageWeightTags , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxResponseMessageWeightTags" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [152u8 , 87u8 , 67u8 , 146u8 , 140u8 , 121u8 , 65u8 , 90u8 , 132u8 , 221u8 , 39u8 , 27u8 , 12u8 , 148u8 , 101u8 , 196u8 , 66u8 , 124u8 , 50u8 , 238u8 , 11u8 , 178u8 , 48u8 , 26u8 , 143u8 , 175u8 , 185u8 , 102u8 , 171u8 , 135u8 , 207u8 , 19u8 ,]) } # [doc = " An allowlist of chains that can open channel with this chain."] pub fn chain_allowlist (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: chain_allowlist :: ChainAllowlist , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "ChainAllowlist" , () , [1u8 , 50u8 , 88u8 , 145u8 , 69u8 , 65u8 , 123u8 , 31u8 , 121u8 , 56u8 , 57u8 , 68u8 , 157u8 , 104u8 , 72u8 , 176u8 , 98u8 , 100u8 , 191u8 , 102u8 , 191u8 , 130u8 , 200u8 , 93u8 , 174u8 , 240u8 , 171u8 , 172u8 , 212u8 , 114u8 , 181u8 , 245u8 ,]) } # [doc = " A storage to store any allowlist updates to domain. The updates will be cleared in the next block"] # [doc = " once the previous block has a domain bundle, but a empty value should be left because in the invalid"] # [doc = " extrinsic root fraud proof the prover need to generate a proof-of-empty-value for the domain."] pub fn domain_chain_allowlist_update_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_chain_allowlist_update :: DomainChainAllowlistUpdate , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "DomainChainAllowlistUpdate" , () , [122u8 , 2u8 , 174u8 , 225u8 , 155u8 , 156u8 , 6u8 , 241u8 , 128u8 , 59u8 , 43u8 , 104u8 , 120u8 , 153u8 , 46u8 , 46u8 , 143u8 , 66u8 , 66u8 , 235u8 , 183u8 , 255u8 , 34u8 , 175u8 , 8u8 , 175u8 , 152u8 , 41u8 , 242u8 , 188u8 , 25u8 , 189u8 ,]) } # [doc = " A storage to store any allowlist updates to domain. The updates will be cleared in the next block"] # [doc = " once the previous block has a domain bundle, but a empty value should be left because in the invalid"] # [doc = " extrinsic root fraud proof the prover need to generate a proof-of-empty-value for the domain."] pub fn domain_chain_allowlist_update (& self , _0 : types :: domain_chain_allowlist_update :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_chain_allowlist_update :: Param0 > , types :: domain_chain_allowlist_update :: DomainChainAllowlistUpdate , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "DomainChainAllowlistUpdate" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [122u8 , 2u8 , 174u8 , 225u8 , 155u8 , 156u8 , 6u8 , 241u8 , 128u8 , 59u8 , 43u8 , 104u8 , 120u8 , 153u8 , 46u8 , 46u8 , 143u8 , 66u8 , 66u8 , 235u8 , 183u8 , 255u8 , 34u8 , 175u8 , 8u8 , 175u8 , 152u8 , 41u8 , 242u8 , 188u8 , 25u8 , 189u8 ,]) } # [doc = " Temporary storage to store the updated channels between this chain and other chain."] # [doc = " Storage is cleared on block initialization."] pub fn updated_channels (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: updated_channels :: UpdatedChannels , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "UpdatedChannels" , () , [108u8 , 156u8 , 208u8 , 63u8 , 156u8 , 253u8 , 61u8 , 198u8 , 226u8 , 177u8 , 105u8 , 150u8 , 141u8 , 248u8 , 142u8 , 142u8 , 255u8 , 10u8 , 95u8 , 117u8 , 141u8 , 250u8 , 104u8 , 56u8 , 233u8 , 240u8 , 176u8 , 92u8 , 137u8 , 238u8 , 8u8 , 241u8 ,]) } # [doc = " Storage to track the inbox fees that is hold on the chain before distributing."] # [doc = ""] # [doc = " NOTE: The inbox fees is accounted to the chain's total issuance but not hold on any account"] # [doc = " because an account with balance below ED will be reaped, in this way, we can manage small"] # [doc = " inbox fee that less than ED easier. It also means whenever `InboxFeesOnHold` is increase/decrease"] # [doc = " we need to increase/decrease the total issuance manually."] pub fn inbox_fees_on_hold (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inbox_fees_on_hold :: InboxFeesOnHold , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxFeesOnHold" , () , [25u8 , 226u8 , 51u8 , 46u8 , 26u8 , 247u8 , 120u8 , 223u8 , 71u8 , 233u8 , 140u8 , 235u8 , 82u8 , 11u8 , 254u8 , 117u8 , 127u8 , 214u8 , 240u8 , 246u8 , 182u8 , 114u8 , 210u8 , 239u8 , 18u8 , 159u8 , 211u8 , 5u8 , 10u8 , 40u8 , 243u8 , 30u8 ,]) } # [doc = " Storage to track the outbox fees that is hold on the chain before distributing."] # [doc = ""] # [doc = " NOTE: The outbox fees is accounted to the chain's total issuance but not hold on any account"] # [doc = " because an account with balance below ED will be reaped, in this way, we can manage small"] # [doc = " outbox fee that less than ED easier. It also means whenever `OutboxFeesOnHold` is increase/decrease"] # [doc = " we need to increase/decrease the total issuance manually."] pub fn outbox_fees_on_hold (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: outbox_fees_on_hold :: OutboxFeesOnHold , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxFeesOnHold" , () , [147u8 , 48u8 , 38u8 , 182u8 , 245u8 , 14u8 , 232u8 , 188u8 , 188u8 , 94u8 , 45u8 , 175u8 , 99u8 , 111u8 , 131u8 , 92u8 , 33u8 , 100u8 , 69u8 , 16u8 , 113u8 , 142u8 , 129u8 , 120u8 , 97u8 , 95u8 , 36u8 , 225u8 , 251u8 , 212u8 , 245u8 , 133u8 ,]) } # [doc = " `InboxFeesOnHoldStartAt` and `OutboxFeesOnHoldStartAt` are used to record when the inbox/outbox fee"] # [doc = " is started to be tracked in `InboxFeesOnHold` and `OutboxFeesOnHold`. This is needed as migration on"] # [doc = " Taurus."] # [doc = ""] # [doc = " TODO: remove once the XDM V1 format is enabled on Taurus and all the untracked pending XDM is processed."] pub fn inbox_fees_on_hold_start_at_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: inbox_fees_on_hold_start_at :: InboxFeesOnHoldStartAt , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxFeesOnHoldStartAt" , () , [156u8 , 145u8 , 241u8 , 77u8 , 101u8 , 152u8 , 34u8 , 64u8 , 255u8 , 90u8 , 187u8 , 232u8 , 77u8 , 77u8 , 214u8 , 195u8 , 24u8 , 173u8 , 114u8 , 119u8 , 171u8 , 239u8 , 93u8 , 189u8 , 216u8 , 242u8 , 6u8 , 160u8 , 59u8 , 83u8 , 246u8 , 204u8 ,]) } # [doc = " `InboxFeesOnHoldStartAt` and `OutboxFeesOnHoldStartAt` are used to record when the inbox/outbox fee"] # [doc = " is started to be tracked in `InboxFeesOnHold` and `OutboxFeesOnHold`. This is needed as migration on"] # [doc = " Taurus."] # [doc = ""] # [doc = " TODO: remove once the XDM V1 format is enabled on Taurus and all the untracked pending XDM is processed."] pub fn inbox_fees_on_hold_start_at (& self , _0 : types :: inbox_fees_on_hold_start_at :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: inbox_fees_on_hold_start_at :: Param0 > , types :: inbox_fees_on_hold_start_at :: InboxFeesOnHoldStartAt , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "InboxFeesOnHoldStartAt" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [156u8 , 145u8 , 241u8 , 77u8 , 101u8 , 152u8 , 34u8 , 64u8 , 255u8 , 90u8 , 187u8 , 232u8 , 77u8 , 77u8 , 214u8 , 195u8 , 24u8 , 173u8 , 114u8 , 119u8 , 171u8 , 239u8 , 93u8 , 189u8 , 216u8 , 242u8 , 6u8 , 160u8 , 59u8 , 83u8 , 246u8 , 204u8 ,]) } pub fn outbox_fees_on_hold_start_at_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: outbox_fees_on_hold_start_at :: OutboxFeesOnHoldStartAt , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxFeesOnHoldStartAt" , () , [92u8 , 161u8 , 91u8 , 45u8 , 206u8 , 62u8 , 148u8 , 126u8 , 240u8 , 59u8 , 26u8 , 169u8 , 232u8 , 255u8 , 234u8 , 122u8 , 22u8 , 230u8 , 52u8 , 98u8 , 225u8 , 22u8 , 26u8 , 241u8 , 45u8 , 254u8 , 92u8 , 176u8 , 150u8 , 65u8 , 105u8 , 188u8 ,]) } pub fn outbox_fees_on_hold_start_at (& self , _0 : types :: outbox_fees_on_hold_start_at :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: outbox_fees_on_hold_start_at :: Param0 > , types :: outbox_fees_on_hold_start_at :: OutboxFeesOnHoldStartAt , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Messenger" , "OutboxFeesOnHoldStartAt" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [92u8 , 161u8 , 91u8 , 45u8 , 206u8 , 62u8 , 148u8 , 126u8 , 240u8 , 59u8 , 26u8 , 169u8 , 232u8 , 255u8 , 234u8 , 122u8 , 22u8 , 230u8 , 52u8 , 98u8 , 225u8 , 22u8 , 26u8 , 241u8 , 45u8 , 254u8 , 92u8 , 176u8 , 150u8 , 65u8 , 105u8 , 188u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Fee Multiper for XDM"] # [doc = " Final fee calculated will fee_multiplier * adjusted_weight_to_fee."] pub fn fee_multiplier (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Messenger" , "FeeMultiplier" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Channel reserve fee to open a channel."] pub fn channel_reserve_fee (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Messenger" , "ChannelReserveFee" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Portion of Channel reserve taken by the protocol"] # [doc = " if the channel is in init state and is requested to be closed."] pub fn channel_init_reserve_portion (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_arithmetic :: per_things :: Perbill > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Messenger" , "ChannelInitReservePortion" , [65u8 , 93u8 , 120u8 , 165u8 , 204u8 , 81u8 , 159u8 , 163u8 , 93u8 , 135u8 , 114u8 , 121u8 , 147u8 , 35u8 , 215u8 , 213u8 , 4u8 , 223u8 , 83u8 , 37u8 , 225u8 , 200u8 , 189u8 , 156u8 , 140u8 , 36u8 , 58u8 , 46u8 , 42u8 , 232u8 , 155u8 , 0u8 ,]) } # [doc = " Maximum outgoing messages from a given channel"] pub fn max_outgoing_messages (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Messenger" , "MaxOutgoingMessages" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod transporter { use super :: root_mod ; use super :: runtime_types ; # [doc = "Errors emitted by pallet-transporter."] pub type Error = runtime_types :: pallet_transporter :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_transporter :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Initiates transfer of funds from account on src_chain to account on dst_chain."] # [doc = "Funds are burned on src_chain first and are minted on dst_chain using Messenger."] pub struct Transfer { pub dst_location : transfer :: DstLocation , pub amount : transfer :: Amount , } pub mod transfer { use super :: runtime_types ; pub type DstLocation = runtime_types :: pallet_transporter :: Location ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Transfer { const PALLET : & 'static str = "Transporter" ; const CALL : & 'static str = "transfer" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Initiates transfer of funds from account on src_chain to account on dst_chain."] # [doc = "Funds are burned on src_chain first and are minted on dst_chain using Messenger."] pub fn transfer (& self , dst_location : types :: transfer :: DstLocation , amount : types :: transfer :: Amount ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Transfer > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Transporter" , "transfer" , types :: Transfer { dst_location , amount , } , [183u8 , 173u8 , 215u8 , 213u8 , 4u8 , 61u8 , 170u8 , 246u8 , 231u8 , 135u8 , 144u8 , 28u8 , 233u8 , 24u8 , 93u8 , 78u8 , 76u8 , 61u8 , 158u8 , 30u8 , 43u8 , 6u8 , 241u8 , 7u8 , 11u8 , 25u8 , 252u8 , 146u8 , 94u8 , 4u8 , 106u8 , 217u8 ,]) } } } # [doc = "Events emitted by pallet-transporter."] pub type Event = runtime_types :: pallet_transporter :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when there is a new outgoing transfer."] pub struct OutgoingTransferInitiated { pub chain_id : outgoing_transfer_initiated :: ChainId , pub message_id : outgoing_transfer_initiated :: MessageId , pub amount : outgoing_transfer_initiated :: Amount , } pub mod outgoing_transfer_initiated { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type MessageId = (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OutgoingTransferInitiated { const PALLET : & 'static str = "Transporter" ; const EVENT : & 'static str = "OutgoingTransferInitiated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a given outgoing transfer was failed on dst_chain."] pub struct OutgoingTransferFailed { pub chain_id : outgoing_transfer_failed :: ChainId , pub message_id : outgoing_transfer_failed :: MessageId , pub err : outgoing_transfer_failed :: Err , } pub mod outgoing_transfer_failed { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type MessageId = (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; pub type Err = runtime_types :: sp_runtime :: DispatchError ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OutgoingTransferFailed { const PALLET : & 'static str = "Transporter" ; const EVENT : & 'static str = "OutgoingTransferFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a given outgoing transfer was successful."] pub struct OutgoingTransferSuccessful { pub chain_id : outgoing_transfer_successful :: ChainId , pub message_id : outgoing_transfer_successful :: MessageId , } pub mod outgoing_transfer_successful { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type MessageId = (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for OutgoingTransferSuccessful { const PALLET : & 'static str = "Transporter" ; const EVENT : & 'static str = "OutgoingTransferSuccessful" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Emits when a given incoming transfer was successfully processed."] pub struct IncomingTransferSuccessful { pub chain_id : incoming_transfer_successful :: ChainId , pub message_id : incoming_transfer_successful :: MessageId , pub amount : incoming_transfer_successful :: Amount , } pub mod incoming_transfer_successful { use super :: runtime_types ; pub type ChainId = runtime_types :: sp_domains :: ChainId ; pub type MessageId = (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; pub type Amount = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for IncomingTransferSuccessful { const PALLET : & 'static str = "Transporter" ; const EVENT : & 'static str = "IncomingTransferSuccessful" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod outgoing_transfers { use super :: runtime_types ; pub type OutgoingTransfers = runtime_types :: pallet_transporter :: Transfer < :: core :: primitive :: u128 > ; pub type Param0 = runtime_types :: sp_domains :: ChainId ; pub type Param1 = (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ; } pub mod domain_balances { use super :: runtime_types ; pub type DomainBalances = :: core :: primitive :: u128 ; pub type Param0 = runtime_types :: sp_domains :: DomainId ; } pub mod chain_transfers { use super :: runtime_types ; pub type ChainTransfers = runtime_types :: sp_domains :: Transfers < :: core :: primitive :: u128 > ; } pub mod unconfirmed_transfers { use super :: runtime_types ; pub type UnconfirmedTransfers = :: core :: primitive :: u128 ; pub type Param0 = runtime_types :: sp_domains :: ChainId ; pub type Param1 = runtime_types :: sp_domains :: ChainId ; } pub mod cancelled_transfers { use super :: runtime_types ; pub type CancelledTransfers = :: core :: primitive :: u128 ; pub type Param0 = runtime_types :: sp_domains :: ChainId ; pub type Param1 = runtime_types :: sp_domains :: ChainId ; } } pub struct StorageApi ; impl StorageApi { # [doc = " All the outgoing transfers on this execution environment."] pub fn outgoing_transfers_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: outgoing_transfers :: OutgoingTransfers , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "OutgoingTransfers" , () , [178u8 , 139u8 , 130u8 , 102u8 , 146u8 , 182u8 , 169u8 , 201u8 , 87u8 , 116u8 , 210u8 , 170u8 , 15u8 , 138u8 , 153u8 , 184u8 , 100u8 , 121u8 , 172u8 , 2u8 , 101u8 , 2u8 , 20u8 , 244u8 , 58u8 , 210u8 , 181u8 , 94u8 , 19u8 , 208u8 , 217u8 , 162u8 ,]) } # [doc = " All the outgoing transfers on this execution environment."] pub fn outgoing_transfers_iter1 (& self , _0 : types :: outgoing_transfers :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: outgoing_transfers :: Param0 > , types :: outgoing_transfers :: OutgoingTransfers , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "OutgoingTransfers" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [178u8 , 139u8 , 130u8 , 102u8 , 146u8 , 182u8 , 169u8 , 201u8 , 87u8 , 116u8 , 210u8 , 170u8 , 15u8 , 138u8 , 153u8 , 184u8 , 100u8 , 121u8 , 172u8 , 2u8 , 101u8 , 2u8 , 20u8 , 244u8 , 58u8 , 210u8 , 181u8 , 94u8 , 19u8 , 208u8 , 217u8 , 162u8 ,]) } # [doc = " All the outgoing transfers on this execution environment."] pub fn outgoing_transfers (& self , _0 : types :: outgoing_transfers :: Param0 , _1 : types :: outgoing_transfers :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: outgoing_transfers :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: outgoing_transfers :: Param1 > ,) , types :: outgoing_transfers :: OutgoingTransfers , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "OutgoingTransfers" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [178u8 , 139u8 , 130u8 , 102u8 , 146u8 , 182u8 , 169u8 , 201u8 , 87u8 , 116u8 , 210u8 , 170u8 , 15u8 , 138u8 , 153u8 , 184u8 , 100u8 , 121u8 , 172u8 , 2u8 , 101u8 , 2u8 , 20u8 , 244u8 , 58u8 , 210u8 , 181u8 , 94u8 , 19u8 , 208u8 , 217u8 , 162u8 ,]) } # [doc = " Domain balances."] pub fn domain_balances_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: domain_balances :: DomainBalances , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "DomainBalances" , () , [147u8 , 201u8 , 224u8 , 2u8 , 67u8 , 218u8 , 209u8 , 179u8 , 145u8 , 19u8 , 153u8 , 242u8 , 77u8 , 146u8 , 77u8 , 144u8 , 136u8 , 40u8 , 141u8 , 97u8 , 152u8 , 195u8 , 200u8 , 121u8 , 107u8 , 194u8 , 229u8 , 132u8 , 171u8 , 150u8 , 143u8 , 63u8 ,]) } # [doc = " Domain balances."] pub fn domain_balances (& self , _0 : types :: domain_balances :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: domain_balances :: Param0 > , types :: domain_balances :: DomainBalances , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "DomainBalances" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [147u8 , 201u8 , 224u8 , 2u8 , 67u8 , 218u8 , 209u8 , 179u8 , 145u8 , 19u8 , 153u8 , 242u8 , 77u8 , 146u8 , 77u8 , 144u8 , 136u8 , 40u8 , 141u8 , 97u8 , 152u8 , 195u8 , 200u8 , 121u8 , 107u8 , 194u8 , 229u8 , 132u8 , 171u8 , 150u8 , 143u8 , 63u8 ,]) } # [doc = " A temporary storage that tracks total transfers from this chain."] # [doc = " Clears on on_initialize for every block."] pub fn chain_transfers (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: chain_transfers :: ChainTransfers , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "ChainTransfers" , () , [12u8 , 241u8 , 30u8 , 107u8 , 103u8 , 101u8 , 170u8 , 235u8 , 77u8 , 70u8 , 228u8 , 81u8 , 75u8 , 65u8 , 88u8 , 170u8 , 59u8 , 7u8 , 17u8 , 127u8 , 140u8 , 152u8 , 252u8 , 228u8 , 108u8 , 219u8 , 172u8 , 170u8 , 57u8 , 129u8 , 249u8 , 117u8 ,]) } # [doc = " Storage to track unconfirmed transfers between different chains."] pub fn unconfirmed_transfers_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: unconfirmed_transfers :: UnconfirmedTransfers , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "UnconfirmedTransfers" , () , [217u8 , 89u8 , 155u8 , 28u8 , 251u8 , 113u8 , 18u8 , 111u8 , 6u8 , 222u8 , 79u8 , 239u8 , 142u8 , 247u8 , 247u8 , 158u8 , 18u8 , 161u8 , 243u8 , 37u8 , 156u8 , 18u8 , 227u8 , 13u8 , 5u8 , 78u8 , 222u8 , 187u8 , 123u8 , 82u8 , 88u8 , 228u8 ,]) } # [doc = " Storage to track unconfirmed transfers between different chains."] pub fn unconfirmed_transfers_iter1 (& self , _0 : types :: unconfirmed_transfers :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: unconfirmed_transfers :: Param0 > , types :: unconfirmed_transfers :: UnconfirmedTransfers , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "UnconfirmedTransfers" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [217u8 , 89u8 , 155u8 , 28u8 , 251u8 , 113u8 , 18u8 , 111u8 , 6u8 , 222u8 , 79u8 , 239u8 , 142u8 , 247u8 , 247u8 , 158u8 , 18u8 , 161u8 , 243u8 , 37u8 , 156u8 , 18u8 , 227u8 , 13u8 , 5u8 , 78u8 , 222u8 , 187u8 , 123u8 , 82u8 , 88u8 , 228u8 ,]) } # [doc = " Storage to track unconfirmed transfers between different chains."] pub fn unconfirmed_transfers (& self , _0 : types :: unconfirmed_transfers :: Param0 , _1 : types :: unconfirmed_transfers :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: unconfirmed_transfers :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: unconfirmed_transfers :: Param1 > ,) , types :: unconfirmed_transfers :: UnconfirmedTransfers , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "UnconfirmedTransfers" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [217u8 , 89u8 , 155u8 , 28u8 , 251u8 , 113u8 , 18u8 , 111u8 , 6u8 , 222u8 , 79u8 , 239u8 , 142u8 , 247u8 , 247u8 , 158u8 , 18u8 , 161u8 , 243u8 , 37u8 , 156u8 , 18u8 , 227u8 , 13u8 , 5u8 , 78u8 , 222u8 , 187u8 , 123u8 , 82u8 , 88u8 , 228u8 ,]) } # [doc = " Storage to track cancelled transfers between different chains."] pub fn cancelled_transfers_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: cancelled_transfers :: CancelledTransfers , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "CancelledTransfers" , () , [25u8 , 236u8 , 204u8 , 24u8 , 198u8 , 232u8 , 65u8 , 52u8 , 152u8 , 206u8 , 55u8 , 120u8 , 186u8 , 207u8 , 142u8 , 222u8 , 182u8 , 29u8 , 179u8 , 114u8 , 101u8 , 212u8 , 2u8 , 10u8 , 58u8 , 235u8 , 10u8 , 186u8 , 60u8 , 99u8 , 28u8 , 38u8 ,]) } # [doc = " Storage to track cancelled transfers between different chains."] pub fn cancelled_transfers_iter1 (& self , _0 : types :: cancelled_transfers :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: cancelled_transfers :: Param0 > , types :: cancelled_transfers :: CancelledTransfers , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "CancelledTransfers" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [25u8 , 236u8 , 204u8 , 24u8 , 198u8 , 232u8 , 65u8 , 52u8 , 152u8 , 206u8 , 55u8 , 120u8 , 186u8 , 207u8 , 142u8 , 222u8 , 182u8 , 29u8 , 179u8 , 114u8 , 101u8 , 212u8 , 2u8 , 10u8 , 58u8 , 235u8 , 10u8 , 186u8 , 60u8 , 99u8 , 28u8 , 38u8 ,]) } # [doc = " Storage to track cancelled transfers between different chains."] pub fn cancelled_transfers (& self , _0 : types :: cancelled_transfers :: Param0 , _1 : types :: cancelled_transfers :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: cancelled_transfers :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: cancelled_transfers :: Param1 > ,) , types :: cancelled_transfers :: CancelledTransfers , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Transporter" , "CancelledTransfers" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [25u8 , 236u8 , 204u8 , 24u8 , 198u8 , 232u8 , 65u8 , 52u8 , 152u8 , 206u8 , 55u8 , 120u8 , 186u8 , 207u8 , 142u8 , 222u8 , 182u8 , 29u8 , 179u8 , 114u8 , 101u8 , 212u8 , 2u8 , 10u8 , 58u8 , 235u8 , 10u8 , 186u8 , 60u8 , 99u8 , 28u8 , 38u8 ,]) } } } } pub mod scheduler { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_scheduler :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_scheduler :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Anonymously schedule a task."] pub struct Schedule { pub when : schedule :: When , pub maybe_periodic : schedule :: MaybePeriodic , pub priority : schedule :: Priority , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < schedule :: Call > , } pub mod schedule { use super :: runtime_types ; pub type When = :: core :: primitive :: u32 ; pub type MaybePeriodic = :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Priority = :: core :: primitive :: u8 ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Schedule { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "schedule" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel an anonymously scheduled task."] pub struct Cancel { pub when : cancel :: When , pub index : cancel :: Index , } pub mod cancel { use super :: runtime_types ; pub type When = :: core :: primitive :: u32 ; pub type Index = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Cancel { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "cancel" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule a named task."] pub struct ScheduleNamed { pub id : schedule_named :: Id , pub when : schedule_named :: When , pub maybe_periodic : schedule_named :: MaybePeriodic , pub priority : schedule_named :: Priority , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < schedule_named :: Call > , } pub mod schedule_named { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; pub type When = :: core :: primitive :: u32 ; pub type MaybePeriodic = :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Priority = :: core :: primitive :: u8 ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ScheduleNamed { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "schedule_named" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel a named scheduled task."] pub struct CancelNamed { pub id : cancel_named :: Id , } pub mod cancel_named { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelNamed { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "cancel_named" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Anonymously schedule a task after a delay."] pub struct ScheduleAfter { pub after : schedule_after :: After , pub maybe_periodic : schedule_after :: MaybePeriodic , pub priority : schedule_after :: Priority , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < schedule_after :: Call > , } pub mod schedule_after { use super :: runtime_types ; pub type After = :: core :: primitive :: u32 ; pub type MaybePeriodic = :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Priority = :: core :: primitive :: u8 ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ScheduleAfter { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "schedule_after" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule a named task after a delay."] pub struct ScheduleNamedAfter { pub id : schedule_named_after :: Id , pub after : schedule_named_after :: After , pub maybe_periodic : schedule_named_after :: MaybePeriodic , pub priority : schedule_named_after :: Priority , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < schedule_named_after :: Call > , } pub mod schedule_named_after { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; pub type After = :: core :: primitive :: u32 ; pub type MaybePeriodic = :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; pub type Priority = :: core :: primitive :: u8 ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ScheduleNamedAfter { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "schedule_named_after" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"] # [doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"] # [doc = "succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] pub struct SetRetry { pub task : set_retry :: Task , pub retries : set_retry :: Retries , pub period : set_retry :: Period , } pub mod set_retry { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Retries = :: core :: primitive :: u8 ; pub type Period = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetRetry { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "set_retry" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"] # [doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"] # [doc = "it succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] pub struct SetRetryNamed { pub id : set_retry_named :: Id , pub retries : set_retry_named :: Retries , pub period : set_retry_named :: Period , } pub mod set_retry_named { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; pub type Retries = :: core :: primitive :: u8 ; pub type Period = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetRetryNamed { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "set_retry_named" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Removes the retry configuration of a task."] pub struct CancelRetry { pub task : cancel_retry :: Task , } pub mod cancel_retry { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelRetry { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "cancel_retry" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel the retry configuration of a named task."] pub struct CancelRetryNamed { pub id : cancel_retry_named :: Id , } pub mod cancel_retry_named { use super :: runtime_types ; pub type Id = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelRetryNamed { const PALLET : & 'static str = "Scheduler" ; const CALL : & 'static str = "cancel_retry_named" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Anonymously schedule a task."] pub fn schedule (& self , when : types :: schedule :: When , maybe_periodic : types :: schedule :: MaybePeriodic , priority : types :: schedule :: Priority , call : types :: schedule :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Schedule > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "schedule" , types :: Schedule { when , maybe_periodic , priority , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [22u8 , 81u8 , 236u8 , 222u8 , 116u8 , 242u8 , 67u8 , 15u8 , 205u8 , 95u8 , 153u8 , 131u8 , 201u8 , 50u8 , 140u8 , 130u8 , 251u8 , 79u8 , 219u8 , 15u8 , 50u8 , 179u8 , 42u8 , 121u8 , 134u8 , 188u8 , 26u8 , 220u8 , 190u8 , 120u8 , 62u8 , 84u8 ,]) } # [doc = "Cancel an anonymously scheduled task."] pub fn cancel (& self , when : types :: cancel :: When , index : types :: cancel :: Index ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Cancel > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "cancel" , types :: Cancel { when , index , } , [183u8 , 204u8 , 143u8 , 86u8 , 17u8 , 130u8 , 132u8 , 91u8 , 133u8 , 168u8 , 103u8 , 129u8 , 114u8 , 56u8 , 123u8 , 42u8 , 123u8 , 120u8 , 221u8 , 211u8 , 26u8 , 85u8 , 82u8 , 246u8 , 192u8 , 39u8 , 254u8 , 45u8 , 147u8 , 56u8 , 178u8 , 133u8 ,]) } # [doc = "Schedule a named task."] pub fn schedule_named (& self , id : types :: schedule_named :: Id , when : types :: schedule_named :: When , maybe_periodic : types :: schedule_named :: MaybePeriodic , priority : types :: schedule_named :: Priority , call : types :: schedule_named :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ScheduleNamed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "schedule_named" , types :: ScheduleNamed { id , when , maybe_periodic , priority , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [170u8 , 115u8 , 165u8 , 66u8 , 79u8 , 46u8 , 189u8 , 118u8 , 9u8 , 109u8 , 18u8 , 11u8 , 109u8 , 105u8 , 194u8 , 50u8 , 34u8 , 56u8 , 98u8 , 40u8 , 85u8 , 141u8 , 188u8 , 202u8 , 16u8 , 211u8 , 18u8 , 71u8 , 165u8 , 184u8 , 78u8 , 12u8 ,]) } # [doc = "Cancel a named scheduled task."] pub fn cancel_named (& self , id : types :: cancel_named :: Id ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelNamed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "cancel_named" , types :: CancelNamed { id , } , [205u8 , 35u8 , 28u8 , 57u8 , 224u8 , 7u8 , 49u8 , 233u8 , 236u8 , 163u8 , 93u8 , 236u8 , 103u8 , 69u8 , 65u8 , 51u8 , 121u8 , 84u8 , 9u8 , 196u8 , 147u8 , 122u8 , 227u8 , 200u8 , 181u8 , 233u8 , 62u8 , 240u8 , 174u8 , 83u8 , 129u8 , 193u8 ,]) } # [doc = "Anonymously schedule a task after a delay."] pub fn schedule_after (& self , after : types :: schedule_after :: After , maybe_periodic : types :: schedule_after :: MaybePeriodic , priority : types :: schedule_after :: Priority , call : types :: schedule_after :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ScheduleAfter > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "schedule_after" , types :: ScheduleAfter { after , maybe_periodic , priority , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [200u8 , 119u8 , 219u8 , 109u8 , 223u8 , 168u8 , 133u8 , 69u8 , 151u8 , 108u8 , 250u8 , 5u8 , 92u8 , 24u8 , 56u8 , 184u8 , 180u8 , 64u8 , 152u8 , 155u8 , 2u8 , 191u8 , 240u8 , 204u8 , 231u8 , 30u8 , 104u8 , 162u8 , 236u8 , 29u8 , 14u8 , 99u8 ,]) } # [doc = "Schedule a named task after a delay."] pub fn schedule_named_after (& self , id : types :: schedule_named_after :: Id , after : types :: schedule_named_after :: After , maybe_periodic : types :: schedule_named_after :: MaybePeriodic , priority : types :: schedule_named_after :: Priority , call : types :: schedule_named_after :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ScheduleNamedAfter > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "schedule_named_after" , types :: ScheduleNamedAfter { id , after , maybe_periodic , priority , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [63u8 , 204u8 , 185u8 , 118u8 , 246u8 , 196u8 , 19u8 , 128u8 , 175u8 , 153u8 , 104u8 , 228u8 , 181u8 , 74u8 , 171u8 , 91u8 , 23u8 , 162u8 , 192u8 , 109u8 , 59u8 , 0u8 , 211u8 , 162u8 , 56u8 , 156u8 , 194u8 , 69u8 , 24u8 , 192u8 , 107u8 , 162u8 ,]) } # [doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"] # [doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"] # [doc = "succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] pub fn set_retry (& self , task : types :: set_retry :: Task , retries : types :: set_retry :: Retries , period : types :: set_retry :: Period ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetRetry > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "set_retry" , types :: SetRetry { task , retries , period , } , [2u8 , 242u8 , 180u8 , 69u8 , 237u8 , 168u8 , 243u8 , 93u8 , 47u8 , 222u8 , 189u8 , 74u8 , 233u8 , 106u8 , 54u8 , 40u8 , 160u8 , 61u8 , 78u8 , 138u8 , 232u8 , 20u8 , 243u8 , 17u8 , 151u8 , 194u8 , 67u8 , 200u8 , 186u8 , 192u8 , 210u8 , 214u8 ,]) } # [doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"] # [doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"] # [doc = "it succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] pub fn set_retry_named (& self , id : types :: set_retry_named :: Id , retries : types :: set_retry_named :: Retries , period : types :: set_retry_named :: Period ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetRetryNamed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "set_retry_named" , types :: SetRetryNamed { id , retries , period , } , [240u8 , 102u8 , 255u8 , 253u8 , 52u8 , 81u8 , 164u8 , 170u8 , 184u8 , 178u8 , 254u8 , 126u8 , 41u8 , 247u8 , 121u8 , 22u8 , 254u8 , 136u8 , 237u8 , 37u8 , 11u8 , 42u8 , 227u8 , 234u8 , 132u8 , 83u8 , 109u8 , 168u8 , 31u8 , 44u8 , 231u8 , 70u8 ,]) } # [doc = "Removes the retry configuration of a task."] pub fn cancel_retry (& self , task : types :: cancel_retry :: Task ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelRetry > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "cancel_retry" , types :: CancelRetry { task , } , [142u8 , 126u8 , 127u8 , 216u8 , 64u8 , 189u8 , 42u8 , 126u8 , 63u8 , 249u8 , 211u8 , 202u8 , 224u8 , 197u8 , 199u8 , 240u8 , 58u8 , 94u8 , 219u8 , 177u8 , 20u8 , 210u8 , 153u8 , 0u8 , 127u8 , 255u8 , 235u8 , 238u8 , 170u8 , 240u8 , 44u8 , 49u8 ,]) } # [doc = "Cancel the retry configuration of a named task."] pub fn cancel_retry_named (& self , id : types :: cancel_retry_named :: Id ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelRetryNamed > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Scheduler" , "cancel_retry_named" , types :: CancelRetryNamed { id , } , [76u8 , 157u8 , 253u8 , 113u8 , 162u8 , 54u8 , 98u8 , 21u8 , 62u8 , 44u8 , 155u8 , 202u8 , 2u8 , 28u8 , 153u8 , 219u8 , 67u8 , 166u8 , 206u8 , 79u8 , 139u8 , 3u8 , 119u8 , 182u8 , 254u8 , 134u8 , 143u8 , 121u8 , 155u8 , 220u8 , 192u8 , 209u8 ,]) } } } # [doc = "Events type."] pub type Event = runtime_types :: pallet_scheduler :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Scheduled some task."] pub struct Scheduled { pub when : scheduled :: When , pub index : scheduled :: Index , } pub mod scheduled { use super :: runtime_types ; pub type When = :: core :: primitive :: u32 ; pub type Index = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Scheduled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Scheduled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Canceled some task."] pub struct Canceled { pub when : canceled :: When , pub index : canceled :: Index , } pub mod canceled { use super :: runtime_types ; pub type When = :: core :: primitive :: u32 ; pub type Index = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Canceled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Canceled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatched some task."] pub struct Dispatched { pub task : dispatched :: Task , pub id : dispatched :: Id , pub result : dispatched :: Result , } pub mod dispatched { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Dispatched { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Dispatched" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set a retry configuration for some task."] pub struct RetrySet { pub task : retry_set :: Task , pub id : retry_set :: Id , pub period : retry_set :: Period , pub retries : retry_set :: Retries , } pub mod retry_set { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; pub type Period = :: core :: primitive :: u32 ; pub type Retries = :: core :: primitive :: u8 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RetrySet { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "RetrySet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel a retry configuration for some task."] pub struct RetryCancelled { pub task : retry_cancelled :: Task , pub id : retry_cancelled :: Id , } pub mod retry_cancelled { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RetryCancelled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "RetryCancelled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The call for the provided hash was not found so the task has been aborted."] pub struct CallUnavailable { pub task : call_unavailable :: Task , pub id : call_unavailable :: Id , } pub mod call_unavailable { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for CallUnavailable { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "CallUnavailable" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given task was unable to be renewed since the agenda is full at that block."] pub struct PeriodicFailed { pub task : periodic_failed :: Task , pub id : periodic_failed :: Id , } pub mod periodic_failed { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PeriodicFailed { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "PeriodicFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given task was unable to be retried since the agenda is full at that block or there"] # [doc = "was not enough weight to reschedule it."] pub struct RetryFailed { pub task : retry_failed :: Task , pub id : retry_failed :: Id , } pub mod retry_failed { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for RetryFailed { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "RetryFailed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The given task can never be executed since it is overweight."] pub struct PermanentlyOverweight { pub task : permanently_overweight :: Task , pub id : permanently_overweight :: Id , } pub mod permanently_overweight { use super :: runtime_types ; pub type Task = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Id = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for PermanentlyOverweight { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "PermanentlyOverweight" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod incomplete_since { use super :: runtime_types ; pub type IncompleteSince = :: core :: primitive :: u32 ; } pub mod agenda { use super :: runtime_types ; pub type Agenda = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: option :: Option < runtime_types :: pallet_scheduler :: Scheduled < [:: core :: primitive :: u8 ; 32usize] , runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , :: core :: primitive :: u32 , runtime_types :: subspace_runtime :: OriginCaller , :: subxt :: ext :: subxt_core :: utils :: AccountId32 > > > ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod retries { use super :: runtime_types ; pub type Retries = runtime_types :: pallet_scheduler :: RetryConfig < :: core :: primitive :: u32 > ; pub type Param0 = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; } pub mod lookup { use super :: runtime_types ; pub type Lookup = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; pub type Param0 = [:: core :: primitive :: u8 ; 32usize] ; } } pub struct StorageApi ; impl StorageApi { pub fn incomplete_since (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: incomplete_since :: IncompleteSince , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "IncompleteSince" , () , [250u8 , 83u8 , 64u8 , 167u8 , 205u8 , 59u8 , 225u8 , 97u8 , 205u8 , 12u8 , 76u8 , 130u8 , 197u8 , 4u8 , 111u8 , 208u8 , 92u8 , 217u8 , 145u8 , 119u8 , 38u8 , 135u8 , 1u8 , 242u8 , 228u8 , 143u8 , 56u8 , 25u8 , 115u8 , 233u8 , 227u8 , 66u8 ,]) } # [doc = " Items to be executed, indexed by the block number that they should be executed on."] pub fn agenda_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: agenda :: Agenda , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Agenda" , () , [211u8 , 99u8 , 252u8 , 189u8 , 217u8 , 39u8 , 189u8 , 125u8 , 241u8 , 68u8 , 128u8 , 12u8 , 112u8 , 49u8 , 52u8 , 90u8 , 228u8 , 142u8 , 199u8 , 252u8 , 180u8 , 192u8 , 171u8 , 223u8 , 41u8 , 222u8 , 43u8 , 249u8 , 145u8 , 187u8 , 17u8 , 196u8 ,]) } # [doc = " Items to be executed, indexed by the block number that they should be executed on."] pub fn agenda (& self , _0 : types :: agenda :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: agenda :: Param0 > , types :: agenda :: Agenda , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Agenda" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [211u8 , 99u8 , 252u8 , 189u8 , 217u8 , 39u8 , 189u8 , 125u8 , 241u8 , 68u8 , 128u8 , 12u8 , 112u8 , 49u8 , 52u8 , 90u8 , 228u8 , 142u8 , 199u8 , 252u8 , 180u8 , 192u8 , 171u8 , 223u8 , 41u8 , 222u8 , 43u8 , 249u8 , 145u8 , 187u8 , 17u8 , 196u8 ,]) } # [doc = " Retry configurations for items to be executed, indexed by task address."] pub fn retries_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: retries :: Retries , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Retries" , () , [164u8 , 27u8 , 208u8 , 185u8 , 19u8 , 232u8 , 190u8 , 97u8 , 137u8 , 73u8 , 146u8 , 10u8 , 241u8 , 176u8 , 251u8 , 140u8 , 133u8 , 65u8 , 190u8 , 162u8 , 59u8 , 32u8 , 77u8 , 201u8 , 27u8 , 78u8 , 183u8 , 164u8 , 74u8 , 46u8 , 139u8 , 145u8 ,]) } # [doc = " Retry configurations for items to be executed, indexed by task address."] pub fn retries (& self , _0 : types :: retries :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: retries :: Param0 > , types :: retries :: Retries , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Retries" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [164u8 , 27u8 , 208u8 , 185u8 , 19u8 , 232u8 , 190u8 , 97u8 , 137u8 , 73u8 , 146u8 , 10u8 , 241u8 , 176u8 , 251u8 , 140u8 , 133u8 , 65u8 , 190u8 , 162u8 , 59u8 , 32u8 , 77u8 , 201u8 , 27u8 , 78u8 , 183u8 , 164u8 , 74u8 , 46u8 , 139u8 , 145u8 ,]) } # [doc = " Lookup from a name to the block number and index of the task."] # [doc = ""] # [doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"] # [doc = " identities."] pub fn lookup_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: lookup :: Lookup , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Lookup" , () , [24u8 , 87u8 , 96u8 , 127u8 , 136u8 , 205u8 , 238u8 , 174u8 , 71u8 , 110u8 , 65u8 , 98u8 , 228u8 , 167u8 , 99u8 , 71u8 , 171u8 , 186u8 , 12u8 , 218u8 , 137u8 , 70u8 , 70u8 , 228u8 , 153u8 , 111u8 , 165u8 , 114u8 , 229u8 , 136u8 , 118u8 , 131u8 ,]) } # [doc = " Lookup from a name to the block number and index of the task."] # [doc = ""] # [doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"] # [doc = " identities."] pub fn lookup (& self , _0 : types :: lookup :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: lookup :: Param0 > , types :: lookup :: Lookup , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Scheduler" , "Lookup" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [24u8 , 87u8 , 96u8 , 127u8 , 136u8 , 205u8 , 238u8 , 174u8 , 71u8 , 110u8 , 65u8 , 98u8 , 228u8 , 167u8 , 99u8 , 71u8 , 171u8 , 186u8 , 12u8 , 218u8 , 137u8 , 70u8 , 70u8 , 228u8 , 153u8 , 111u8 , 165u8 , 114u8 , 229u8 , 136u8 , 118u8 , 131u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The maximum weight that may be scheduled per block for any dispatchables."] pub fn maximum_weight (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_weights :: weight_v2 :: Weight > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Scheduler" , "MaximumWeight" , [149u8 , 252u8 , 129u8 , 80u8 , 169u8 , 36u8 , 79u8 , 127u8 , 240u8 , 156u8 , 56u8 , 202u8 , 219u8 , 86u8 , 5u8 , 65u8 , 245u8 , 148u8 , 138u8 , 243u8 , 210u8 , 128u8 , 234u8 , 216u8 , 240u8 , 219u8 , 123u8 , 235u8 , 21u8 , 158u8 , 237u8 , 112u8 ,]) } # [doc = " The maximum number of scheduled calls in the queue for a single block."] # [doc = ""] # [doc = " NOTE:"] # [doc = " + Dependent pallets' benchmarks might require a higher limit for the setting. Set a"] # [doc = " higher limit under `runtime-benchmarks` feature."] pub fn max_scheduled_per_block (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Scheduler" , "MaxScheduledPerBlock" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod council { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_collective :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_collective :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "The dispatch of this call must be `SetMembersOrigin`."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] pub struct SetMembers { pub new_members : set_members :: NewMembers , pub prime : set_members :: Prime , pub old_count : set_members :: OldCount , } pub mod set_members { use super :: runtime_types ; pub type NewMembers = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Prime = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type OldCount = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetMembers { const PALLET : & 'static str = "Council" ; const CALL : & 'static str = "set_members" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(B + M + P)` where:"] # [doc = "- `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "- `M` members-count (code-bounded)"] # [doc = "- `P` complexity of dispatching `proposal`"] pub struct Execute { pub proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < execute :: Proposal > , # [codec (compact)] pub length_bound : execute :: LengthBound , } pub mod execute { use super :: runtime_types ; pub type Proposal = runtime_types :: subspace_runtime :: RuntimeCall ; pub type LengthBound = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Execute { const PALLET : & 'static str = "Council" ; const CALL : & 'static str = "execute" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] pub struct Propose { # [codec (compact)] pub threshold : propose :: Threshold , pub proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < propose :: Proposal > , # [codec (compact)] pub length_bound : propose :: LengthBound , } pub mod propose { use super :: runtime_types ; pub type Threshold = :: core :: primitive :: u32 ; pub type Proposal = runtime_types :: subspace_runtime :: RuntimeCall ; pub type LengthBound = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Propose { const PALLET : & 'static str = "Council" ; const CALL : & 'static str = "propose" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "## Complexity"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] pub struct Vote { pub proposal : vote :: Proposal , # [codec (compact)] pub index : vote :: Index , pub approve : vote :: Approve , } pub mod vote { use super :: runtime_types ; pub type Proposal = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Index = :: core :: primitive :: u32 ; pub type Approve = :: core :: primitive :: bool ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Vote { const PALLET : & 'static str = "Council" ; const CALL : & 'static str = "vote" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(P) where P is the number of max proposals"] pub struct DisapproveProposal { pub proposal_hash : disapprove_proposal :: ProposalHash , } pub mod disapprove_proposal { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for DisapproveProposal { const PALLET : & 'static str = "Council" ; const CALL : & 'static str = "disapprove_proposal" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] pub struct Close { pub proposal_hash : close :: ProposalHash , # [codec (compact)] pub index : close :: Index , pub proposal_weight_bound : close :: ProposalWeightBound , # [codec (compact)] pub length_bound : close :: LengthBound , } pub mod close { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Index = :: core :: primitive :: u32 ; pub type ProposalWeightBound = runtime_types :: sp_weights :: weight_v2 :: Weight ; pub type LengthBound = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Close { const PALLET : & 'static str = "Council" ; const CALL : & 'static str = "close" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Disapprove the proposal and burn the cost held for storing this proposal."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: must be the `KillOrigin`."] # [doc = "- `proposal_hash`: The hash of the proposal that should be killed."] # [doc = ""] # [doc = "Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal."] pub struct Kill { pub proposal_hash : kill :: ProposalHash , } pub mod kill { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Kill { const PALLET : & 'static str = "Council" ; const CALL : & 'static str = "kill" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Release the cost held for storing a proposal once the given proposal is completed."] # [doc = ""] # [doc = "If there is no associated cost for the given proposal, this call will have no effect."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: must be `Signed` or `Root`."] # [doc = "- `proposal_hash`: The hash of the proposal."] # [doc = ""] # [doc = "Emits `ProposalCostReleased` if any cost held for a given proposal."] pub struct ReleaseProposalCost { pub proposal_hash : release_proposal_cost :: ProposalHash , } pub mod release_proposal_cost { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ReleaseProposalCost { const PALLET : & 'static str = "Council" ; const CALL : & 'static str = "release_proposal_cost" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "The dispatch of this call must be `SetMembersOrigin`."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] pub fn set_members (& self , new_members : types :: set_members :: NewMembers , prime : types :: set_members :: Prime , old_count : types :: set_members :: OldCount ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetMembers > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Council" , "set_members" , types :: SetMembers { new_members , prime , old_count , } , [66u8 , 224u8 , 186u8 , 178u8 , 41u8 , 208u8 , 67u8 , 192u8 , 57u8 , 242u8 , 141u8 , 31u8 , 216u8 , 118u8 , 192u8 , 43u8 , 125u8 , 213u8 , 226u8 , 85u8 , 142u8 , 225u8 , 131u8 , 45u8 , 172u8 , 142u8 , 12u8 , 9u8 , 73u8 , 7u8 , 218u8 , 61u8 ,]) } # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(B + M + P)` where:"] # [doc = "- `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "- `M` members-count (code-bounded)"] # [doc = "- `P` complexity of dispatching `proposal`"] pub fn execute (& self , proposal : types :: execute :: Proposal , length_bound : types :: execute :: LengthBound ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Execute > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Council" , "execute" , types :: Execute { proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (proposal) , length_bound , } , [160u8 , 127u8 , 203u8 , 40u8 , 40u8 , 171u8 , 95u8 , 115u8 , 44u8 , 31u8 , 172u8 , 193u8 , 133u8 , 84u8 , 236u8 , 72u8 , 4u8 , 238u8 , 13u8 , 48u8 , 56u8 , 74u8 , 246u8 , 120u8 , 128u8 , 32u8 , 253u8 , 230u8 , 151u8 , 164u8 , 155u8 , 64u8 ,]) } # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] pub fn propose (& self , threshold : types :: propose :: Threshold , proposal : types :: propose :: Proposal , length_bound : types :: propose :: LengthBound ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Propose > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Council" , "propose" , types :: Propose { threshold , proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (proposal) , length_bound , } , [249u8 , 148u8 , 12u8 , 235u8 , 254u8 , 30u8 , 170u8 , 222u8 , 42u8 , 241u8 , 236u8 , 186u8 , 234u8 , 135u8 , 50u8 , 171u8 , 225u8 , 18u8 , 93u8 , 136u8 , 79u8 , 219u8 , 6u8 , 155u8 , 108u8 , 97u8 , 217u8 , 88u8 , 209u8 , 165u8 , 59u8 , 23u8 ,]) } # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "## Complexity"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] pub fn vote (& self , proposal : types :: vote :: Proposal , index : types :: vote :: Index , approve : types :: vote :: Approve ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Vote > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Council" , "vote" , types :: Vote { proposal , index , approve , } , [110u8 , 141u8 , 24u8 , 33u8 , 91u8 , 7u8 , 89u8 , 198u8 , 54u8 , 10u8 , 76u8 , 129u8 , 45u8 , 20u8 , 216u8 , 104u8 , 231u8 , 246u8 , 174u8 , 205u8 , 190u8 , 176u8 , 171u8 , 113u8 , 33u8 , 37u8 , 155u8 , 203u8 , 251u8 , 34u8 , 25u8 , 120u8 ,]) } # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(P) where P is the number of max proposals"] pub fn disapprove_proposal (& self , proposal_hash : types :: disapprove_proposal :: ProposalHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: DisapproveProposal > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Council" , "disapprove_proposal" , types :: DisapproveProposal { proposal_hash , } , [26u8 , 140u8 , 111u8 , 193u8 , 229u8 , 59u8 , 53u8 , 196u8 , 230u8 , 60u8 , 7u8 , 155u8 , 168u8 , 7u8 , 201u8 , 177u8 , 70u8 , 103u8 , 190u8 , 57u8 , 244u8 , 156u8 , 67u8 , 101u8 , 228u8 , 6u8 , 213u8 , 83u8 , 225u8 , 95u8 , 148u8 , 96u8 ,]) } # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] pub fn close (& self , proposal_hash : types :: close :: ProposalHash , index : types :: close :: Index , proposal_weight_bound : types :: close :: ProposalWeightBound , length_bound : types :: close :: LengthBound ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Close > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Council" , "close" , types :: Close { proposal_hash , index , proposal_weight_bound , length_bound , } , [136u8 , 48u8 , 243u8 , 34u8 , 60u8 , 109u8 , 186u8 , 158u8 , 72u8 , 48u8 , 62u8 , 34u8 , 167u8 , 46u8 , 33u8 , 142u8 , 239u8 , 43u8 , 238u8 , 125u8 , 94u8 , 80u8 , 157u8 , 245u8 , 220u8 , 126u8 , 58u8 , 244u8 , 186u8 , 195u8 , 30u8 , 127u8 ,]) } # [doc = "Disapprove the proposal and burn the cost held for storing this proposal."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: must be the `KillOrigin`."] # [doc = "- `proposal_hash`: The hash of the proposal that should be killed."] # [doc = ""] # [doc = "Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal."] pub fn kill (& self , proposal_hash : types :: kill :: ProposalHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Kill > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Council" , "kill" , types :: Kill { proposal_hash , } , [190u8 , 209u8 , 250u8 , 180u8 , 66u8 , 156u8 , 159u8 , 253u8 , 174u8 , 70u8 , 121u8 , 156u8 , 70u8 , 240u8 , 46u8 , 219u8 , 85u8 , 172u8 , 136u8 , 193u8 , 225u8 , 172u8 , 157u8 , 22u8 , 195u8 , 10u8 , 101u8 , 40u8 , 57u8 , 34u8 , 108u8 , 206u8 ,]) } # [doc = "Release the cost held for storing a proposal once the given proposal is completed."] # [doc = ""] # [doc = "If there is no associated cost for the given proposal, this call will have no effect."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: must be `Signed` or `Root`."] # [doc = "- `proposal_hash`: The hash of the proposal."] # [doc = ""] # [doc = "Emits `ProposalCostReleased` if any cost held for a given proposal."] pub fn release_proposal_cost (& self , proposal_hash : types :: release_proposal_cost :: ProposalHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ReleaseProposalCost > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Council" , "release_proposal_cost" , types :: ReleaseProposalCost { proposal_hash , } , [66u8 , 154u8 , 93u8 , 101u8 , 111u8 , 62u8 , 246u8 , 128u8 , 240u8 , 32u8 , 120u8 , 79u8 , 20u8 , 151u8 , 136u8 , 144u8 , 106u8 , 8u8 , 114u8 , 204u8 , 163u8 , 80u8 , 129u8 , 124u8 , 50u8 , 49u8 , 61u8 , 159u8 , 79u8 , 221u8 , 199u8 , 220u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_collective :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] pub struct Proposed { pub account : proposed :: Account , pub proposal_index : proposed :: ProposalIndex , pub proposal_hash : proposed :: ProposalHash , pub threshold : proposed :: Threshold , } pub mod proposed { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ProposalIndex = :: core :: primitive :: u32 ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Threshold = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Proposed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] pub struct Voted { pub account : voted :: Account , pub proposal_hash : voted :: ProposalHash , pub voted : voted :: Voted , pub yes : voted :: Yes , pub no : voted :: No , } pub mod voted { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Voted = :: core :: primitive :: bool ; pub type Yes = :: core :: primitive :: u32 ; pub type No = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Voted { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion was approved by the required threshold."] pub struct Approved { pub proposal_hash : approved :: ProposalHash , } pub mod approved { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Approved { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Approved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion was not approved by the required threshold."] pub struct Disapproved { pub proposal_hash : disapproved :: ProposalHash , } pub mod disapproved { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Disapproved { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Disapproved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] pub struct Executed { pub proposal_hash : executed :: ProposalHash , pub result : executed :: Result , } pub mod executed { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Executed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] pub struct MemberExecuted { pub proposal_hash : member_executed :: ProposalHash , pub result : member_executed :: Result , } pub mod member_executed { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MemberExecuted { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "MemberExecuted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] pub struct Closed { pub proposal_hash : closed :: ProposalHash , pub yes : closed :: Yes , pub no : closed :: No , } pub mod closed { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Yes = :: core :: primitive :: u32 ; pub type No = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Closed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Closed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proposal was killed."] pub struct Killed { pub proposal_hash : killed :: ProposalHash , } pub mod killed { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Killed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Killed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some cost for storing a proposal was burned."] pub struct ProposalCostBurned { pub proposal_hash : proposal_cost_burned :: ProposalHash , pub who : proposal_cost_burned :: Who , } pub mod proposal_cost_burned { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ProposalCostBurned { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "ProposalCostBurned" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Some cost for storing a proposal was released."] pub struct ProposalCostReleased { pub proposal_hash : proposal_cost_released :: ProposalHash , pub who : proposal_cost_released :: Who , } pub mod proposal_cost_released { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ProposalCostReleased { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "ProposalCostReleased" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod proposals { use super :: runtime_types ; pub type Proposals = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: ext :: subxt_core :: utils :: H256 > ; } pub mod proposal_of { use super :: runtime_types ; pub type ProposalOf = runtime_types :: subspace_runtime :: RuntimeCall ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod cost_of { use super :: runtime_types ; pub type CostOf = (:: subxt :: ext :: subxt_core :: utils :: AccountId32 , () ,) ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod voting { use super :: runtime_types ; pub type Voting = runtime_types :: pallet_collective :: Votes < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u32 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod proposal_count { use super :: runtime_types ; pub type ProposalCount = :: core :: primitive :: u32 ; } pub mod members { use super :: runtime_types ; pub type Members = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; } pub mod prime { use super :: runtime_types ; pub type Prime = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The hashes of the active proposals."] pub fn proposals (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: proposals :: Proposals , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "Proposals" , () , [210u8 , 234u8 , 7u8 , 29u8 , 231u8 , 80u8 , 17u8 , 36u8 , 189u8 , 34u8 , 175u8 , 147u8 , 56u8 , 92u8 , 201u8 , 104u8 , 207u8 , 150u8 , 58u8 , 110u8 , 90u8 , 28u8 , 198u8 , 79u8 , 236u8 , 245u8 , 19u8 , 38u8 , 68u8 , 59u8 , 215u8 , 74u8 ,]) } # [doc = " Actual proposal for a given hash, if it's current."] pub fn proposal_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: proposal_of :: ProposalOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "ProposalOf" , () , [70u8 , 27u8 , 79u8 , 112u8 , 230u8 , 98u8 , 168u8 , 24u8 , 176u8 , 135u8 , 164u8 , 248u8 , 10u8 , 117u8 , 65u8 , 207u8 , 18u8 , 8u8 , 112u8 , 221u8 , 238u8 , 55u8 , 12u8 , 109u8 , 244u8 , 105u8 , 251u8 , 159u8 , 69u8 , 81u8 , 60u8 , 197u8 ,]) } # [doc = " Actual proposal for a given hash, if it's current."] pub fn proposal_of (& self , _0 : types :: proposal_of :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: proposal_of :: Param0 > , types :: proposal_of :: ProposalOf , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "ProposalOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [70u8 , 27u8 , 79u8 , 112u8 , 230u8 , 98u8 , 168u8 , 24u8 , 176u8 , 135u8 , 164u8 , 248u8 , 10u8 , 117u8 , 65u8 , 207u8 , 18u8 , 8u8 , 112u8 , 221u8 , 238u8 , 55u8 , 12u8 , 109u8 , 244u8 , 105u8 , 251u8 , 159u8 , 69u8 , 81u8 , 60u8 , 197u8 ,]) } # [doc = " Consideration cost created for publishing and storing a proposal."] # [doc = ""] # [doc = " Determined by [Config::Consideration] and may be not present for certain proposals (e.g. if"] # [doc = " the proposal count at the time of creation was below threshold N)."] pub fn cost_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: cost_of :: CostOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "CostOf" , () , [64u8 , 158u8 , 243u8 , 182u8 , 118u8 , 216u8 , 107u8 , 217u8 , 96u8 , 187u8 , 151u8 , 138u8 , 76u8 , 154u8 , 27u8 , 52u8 , 187u8 , 222u8 , 37u8 , 175u8 , 58u8 , 219u8 , 167u8 , 181u8 , 53u8 , 230u8 , 160u8 , 22u8 , 163u8 , 64u8 , 52u8 , 114u8 ,]) } # [doc = " Consideration cost created for publishing and storing a proposal."] # [doc = ""] # [doc = " Determined by [Config::Consideration] and may be not present for certain proposals (e.g. if"] # [doc = " the proposal count at the time of creation was below threshold N)."] pub fn cost_of (& self , _0 : types :: cost_of :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: cost_of :: Param0 > , types :: cost_of :: CostOf , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "CostOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [64u8 , 158u8 , 243u8 , 182u8 , 118u8 , 216u8 , 107u8 , 217u8 , 96u8 , 187u8 , 151u8 , 138u8 , 76u8 , 154u8 , 27u8 , 52u8 , 187u8 , 222u8 , 37u8 , 175u8 , 58u8 , 219u8 , 167u8 , 181u8 , 53u8 , 230u8 , 160u8 , 22u8 , 163u8 , 64u8 , 52u8 , 114u8 ,]) } # [doc = " Votes on a given proposal, if it is ongoing."] pub fn voting_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: voting :: Voting , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "Voting" , () , [109u8 , 198u8 , 2u8 , 13u8 , 29u8 , 14u8 , 241u8 , 217u8 , 55u8 , 147u8 , 147u8 , 4u8 , 176u8 , 69u8 , 132u8 , 228u8 , 158u8 , 203u8 , 110u8 , 239u8 , 158u8 , 137u8 , 97u8 , 46u8 , 228u8 , 118u8 , 251u8 , 201u8 , 88u8 , 208u8 , 94u8 , 132u8 ,]) } # [doc = " Votes on a given proposal, if it is ongoing."] pub fn voting (& self , _0 : types :: voting :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: voting :: Param0 > , types :: voting :: Voting , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "Voting" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [109u8 , 198u8 , 2u8 , 13u8 , 29u8 , 14u8 , 241u8 , 217u8 , 55u8 , 147u8 , 147u8 , 4u8 , 176u8 , 69u8 , 132u8 , 228u8 , 158u8 , 203u8 , 110u8 , 239u8 , 158u8 , 137u8 , 97u8 , 46u8 , 228u8 , 118u8 , 251u8 , 201u8 , 88u8 , 208u8 , 94u8 , 132u8 ,]) } # [doc = " Proposals so far."] pub fn proposal_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: proposal_count :: ProposalCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "ProposalCount" , () , [91u8 , 238u8 , 246u8 , 106u8 , 95u8 , 66u8 , 83u8 , 134u8 , 1u8 , 225u8 , 164u8 , 216u8 , 113u8 , 101u8 , 203u8 , 200u8 , 113u8 , 97u8 , 246u8 , 228u8 , 140u8 , 29u8 , 29u8 , 48u8 , 176u8 , 137u8 , 93u8 , 230u8 , 56u8 , 75u8 , 51u8 , 149u8 ,]) } # [doc = " The current members of the collective. This is stored sorted (just by value)."] pub fn members (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: members :: Members , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "Members" , () , [16u8 , 29u8 , 32u8 , 222u8 , 175u8 , 136u8 , 111u8 , 101u8 , 43u8 , 74u8 , 209u8 , 81u8 , 47u8 , 97u8 , 129u8 , 39u8 , 225u8 , 243u8 , 110u8 , 229u8 , 237u8 , 21u8 , 90u8 , 127u8 , 80u8 , 239u8 , 156u8 , 32u8 , 90u8 , 109u8 , 179u8 , 0u8 ,]) } # [doc = " The prime member that helps determine the default vote behavior in case of abstentions."] pub fn prime (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: prime :: Prime , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Council" , "Prime" , () , [72u8 , 128u8 , 214u8 , 72u8 , 78u8 , 80u8 , 100u8 , 198u8 , 114u8 , 215u8 , 59u8 , 3u8 , 103u8 , 14u8 , 152u8 , 202u8 , 12u8 , 165u8 , 224u8 , 10u8 , 41u8 , 154u8 , 77u8 , 95u8 , 116u8 , 143u8 , 250u8 , 250u8 , 176u8 , 92u8 , 238u8 , 154u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The maximum weight of a dispatch call that can be proposed and executed."] pub fn max_proposal_weight (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < runtime_types :: sp_weights :: weight_v2 :: Weight > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Council" , "MaxProposalWeight" , [149u8 , 252u8 , 129u8 , 80u8 , 169u8 , 36u8 , 79u8 , 127u8 , 240u8 , 156u8 , 56u8 , 202u8 , 219u8 , 86u8 , 5u8 , 65u8 , 245u8 , 148u8 , 138u8 , 243u8 , 210u8 , 128u8 , 234u8 , 216u8 , 240u8 , 219u8 , 123u8 , 235u8 , 21u8 , 158u8 , 237u8 , 112u8 ,]) } } } } pub mod democracy { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_democracy :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_democracy :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Propose a sensitive action to be taken."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender must"] # [doc = "have funds to cover the deposit."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the proposal preimage."] # [doc = "- `value`: The amount of deposit (must be at least `MinimumDeposit`)."] # [doc = ""] # [doc = "Emits `Proposed`."] pub struct Propose { pub proposal : propose :: Proposal , # [codec (compact)] pub value : propose :: Value , } pub mod propose { use super :: runtime_types ; pub type Proposal = runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > ; pub type Value = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Propose { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "propose" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Signals agreement with a particular proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender"] # [doc = "must have funds to cover the deposit, equal to the original deposit."] # [doc = ""] # [doc = "- `proposal`: The index of the proposal to second."] pub struct Second { # [codec (compact)] pub proposal : second :: Proposal , } pub mod second { use super :: runtime_types ; pub type Proposal = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Second { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "second" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;"] # [doc = "otherwise it is a vote to keep the status quo."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to vote for."] # [doc = "- `vote`: The vote configuration."] pub struct Vote { # [codec (compact)] pub ref_index : vote :: RefIndex , pub vote : vote :: Vote , } pub mod vote { use super :: runtime_types ; pub type RefIndex = :: core :: primitive :: u32 ; pub type Vote = runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Vote { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "vote" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule an emergency cancellation of a referendum. Cannot happen twice to the same"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancellationOrigin`."] # [doc = ""] # [doc = "-`ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(1)`."] pub struct EmergencyCancel { pub ref_index : emergency_cancel :: RefIndex , } pub mod emergency_cancel { use super :: runtime_types ; pub type RefIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for EmergencyCancel { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "emergency_cancel" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule a referendum to be tabled once it is legal to schedule an external"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `ExternalOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] pub struct ExternalPropose { pub proposal : external_propose :: Proposal , } pub mod external_propose { use super :: runtime_types ; pub type Proposal = runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ExternalPropose { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "external_propose" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule a majority-carries referendum to be tabled next once it is legal to schedule"] # [doc = "an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalMajorityOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub struct ExternalProposeMajority { pub proposal : external_propose_majority :: Proposal , } pub mod external_propose_majority { use super :: runtime_types ; pub type Proposal = runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ExternalProposeMajority { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "external_propose_majority" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule a negative-turnout-bias referendum to be tabled next once it is legal to"] # [doc = "schedule an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalDefaultOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub struct ExternalProposeDefault { pub proposal : external_propose_default :: Proposal , } pub mod external_propose_default { use super :: runtime_types ; pub type Proposal = runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ExternalProposeDefault { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "external_propose_default" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Schedule the currently externally-proposed majority-carries referendum to be tabled"] # [doc = "immediately. If there is no externally-proposed referendum currently, or if there is one"] # [doc = "but it is not a majority-carries referendum then it fails."] # [doc = ""] # [doc = "The dispatch of this call must be `FastTrackOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the current external proposal."] # [doc = "- `voting_period`: The period that is allowed for voting on this proposal. Increased to"] # [doc = "\tMust be always greater than zero."] # [doc = "\tFor `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`."] # [doc = "- `delay`: The number of block after voting has ended in approval and this should be"] # [doc = "  enacted. This doesn't have a minimum amount."] # [doc = ""] # [doc = "Emits `Started`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub struct FastTrack { pub proposal_hash : fast_track :: ProposalHash , pub voting_period : fast_track :: VotingPeriod , pub delay : fast_track :: Delay , } pub mod fast_track { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type VotingPeriod = :: core :: primitive :: u32 ; pub type Delay = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for FastTrack { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "fast_track" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Veto and blacklist the external proposal hash."] # [doc = ""] # [doc = "The dispatch origin of this call must be `VetoOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal to veto and blacklist."] # [doc = ""] # [doc = "Emits `Vetoed`."] # [doc = ""] # [doc = "Weight: `O(V + log(V))` where V is number of `existing vetoers`"] pub struct VetoExternal { pub proposal_hash : veto_external :: ProposalHash , } pub mod veto_external { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for VetoExternal { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "veto_external" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove a referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "# Weight: `O(1)`."] pub struct CancelReferendum { # [codec (compact)] pub ref_index : cancel_referendum :: RefIndex , } pub mod cancel_referendum { use super :: runtime_types ; pub type RefIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelReferendum { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "cancel_referendum" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Delegate the voting power (with some given conviction) of the sending account."] # [doc = ""] # [doc = "The balance delegated is locked for as long as it's delegated, and thereafter for the"] # [doc = "time appropriate for the conviction's lock period."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signing account must either:"] # [doc = "  - be delegating already; or"] # [doc = "  - have no voting activity (if there is, then it will need to be removed/consolidated"] # [doc = "    through `reap_vote` or `unvote`)."] # [doc = ""] # [doc = "- `to`: The account whose voting the `target` account's voting power will follow."] # [doc = "- `conviction`: The conviction that will be attached to the delegated votes. When the"] # [doc = "  account is undelegated, the funds will be locked for the corresponding period."] # [doc = "- `balance`: The amount of the account's balance to be used in delegating. This must not"] # [doc = "  be more than the account's current balance."] # [doc = ""] # [doc = "Emits `Delegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] pub struct Delegate { pub to : delegate :: To , pub conviction : delegate :: Conviction , pub balance : delegate :: Balance , } pub mod delegate { use super :: runtime_types ; pub type To = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Conviction = runtime_types :: pallet_democracy :: conviction :: Conviction ; pub type Balance = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Delegate { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "delegate" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Undelegate the voting power of the sending account."] # [doc = ""] # [doc = "Tokens may be unlocked following once an amount of time consistent with the lock period"] # [doc = "of the conviction with which the delegation was issued."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the signing account must be"] # [doc = "currently delegating."] # [doc = ""] # [doc = "Emits `Undelegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] pub struct Undelegate ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Undelegate { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "undelegate" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Clears all public proposals."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "Weight: `O(1)`."] pub struct ClearPublicProposals ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ClearPublicProposals { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "clear_public_proposals" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Unlock tokens that have an expired lock."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account to remove the lock on."] # [doc = ""] # [doc = "Weight: `O(R)` with R number of vote of target."] pub struct Unlock { pub target : unlock :: Target , } pub mod unlock { use super :: runtime_types ; pub type Target = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Unlock { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "unlock" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If:"] # [doc = "- the referendum was cancelled, or"] # [doc = "- the referendum is ongoing, or"] # [doc = "- the referendum has ended such that"] # [doc = "  - the vote of the account was in opposition to the result; or"] # [doc = "  - there was no conviction to the account's vote; or"] # [doc = "  - the account made a split vote"] # [doc = "...then the vote is removed cleanly and a following call to `unlock` may result in more"] # [doc = "funds being available."] # [doc = ""] # [doc = "If, however, the referendum has ended and:"] # [doc = "- it finished corresponding to the vote of the account, and"] # [doc = "- the account made a standard vote with conviction, and"] # [doc = "- the lock period of the conviction is not over"] # [doc = "...then the lock will be aggregated into the overall account's lock, which may involve"] # [doc = "*overlocking* (where the two locks are combined into a single lock that is the maximum"] # [doc = "of both the amount locked and the time is it locked for)."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signer must have a vote"] # [doc = "registered for referendum `index`."] # [doc = ""] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] pub struct RemoveVote { pub index : remove_vote :: Index , } pub mod remove_vote { use super :: runtime_types ; pub type Index = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveVote { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "remove_vote" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If the `target` is equal to the signer, then this function is exactly equivalent to"] # [doc = "`remove_vote`. If not equal to the signer, then the vote must have expired,"] # [doc = "either because the referendum was cancelled, because the voter lost the referendum or"] # [doc = "because the conviction period is over."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account of the vote to be removed; this account must have voted for"] # [doc = "  referendum `index`."] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] pub struct RemoveOtherVote { pub target : remove_other_vote :: Target , pub index : remove_other_vote :: Index , } pub mod remove_other_vote { use super :: runtime_types ; pub type Target = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Index = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveOtherVote { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "remove_other_vote" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Permanently place a proposal into the blacklist. This prevents it from ever being"] # [doc = "proposed again."] # [doc = ""] # [doc = "If called on a queued public or external proposal, then this will result in it being"] # [doc = "removed. If the `ref_index` supplied is an active referendum with the proposal hash,"] # [doc = "then it will be cancelled."] # [doc = ""] # [doc = "The dispatch origin of this call must be `BlacklistOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The proposal hash to blacklist permanently."] # [doc = "- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be"] # [doc = "cancelled."] # [doc = ""] # [doc = "Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a"] # [doc = "  reasonable value)."] pub struct Blacklist { pub proposal_hash : blacklist :: ProposalHash , pub maybe_ref_index : blacklist :: MaybeRefIndex , } pub mod blacklist { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type MaybeRefIndex = :: core :: option :: Option < :: core :: primitive :: u32 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Blacklist { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "blacklist" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Remove a proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancelProposalOrigin`."] # [doc = ""] # [doc = "- `prop_index`: The index of the proposal to cancel."] # [doc = ""] # [doc = "Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"] pub struct CancelProposal { # [codec (compact)] pub prop_index : cancel_proposal :: PropIndex , } pub mod cancel_proposal { use super :: runtime_types ; pub type PropIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelProposal { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "cancel_proposal" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Set or clear a metadata of a proposal or a referendum."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: Must correspond to the `MetadataOwner`."] # [doc = "    - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`"] # [doc = "      threshold."] # [doc = "    - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`"] # [doc = "      threshold."] # [doc = "    - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`"] # [doc = "      threshold."] # [doc = "    - `Signed` by a creator for a public proposal."] # [doc = "    - `Signed` to clear a metadata for a finished referendum."] # [doc = "    - `Root` to set a metadata for an ongoing referendum."] # [doc = "- `owner`: an identifier of a metadata owner."] # [doc = "- `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata."] pub struct SetMetadata { pub owner : set_metadata :: Owner , pub maybe_hash : set_metadata :: MaybeHash , } pub mod set_metadata { use super :: runtime_types ; pub type Owner = runtime_types :: pallet_democracy :: types :: MetadataOwner ; pub type MaybeHash = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: H256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetMetadata { const PALLET : & 'static str = "Democracy" ; const CALL : & 'static str = "set_metadata" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Propose a sensitive action to be taken."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender must"] # [doc = "have funds to cover the deposit."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the proposal preimage."] # [doc = "- `value`: The amount of deposit (must be at least `MinimumDeposit`)."] # [doc = ""] # [doc = "Emits `Proposed`."] pub fn propose (& self , proposal : types :: propose :: Proposal , value : types :: propose :: Value ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Propose > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "propose" , types :: Propose { proposal , value , } , [164u8 , 45u8 , 183u8 , 137u8 , 222u8 , 27u8 , 138u8 , 45u8 , 20u8 , 18u8 , 234u8 , 211u8 , 52u8 , 184u8 , 234u8 , 222u8 , 193u8 , 9u8 , 160u8 , 58u8 , 198u8 , 106u8 , 236u8 , 210u8 , 172u8 , 34u8 , 194u8 , 107u8 , 135u8 , 83u8 , 22u8 , 238u8 ,]) } # [doc = "Signals agreement with a particular proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender"] # [doc = "must have funds to cover the deposit, equal to the original deposit."] # [doc = ""] # [doc = "- `proposal`: The index of the proposal to second."] pub fn second (& self , proposal : types :: second :: Proposal ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Second > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "second" , types :: Second { proposal , } , [195u8 , 55u8 , 178u8 , 55u8 , 129u8 , 64u8 , 10u8 , 131u8 , 217u8 , 79u8 , 1u8 , 187u8 , 73u8 , 126u8 , 191u8 , 221u8 , 110u8 , 10u8 , 13u8 , 65u8 , 190u8 , 107u8 , 21u8 , 236u8 , 175u8 , 130u8 , 227u8 , 179u8 , 173u8 , 39u8 , 32u8 , 147u8 ,]) } # [doc = "Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;"] # [doc = "otherwise it is a vote to keep the status quo."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to vote for."] # [doc = "- `vote`: The vote configuration."] pub fn vote (& self , ref_index : types :: vote :: RefIndex , vote : types :: vote :: Vote ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Vote > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "vote" , types :: Vote { ref_index , vote , } , [106u8 , 195u8 , 229u8 , 44u8 , 217u8 , 214u8 , 8u8 , 234u8 , 175u8 , 62u8 , 97u8 , 83u8 , 193u8 , 180u8 , 103u8 , 26u8 , 174u8 , 8u8 , 2u8 , 158u8 , 25u8 , 122u8 , 203u8 , 122u8 , 32u8 , 14u8 , 107u8 , 169u8 , 43u8 , 240u8 , 143u8 , 103u8 ,]) } # [doc = "Schedule an emergency cancellation of a referendum. Cannot happen twice to the same"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancellationOrigin`."] # [doc = ""] # [doc = "-`ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(1)`."] pub fn emergency_cancel (& self , ref_index : types :: emergency_cancel :: RefIndex ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: EmergencyCancel > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "emergency_cancel" , types :: EmergencyCancel { ref_index , } , [82u8 , 232u8 , 19u8 , 158u8 , 88u8 , 69u8 , 96u8 , 225u8 , 106u8 , 253u8 , 6u8 , 136u8 , 87u8 , 0u8 , 68u8 , 128u8 , 122u8 , 16u8 , 107u8 , 76u8 , 209u8 , 14u8 , 230u8 , 49u8 , 228u8 , 100u8 , 187u8 , 10u8 , 76u8 , 71u8 , 197u8 , 72u8 ,]) } # [doc = "Schedule a referendum to be tabled once it is legal to schedule an external"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `ExternalOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] pub fn external_propose (& self , proposal : types :: external_propose :: Proposal ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ExternalPropose > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "external_propose" , types :: ExternalPropose { proposal , } , [99u8 , 120u8 , 61u8 , 124u8 , 244u8 , 68u8 , 12u8 , 240u8 , 11u8 , 168u8 , 4u8 , 50u8 , 19u8 , 152u8 , 255u8 , 97u8 , 20u8 , 195u8 , 141u8 , 199u8 , 31u8 , 250u8 , 222u8 , 136u8 , 47u8 , 162u8 , 0u8 , 32u8 , 215u8 , 110u8 , 94u8 , 109u8 ,]) } # [doc = "Schedule a majority-carries referendum to be tabled next once it is legal to schedule"] # [doc = "an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalMajorityOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn external_propose_majority (& self , proposal : types :: external_propose_majority :: Proposal ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ExternalProposeMajority > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "external_propose_majority" , types :: ExternalProposeMajority { proposal , } , [35u8 , 61u8 , 130u8 , 81u8 , 81u8 , 180u8 , 127u8 , 202u8 , 67u8 , 84u8 , 105u8 , 113u8 , 112u8 , 210u8 , 1u8 , 191u8 , 10u8 , 39u8 , 157u8 , 164u8 , 9u8 , 231u8 , 75u8 , 25u8 , 17u8 , 175u8 , 128u8 , 180u8 , 238u8 , 58u8 , 236u8 , 214u8 ,]) } # [doc = "Schedule a negative-turnout-bias referendum to be tabled next once it is legal to"] # [doc = "schedule an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalDefaultOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn external_propose_default (& self , proposal : types :: external_propose_default :: Proposal ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ExternalProposeDefault > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "external_propose_default" , types :: ExternalProposeDefault { proposal , } , [136u8 , 199u8 , 244u8 , 69u8 , 5u8 , 174u8 , 166u8 , 251u8 , 102u8 , 196u8 , 25u8 , 6u8 , 33u8 , 216u8 , 141u8 , 78u8 , 118u8 , 125u8 , 128u8 , 218u8 , 120u8 , 170u8 , 166u8 , 15u8 , 124u8 , 216u8 , 128u8 , 178u8 , 5u8 , 74u8 , 170u8 , 25u8 ,]) } # [doc = "Schedule the currently externally-proposed majority-carries referendum to be tabled"] # [doc = "immediately. If there is no externally-proposed referendum currently, or if there is one"] # [doc = "but it is not a majority-carries referendum then it fails."] # [doc = ""] # [doc = "The dispatch of this call must be `FastTrackOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the current external proposal."] # [doc = "- `voting_period`: The period that is allowed for voting on this proposal. Increased to"] # [doc = "\tMust be always greater than zero."] # [doc = "\tFor `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`."] # [doc = "- `delay`: The number of block after voting has ended in approval and this should be"] # [doc = "  enacted. This doesn't have a minimum amount."] # [doc = ""] # [doc = "Emits `Started`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn fast_track (& self , proposal_hash : types :: fast_track :: ProposalHash , voting_period : types :: fast_track :: VotingPeriod , delay : types :: fast_track :: Delay ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: FastTrack > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "fast_track" , types :: FastTrack { proposal_hash , voting_period , delay , } , [96u8 , 201u8 , 216u8 , 109u8 , 4u8 , 244u8 , 52u8 , 237u8 , 120u8 , 234u8 , 30u8 , 102u8 , 186u8 , 132u8 , 214u8 , 22u8 , 40u8 , 75u8 , 118u8 , 23u8 , 56u8 , 68u8 , 192u8 , 129u8 , 74u8 , 61u8 , 247u8 , 98u8 , 103u8 , 127u8 , 200u8 , 171u8 ,]) } # [doc = "Veto and blacklist the external proposal hash."] # [doc = ""] # [doc = "The dispatch origin of this call must be `VetoOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal to veto and blacklist."] # [doc = ""] # [doc = "Emits `Vetoed`."] # [doc = ""] # [doc = "Weight: `O(V + log(V))` where V is number of `existing vetoers`"] pub fn veto_external (& self , proposal_hash : types :: veto_external :: ProposalHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: VetoExternal > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "veto_external" , types :: VetoExternal { proposal_hash , } , [121u8 , 217u8 , 249u8 , 134u8 , 45u8 , 19u8 , 126u8 , 166u8 , 218u8 , 223u8 , 165u8 , 124u8 , 162u8 , 59u8 , 56u8 , 200u8 , 227u8 , 125u8 , 23u8 , 133u8 , 196u8 , 93u8 , 210u8 , 15u8 , 39u8 , 26u8 , 58u8 , 236u8 , 9u8 , 101u8 , 202u8 , 168u8 ,]) } # [doc = "Remove a referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "# Weight: `O(1)`."] pub fn cancel_referendum (& self , ref_index : types :: cancel_referendum :: RefIndex ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelReferendum > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "cancel_referendum" , types :: CancelReferendum { ref_index , } , [149u8 , 120u8 , 70u8 , 20u8 , 126u8 , 21u8 , 30u8 , 33u8 , 82u8 , 124u8 , 229u8 , 179u8 , 169u8 , 243u8 , 173u8 , 146u8 , 140u8 , 22u8 , 124u8 , 154u8 , 228u8 , 117u8 , 109u8 , 88u8 , 11u8 , 100u8 , 235u8 , 243u8 , 118u8 , 99u8 , 250u8 , 140u8 ,]) } # [doc = "Delegate the voting power (with some given conviction) of the sending account."] # [doc = ""] # [doc = "The balance delegated is locked for as long as it's delegated, and thereafter for the"] # [doc = "time appropriate for the conviction's lock period."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signing account must either:"] # [doc = "  - be delegating already; or"] # [doc = "  - have no voting activity (if there is, then it will need to be removed/consolidated"] # [doc = "    through `reap_vote` or `unvote`)."] # [doc = ""] # [doc = "- `to`: The account whose voting the `target` account's voting power will follow."] # [doc = "- `conviction`: The conviction that will be attached to the delegated votes. When the"] # [doc = "  account is undelegated, the funds will be locked for the corresponding period."] # [doc = "- `balance`: The amount of the account's balance to be used in delegating. This must not"] # [doc = "  be more than the account's current balance."] # [doc = ""] # [doc = "Emits `Delegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] pub fn delegate (& self , to : types :: delegate :: To , conviction : types :: delegate :: Conviction , balance : types :: delegate :: Balance ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Delegate > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "delegate" , types :: Delegate { to , conviction , balance , } , [98u8 , 120u8 , 223u8 , 48u8 , 181u8 , 91u8 , 232u8 , 157u8 , 124u8 , 249u8 , 137u8 , 195u8 , 211u8 , 199u8 , 173u8 , 118u8 , 164u8 , 196u8 , 253u8 , 53u8 , 214u8 , 120u8 , 138u8 , 7u8 , 129u8 , 85u8 , 217u8 , 172u8 , 98u8 , 78u8 , 165u8 , 37u8 ,]) } # [doc = "Undelegate the voting power of the sending account."] # [doc = ""] # [doc = "Tokens may be unlocked following once an amount of time consistent with the lock period"] # [doc = "of the conviction with which the delegation was issued."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the signing account must be"] # [doc = "currently delegating."] # [doc = ""] # [doc = "Emits `Undelegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] pub fn undelegate (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Undelegate > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "undelegate" , types :: Undelegate { } , [225u8 , 156u8 , 102u8 , 1u8 , 172u8 , 145u8 , 88u8 , 12u8 , 89u8 , 32u8 , 51u8 , 83u8 , 25u8 , 149u8 , 132u8 , 203u8 , 246u8 , 98u8 , 155u8 , 36u8 , 165u8 , 206u8 , 233u8 , 169u8 , 91u8 , 85u8 , 105u8 , 67u8 , 46u8 , 134u8 , 244u8 , 250u8 ,]) } # [doc = "Clears all public proposals."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "Weight: `O(1)`."] pub fn clear_public_proposals (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ClearPublicProposals > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "clear_public_proposals" , types :: ClearPublicProposals { } , [116u8 , 160u8 , 246u8 , 216u8 , 23u8 , 188u8 , 144u8 , 63u8 , 97u8 , 198u8 , 11u8 , 243u8 , 165u8 , 84u8 , 159u8 , 153u8 , 235u8 , 169u8 , 166u8 , 15u8 , 23u8 , 116u8 , 30u8 , 56u8 , 133u8 , 31u8 , 158u8 , 114u8 , 158u8 , 86u8 , 106u8 , 93u8 ,]) } # [doc = "Unlock tokens that have an expired lock."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account to remove the lock on."] # [doc = ""] # [doc = "Weight: `O(R)` with R number of vote of target."] pub fn unlock (& self , target : types :: unlock :: Target ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Unlock > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "unlock" , types :: Unlock { target , } , [168u8 , 111u8 , 199u8 , 137u8 , 136u8 , 162u8 , 69u8 , 122u8 , 130u8 , 226u8 , 234u8 , 79u8 , 214u8 , 164u8 , 127u8 , 217u8 , 140u8 , 10u8 , 116u8 , 94u8 , 5u8 , 58u8 , 208u8 , 255u8 , 136u8 , 147u8 , 148u8 , 133u8 , 136u8 , 206u8 , 219u8 , 94u8 ,]) } # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If:"] # [doc = "- the referendum was cancelled, or"] # [doc = "- the referendum is ongoing, or"] # [doc = "- the referendum has ended such that"] # [doc = "  - the vote of the account was in opposition to the result; or"] # [doc = "  - there was no conviction to the account's vote; or"] # [doc = "  - the account made a split vote"] # [doc = "...then the vote is removed cleanly and a following call to `unlock` may result in more"] # [doc = "funds being available."] # [doc = ""] # [doc = "If, however, the referendum has ended and:"] # [doc = "- it finished corresponding to the vote of the account, and"] # [doc = "- the account made a standard vote with conviction, and"] # [doc = "- the lock period of the conviction is not over"] # [doc = "...then the lock will be aggregated into the overall account's lock, which may involve"] # [doc = "*overlocking* (where the two locks are combined into a single lock that is the maximum"] # [doc = "of both the amount locked and the time is it locked for)."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signer must have a vote"] # [doc = "registered for referendum `index`."] # [doc = ""] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] pub fn remove_vote (& self , index : types :: remove_vote :: Index ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveVote > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "remove_vote" , types :: RemoveVote { index , } , [98u8 , 146u8 , 215u8 , 63u8 , 222u8 , 70u8 , 61u8 , 186u8 , 90u8 , 34u8 , 63u8 , 25u8 , 195u8 , 119u8 , 228u8 , 189u8 , 38u8 , 163u8 , 58u8 , 210u8 , 216u8 , 156u8 , 20u8 , 204u8 , 136u8 , 192u8 , 33u8 , 210u8 , 124u8 , 65u8 , 153u8 , 105u8 ,]) } # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If the `target` is equal to the signer, then this function is exactly equivalent to"] # [doc = "`remove_vote`. If not equal to the signer, then the vote must have expired,"] # [doc = "either because the referendum was cancelled, because the voter lost the referendum or"] # [doc = "because the conviction period is over."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account of the vote to be removed; this account must have voted for"] # [doc = "  referendum `index`."] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] pub fn remove_other_vote (& self , target : types :: remove_other_vote :: Target , index : types :: remove_other_vote :: Index ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveOtherVote > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "remove_other_vote" , types :: RemoveOtherVote { target , index , } , [144u8 , 81u8 , 115u8 , 108u8 , 30u8 , 235u8 , 166u8 , 115u8 , 147u8 , 56u8 , 144u8 , 196u8 , 252u8 , 166u8 , 201u8 , 131u8 , 0u8 , 193u8 , 21u8 , 234u8 , 55u8 , 253u8 , 165u8 , 149u8 , 38u8 , 47u8 , 241u8 , 140u8 , 186u8 , 139u8 , 227u8 , 165u8 ,]) } # [doc = "Permanently place a proposal into the blacklist. This prevents it from ever being"] # [doc = "proposed again."] # [doc = ""] # [doc = "If called on a queued public or external proposal, then this will result in it being"] # [doc = "removed. If the `ref_index` supplied is an active referendum with the proposal hash,"] # [doc = "then it will be cancelled."] # [doc = ""] # [doc = "The dispatch origin of this call must be `BlacklistOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The proposal hash to blacklist permanently."] # [doc = "- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be"] # [doc = "cancelled."] # [doc = ""] # [doc = "Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a"] # [doc = "  reasonable value)."] pub fn blacklist (& self , proposal_hash : types :: blacklist :: ProposalHash , maybe_ref_index : types :: blacklist :: MaybeRefIndex ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Blacklist > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "blacklist" , types :: Blacklist { proposal_hash , maybe_ref_index , } , [227u8 , 200u8 , 88u8 , 154u8 , 134u8 , 121u8 , 131u8 , 177u8 , 94u8 , 119u8 , 12u8 , 129u8 , 150u8 , 59u8 , 108u8 , 103u8 , 109u8 , 55u8 , 220u8 , 211u8 , 250u8 , 103u8 , 160u8 , 170u8 , 63u8 , 142u8 , 112u8 , 244u8 , 29u8 , 238u8 , 101u8 , 24u8 ,]) } # [doc = "Remove a proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancelProposalOrigin`."] # [doc = ""] # [doc = "- `prop_index`: The index of the proposal to cancel."] # [doc = ""] # [doc = "Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"] pub fn cancel_proposal (& self , prop_index : types :: cancel_proposal :: PropIndex ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelProposal > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "cancel_proposal" , types :: CancelProposal { prop_index , } , [213u8 , 5u8 , 215u8 , 209u8 , 71u8 , 229u8 , 66u8 , 38u8 , 171u8 , 38u8 , 14u8 , 103u8 , 248u8 , 176u8 , 217u8 , 143u8 , 234u8 , 89u8 , 110u8 , 250u8 , 3u8 , 190u8 , 151u8 , 74u8 , 55u8 , 58u8 , 249u8 , 138u8 , 25u8 , 191u8 , 55u8 , 142u8 ,]) } # [doc = "Set or clear a metadata of a proposal or a referendum."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: Must correspond to the `MetadataOwner`."] # [doc = "    - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`"] # [doc = "      threshold."] # [doc = "    - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`"] # [doc = "      threshold."] # [doc = "    - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`"] # [doc = "      threshold."] # [doc = "    - `Signed` by a creator for a public proposal."] # [doc = "    - `Signed` to clear a metadata for a finished referendum."] # [doc = "    - `Root` to set a metadata for an ongoing referendum."] # [doc = "- `owner`: an identifier of a metadata owner."] # [doc = "- `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata."] pub fn set_metadata (& self , owner : types :: set_metadata :: Owner , maybe_hash : types :: set_metadata :: MaybeHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetMetadata > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Democracy" , "set_metadata" , types :: SetMetadata { owner , maybe_hash , } , [191u8 , 200u8 , 139u8 , 27u8 , 167u8 , 250u8 , 72u8 , 78u8 , 18u8 , 98u8 , 108u8 , 1u8 , 122u8 , 120u8 , 47u8 , 77u8 , 174u8 , 60u8 , 247u8 , 69u8 , 228u8 , 196u8 , 149u8 , 107u8 , 239u8 , 45u8 , 47u8 , 118u8 , 87u8 , 233u8 , 79u8 , 29u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_democracy :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A motion has been proposed by a public account."] pub struct Proposed { pub proposal_index : proposed :: ProposalIndex , pub deposit : proposed :: Deposit , } pub mod proposed { use super :: runtime_types ; pub type ProposalIndex = :: core :: primitive :: u32 ; pub type Deposit = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Proposed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A public proposal has been tabled for referendum vote."] pub struct Tabled { pub proposal_index : tabled :: ProposalIndex , pub deposit : tabled :: Deposit , } pub mod tabled { use super :: runtime_types ; pub type ProposalIndex = :: core :: primitive :: u32 ; pub type Deposit = :: core :: primitive :: u128 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Tabled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Tabled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An external proposal has been tabled."] pub struct ExternalTabled ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ExternalTabled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "ExternalTabled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A referendum has begun."] pub struct Started { pub ref_index : started :: RefIndex , pub threshold : started :: Threshold , } pub mod started { use super :: runtime_types ; pub type RefIndex = :: core :: primitive :: u32 ; pub type Threshold = runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Started { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Started" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proposal has been approved by referendum."] pub struct Passed { pub ref_index : passed :: RefIndex , } pub mod passed { use super :: runtime_types ; pub type RefIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Passed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Passed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proposal has been rejected by referendum."] pub struct NotPassed { pub ref_index : not_passed :: RefIndex , } pub mod not_passed { use super :: runtime_types ; pub type RefIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NotPassed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "NotPassed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A referendum has been cancelled."] pub struct Cancelled { pub ref_index : cancelled :: RefIndex , } pub mod cancelled { use super :: runtime_types ; pub type RefIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Cancelled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Cancelled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account has delegated their vote to another account."] pub struct Delegated { pub who : delegated :: Who , pub target : delegated :: Target , } pub mod delegated { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Target = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Delegated { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Delegated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account has cancelled a previous delegation operation."] pub struct Undelegated { pub account : undelegated :: Account , } pub mod undelegated { use super :: runtime_types ; pub type Account = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Undelegated { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Undelegated" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An external proposal has been vetoed."] pub struct Vetoed { pub who : vetoed :: Who , pub proposal_hash : vetoed :: ProposalHash , pub until : vetoed :: Until , } pub mod vetoed { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Until = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Vetoed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Vetoed" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proposal_hash has been blacklisted permanently."] pub struct Blacklisted { pub proposal_hash : blacklisted :: ProposalHash , } pub mod blacklisted { use super :: runtime_types ; pub type ProposalHash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Blacklisted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Blacklisted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account has voted in a referendum"] pub struct Voted { pub voter : voted :: Voter , pub ref_index : voted :: RefIndex , pub vote : voted :: Vote , } pub mod voted { use super :: runtime_types ; pub type Voter = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type RefIndex = :: core :: primitive :: u32 ; pub type Vote = runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Voted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "An account has seconded a proposal"] pub struct Seconded { pub seconder : seconded :: Seconder , pub prop_index : seconded :: PropIndex , } pub mod seconded { use super :: runtime_types ; pub type Seconder = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type PropIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Seconded { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Seconded" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A proposal got canceled."] pub struct ProposalCanceled { pub prop_index : proposal_canceled :: PropIndex , } pub mod proposal_canceled { use super :: runtime_types ; pub type PropIndex = :: core :: primitive :: u32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for ProposalCanceled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "ProposalCanceled" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Metadata for a proposal or a referendum has been set."] pub struct MetadataSet { pub owner : metadata_set :: Owner , pub hash : metadata_set :: Hash , } pub mod metadata_set { use super :: runtime_types ; pub type Owner = runtime_types :: pallet_democracy :: types :: MetadataOwner ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MetadataSet { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "MetadataSet" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Metadata for a proposal or a referendum has been cleared."] pub struct MetadataCleared { pub owner : metadata_cleared :: Owner , pub hash : metadata_cleared :: Hash , } pub mod metadata_cleared { use super :: runtime_types ; pub type Owner = runtime_types :: pallet_democracy :: types :: MetadataOwner ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MetadataCleared { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "MetadataCleared" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Metadata has been transferred to new owner."] pub struct MetadataTransferred { pub prev_owner : metadata_transferred :: PrevOwner , pub owner : metadata_transferred :: Owner , pub hash : metadata_transferred :: Hash , } pub mod metadata_transferred { use super :: runtime_types ; pub type PrevOwner = runtime_types :: pallet_democracy :: types :: MetadataOwner ; pub type Owner = runtime_types :: pallet_democracy :: types :: MetadataOwner ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MetadataTransferred { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "MetadataTransferred" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod public_prop_count { use super :: runtime_types ; pub type PublicPropCount = :: core :: primitive :: u32 ; } pub mod public_props { use super :: runtime_types ; pub type PublicProps = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < (:: core :: primitive :: u32 , runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , :: subxt :: ext :: subxt_core :: utils :: AccountId32 ,) > ; } pub mod deposit_of { use super :: runtime_types ; pub type DepositOf = (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , :: core :: primitive :: u128 ,) ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod referendum_count { use super :: runtime_types ; pub type ReferendumCount = :: core :: primitive :: u32 ; } pub mod lowest_unbaked { use super :: runtime_types ; pub type LowestUnbaked = :: core :: primitive :: u32 ; } pub mod referendum_info_of { use super :: runtime_types ; pub type ReferendumInfoOf = runtime_types :: pallet_democracy :: types :: ReferendumInfo < :: core :: primitive :: u32 , runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , :: core :: primitive :: u128 > ; pub type Param0 = :: core :: primitive :: u32 ; } pub mod voting_of { use super :: runtime_types ; pub type VotingOf = runtime_types :: pallet_democracy :: vote :: Voting < :: core :: primitive :: u128 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u32 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } pub mod last_tabled_was_external { use super :: runtime_types ; pub type LastTabledWasExternal = :: core :: primitive :: bool ; } pub mod next_external { use super :: runtime_types ; pub type NextExternal = (runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold ,) ; } pub mod blacklist { use super :: runtime_types ; pub type Blacklist = (:: core :: primitive :: u32 , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ,) ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod cancellations { use super :: runtime_types ; pub type Cancellations = :: core :: primitive :: bool ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod metadata_of { use super :: runtime_types ; pub type MetadataOf = :: subxt :: ext :: subxt_core :: utils :: H256 ; pub type Param0 = runtime_types :: pallet_democracy :: types :: MetadataOwner ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The number of (public) proposals that have been made so far."] pub fn public_prop_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: public_prop_count :: PublicPropCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "PublicPropCount" , () , [51u8 , 175u8 , 184u8 , 94u8 , 91u8 , 212u8 , 100u8 , 108u8 , 127u8 , 162u8 , 233u8 , 137u8 , 12u8 , 209u8 , 29u8 , 130u8 , 125u8 , 179u8 , 208u8 , 160u8 , 173u8 , 149u8 , 12u8 , 111u8 , 1u8 , 82u8 , 196u8 , 137u8 , 51u8 , 204u8 , 153u8 , 198u8 ,]) } # [doc = " The public proposals. Unsorted. The second item is the proposal."] pub fn public_props (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: public_props :: PublicProps , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "PublicProps" , () , [174u8 , 85u8 , 209u8 , 117u8 , 29u8 , 193u8 , 230u8 , 16u8 , 94u8 , 219u8 , 69u8 , 29u8 , 116u8 , 35u8 , 252u8 , 43u8 , 127u8 , 0u8 , 43u8 , 218u8 , 240u8 , 176u8 , 73u8 , 81u8 , 207u8 , 131u8 , 227u8 , 132u8 , 242u8 , 45u8 , 172u8 , 50u8 ,]) } # [doc = " Those who have locked a deposit."] # [doc = ""] # [doc = " TWOX-NOTE: Safe, as increasing integer keys are safe."] pub fn deposit_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: deposit_of :: DepositOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "DepositOf" , () , [115u8 , 12u8 , 250u8 , 191u8 , 201u8 , 165u8 , 90u8 , 140u8 , 101u8 , 47u8 , 46u8 , 3u8 , 78u8 , 30u8 , 180u8 , 22u8 , 28u8 , 154u8 , 36u8 , 99u8 , 255u8 , 84u8 , 33u8 , 21u8 , 65u8 , 110u8 , 52u8 , 245u8 , 19u8 , 6u8 , 104u8 , 167u8 ,]) } # [doc = " Those who have locked a deposit."] # [doc = ""] # [doc = " TWOX-NOTE: Safe, as increasing integer keys are safe."] pub fn deposit_of (& self , _0 : types :: deposit_of :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: deposit_of :: Param0 > , types :: deposit_of :: DepositOf , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "DepositOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [115u8 , 12u8 , 250u8 , 191u8 , 201u8 , 165u8 , 90u8 , 140u8 , 101u8 , 47u8 , 46u8 , 3u8 , 78u8 , 30u8 , 180u8 , 22u8 , 28u8 , 154u8 , 36u8 , 99u8 , 255u8 , 84u8 , 33u8 , 21u8 , 65u8 , 110u8 , 52u8 , 245u8 , 19u8 , 6u8 , 104u8 , 167u8 ,]) } # [doc = " The next free referendum index, aka the number of referenda started so far."] pub fn referendum_count (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: referendum_count :: ReferendumCount , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "ReferendumCount" , () , [64u8 , 145u8 , 232u8 , 153u8 , 121u8 , 87u8 , 128u8 , 253u8 , 170u8 , 192u8 , 139u8 , 18u8 , 0u8 , 33u8 , 243u8 , 11u8 , 238u8 , 222u8 , 244u8 , 5u8 , 247u8 , 198u8 , 149u8 , 31u8 , 122u8 , 208u8 , 86u8 , 179u8 , 166u8 , 167u8 , 93u8 , 67u8 ,]) } # [doc = " The lowest referendum index representing an unbaked referendum. Equal to"] # [doc = " `ReferendumCount` if there isn't a unbaked referendum."] pub fn lowest_unbaked (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: lowest_unbaked :: LowestUnbaked , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "LowestUnbaked" , () , [237u8 , 222u8 , 144u8 , 214u8 , 0u8 , 186u8 , 81u8 , 176u8 , 51u8 , 14u8 , 204u8 , 184u8 , 147u8 , 97u8 , 187u8 , 84u8 , 40u8 , 8u8 , 86u8 , 241u8 , 16u8 , 157u8 , 202u8 , 44u8 , 185u8 , 111u8 , 70u8 , 114u8 , 40u8 , 135u8 , 1u8 , 155u8 ,]) } # [doc = " Information concerning any given referendum."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as indexes are not under an attackers control."] pub fn referendum_info_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: referendum_info_of :: ReferendumInfoOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "ReferendumInfoOf" , () , [245u8 , 152u8 , 149u8 , 236u8 , 59u8 , 164u8 , 120u8 , 142u8 , 130u8 , 25u8 , 119u8 , 158u8 , 103u8 , 140u8 , 203u8 , 213u8 , 110u8 , 151u8 , 137u8 , 226u8 , 186u8 , 130u8 , 233u8 , 245u8 , 145u8 , 145u8 , 140u8 , 54u8 , 222u8 , 219u8 , 234u8 , 206u8 ,]) } # [doc = " Information concerning any given referendum."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as indexes are not under an attackers control."] pub fn referendum_info_of (& self , _0 : types :: referendum_info_of :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: referendum_info_of :: Param0 > , types :: referendum_info_of :: ReferendumInfoOf , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "ReferendumInfoOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [245u8 , 152u8 , 149u8 , 236u8 , 59u8 , 164u8 , 120u8 , 142u8 , 130u8 , 25u8 , 119u8 , 158u8 , 103u8 , 140u8 , 203u8 , 213u8 , 110u8 , 151u8 , 137u8 , 226u8 , 186u8 , 130u8 , 233u8 , 245u8 , 145u8 , 145u8 , 140u8 , 54u8 , 222u8 , 219u8 , 234u8 , 206u8 ,]) } # [doc = " All votes for a particular voter. We store the balance for the number of votes that we"] # [doc = " have recorded. The second item is the total amount of delegations, that will be added."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."] pub fn voting_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: voting_of :: VotingOf , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "VotingOf" , () , [234u8 , 35u8 , 206u8 , 197u8 , 17u8 , 251u8 , 1u8 , 230u8 , 80u8 , 235u8 , 108u8 , 126u8 , 82u8 , 145u8 , 39u8 , 104u8 , 209u8 , 16u8 , 209u8 , 52u8 , 165u8 , 231u8 , 110u8 , 92u8 , 113u8 , 212u8 , 72u8 , 57u8 , 60u8 , 73u8 , 107u8 , 118u8 ,]) } # [doc = " All votes for a particular voter. We store the balance for the number of votes that we"] # [doc = " have recorded. The second item is the total amount of delegations, that will be added."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."] pub fn voting_of (& self , _0 : types :: voting_of :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: voting_of :: Param0 > , types :: voting_of :: VotingOf , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "VotingOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [234u8 , 35u8 , 206u8 , 197u8 , 17u8 , 251u8 , 1u8 , 230u8 , 80u8 , 235u8 , 108u8 , 126u8 , 82u8 , 145u8 , 39u8 , 104u8 , 209u8 , 16u8 , 209u8 , 52u8 , 165u8 , 231u8 , 110u8 , 92u8 , 113u8 , 212u8 , 72u8 , 57u8 , 60u8 , 73u8 , 107u8 , 118u8 ,]) } # [doc = " True if the last referendum tabled was submitted externally. False if it was a public"] # [doc = " proposal."] pub fn last_tabled_was_external (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: last_tabled_was_external :: LastTabledWasExternal , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "LastTabledWasExternal" , () , [162u8 , 201u8 , 72u8 , 9u8 , 78u8 , 49u8 , 72u8 , 62u8 , 240u8 , 69u8 , 20u8 , 135u8 , 26u8 , 59u8 , 71u8 , 46u8 , 19u8 , 25u8 , 195u8 , 11u8 , 99u8 , 31u8 , 104u8 , 4u8 , 24u8 , 129u8 , 47u8 , 69u8 , 219u8 , 178u8 , 104u8 , 190u8 ,]) } # [doc = " The referendum to be tabled whenever it would be valid to table an external proposal."] # [doc = " This happens when a referendum needs to be tabled and one of two conditions are met:"] # [doc = " - `LastTabledWasExternal` is `false`; or"] # [doc = " - `PublicProps` is empty."] pub fn next_external (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: next_external :: NextExternal , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "NextExternal" , () , [240u8 , 58u8 , 238u8 , 86u8 , 35u8 , 48u8 , 192u8 , 51u8 , 91u8 , 4u8 , 47u8 , 202u8 , 21u8 , 74u8 , 158u8 , 64u8 , 107u8 , 247u8 , 248u8 , 240u8 , 122u8 , 109u8 , 204u8 , 180u8 , 103u8 , 239u8 , 156u8 , 68u8 , 141u8 , 253u8 , 131u8 , 239u8 ,]) } # [doc = " A record of who vetoed what. Maps proposal hash to a possible existent block number"] # [doc = " (until when it may not be resubmitted) and who vetoed it."] pub fn blacklist_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: blacklist :: Blacklist , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "Blacklist" , () , [12u8 , 231u8 , 204u8 , 151u8 , 57u8 , 182u8 , 5u8 , 74u8 , 231u8 , 100u8 , 165u8 , 28u8 , 147u8 , 109u8 , 119u8 , 37u8 , 138u8 , 159u8 , 7u8 , 175u8 , 41u8 , 110u8 , 205u8 , 69u8 , 17u8 , 9u8 , 39u8 , 102u8 , 90u8 , 244u8 , 165u8 , 141u8 ,]) } # [doc = " A record of who vetoed what. Maps proposal hash to a possible existent block number"] # [doc = " (until when it may not be resubmitted) and who vetoed it."] pub fn blacklist (& self , _0 : types :: blacklist :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: blacklist :: Param0 > , types :: blacklist :: Blacklist , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "Blacklist" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [12u8 , 231u8 , 204u8 , 151u8 , 57u8 , 182u8 , 5u8 , 74u8 , 231u8 , 100u8 , 165u8 , 28u8 , 147u8 , 109u8 , 119u8 , 37u8 , 138u8 , 159u8 , 7u8 , 175u8 , 41u8 , 110u8 , 205u8 , 69u8 , 17u8 , 9u8 , 39u8 , 102u8 , 90u8 , 244u8 , 165u8 , 141u8 ,]) } # [doc = " Record of all proposals that have been subject to emergency cancellation."] pub fn cancellations_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: cancellations :: Cancellations , () , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "Cancellations" , () , [80u8 , 190u8 , 98u8 , 105u8 , 129u8 , 25u8 , 167u8 , 180u8 , 74u8 , 128u8 , 232u8 , 29u8 , 193u8 , 209u8 , 185u8 , 60u8 , 18u8 , 180u8 , 59u8 , 192u8 , 149u8 , 13u8 , 123u8 , 232u8 , 34u8 , 208u8 , 48u8 , 104u8 , 35u8 , 181u8 , 186u8 , 244u8 ,]) } # [doc = " Record of all proposals that have been subject to emergency cancellation."] pub fn cancellations (& self , _0 : types :: cancellations :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: cancellations :: Param0 > , types :: cancellations :: Cancellations , :: subxt :: ext :: subxt_core :: utils :: Yes , :: subxt :: ext :: subxt_core :: utils :: Yes , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "Cancellations" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [80u8 , 190u8 , 98u8 , 105u8 , 129u8 , 25u8 , 167u8 , 180u8 , 74u8 , 128u8 , 232u8 , 29u8 , 193u8 , 209u8 , 185u8 , 60u8 , 18u8 , 180u8 , 59u8 , 192u8 , 149u8 , 13u8 , 123u8 , 232u8 , 34u8 , 208u8 , 48u8 , 104u8 , 35u8 , 181u8 , 186u8 , 244u8 ,]) } # [doc = " General information concerning any proposal or referendum."] # [doc = " The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON"] # [doc = " dump or IPFS hash of a JSON file."] # [doc = ""] # [doc = " Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)"] # [doc = " large preimages."] pub fn metadata_of_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: metadata_of :: MetadataOf , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "MetadataOf" , () , [52u8 , 151u8 , 124u8 , 110u8 , 85u8 , 173u8 , 181u8 , 86u8 , 174u8 , 183u8 , 102u8 , 22u8 , 8u8 , 36u8 , 224u8 , 114u8 , 98u8 , 0u8 , 220u8 , 215u8 , 19u8 , 147u8 , 32u8 , 238u8 , 242u8 , 187u8 , 235u8 , 163u8 , 183u8 , 235u8 , 9u8 , 180u8 ,]) } # [doc = " General information concerning any proposal or referendum."] # [doc = " The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON"] # [doc = " dump or IPFS hash of a JSON file."] # [doc = ""] # [doc = " Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)"] # [doc = " large preimages."] pub fn metadata_of (& self , _0 : types :: metadata_of :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: metadata_of :: Param0 > , types :: metadata_of :: MetadataOf , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Democracy" , "MetadataOf" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [52u8 , 151u8 , 124u8 , 110u8 , 85u8 , 173u8 , 181u8 , 86u8 , 174u8 , 183u8 , 102u8 , 22u8 , 8u8 , 36u8 , 224u8 , 114u8 , 98u8 , 0u8 , 220u8 , 215u8 , 19u8 , 147u8 , 32u8 , 238u8 , 242u8 , 187u8 , 235u8 , 163u8 , 183u8 , 235u8 , 9u8 , 180u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The period between a proposal being approved and enacted."] # [doc = ""] # [doc = " It should generally be a little more than the unstake period to ensure that"] # [doc = " voting stakers have an opportunity to remove themselves from the system in the case"] # [doc = " where they are on the losing side of a vote."] pub fn enactment_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "EnactmentPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " How often (in blocks) new public referenda are launched."] pub fn launch_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "LaunchPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " How often (in blocks) to check for new votes."] pub fn voting_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "VotingPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The minimum period of vote locking."] # [doc = ""] # [doc = " It should be no shorter than enactment period to ensure that in the case of an approval,"] # [doc = " those successful voters are locked into the consequences that their votes entail."] pub fn vote_locking_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "VoteLockingPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The minimum amount to be used as a deposit for a public referendum proposal."] pub fn minimum_deposit (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "MinimumDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Indicator for whether an emergency origin is even allowed to happen. Some chains may"] # [doc = " want to set this permanently to `false`, others may want to condition it on things such"] # [doc = " as an upgrade having happened recently."] pub fn instant_allowed (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: bool > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "InstantAllowed" , [165u8 , 28u8 , 112u8 , 190u8 , 18u8 , 129u8 , 182u8 , 206u8 , 237u8 , 1u8 , 68u8 , 252u8 , 125u8 , 234u8 , 185u8 , 50u8 , 149u8 , 164u8 , 47u8 , 126u8 , 134u8 , 100u8 , 14u8 , 86u8 , 209u8 , 39u8 , 20u8 , 4u8 , 233u8 , 115u8 , 102u8 , 131u8 ,]) } # [doc = " Minimum voting period allowed for a fast-track referendum."] pub fn fast_track_voting_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "FastTrackVotingPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Period in blocks where an external proposal may not be re-submitted after being vetoed."] pub fn cooloff_period (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "CooloffPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of votes for an account."] # [doc = ""] # [doc = " Also used to compute weight, an overly big value can"] # [doc = " lead to extrinsic with very big weight: see `delegate` for instance."] pub fn max_votes (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "MaxVotes" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of public proposals that can exist at any time."] pub fn max_proposals (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "MaxProposals" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of deposits a public proposal may have at any time."] pub fn max_deposits (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "MaxDeposits" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of items which can be blacklisted."] pub fn max_blacklisted (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Democracy" , "MaxBlacklisted" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod preimage { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_preimage :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_preimage :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] pub struct NotePreimage { pub bytes : note_preimage :: Bytes , } pub mod note_preimage { use super :: runtime_types ; pub type Bytes = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for NotePreimage { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "note_preimage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Clear an unrequested preimage from the runtime storage."] # [doc = ""] # [doc = "If `len` is provided, then it will be a much cheaper operation."] # [doc = ""] # [doc = "- `hash`: The hash of the preimage to be removed from the store."] # [doc = "- `len`: The length of the preimage of `hash`."] pub struct UnnotePreimage { pub hash : unnote_preimage :: Hash , } pub mod unnote_preimage { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UnnotePreimage { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "unnote_preimage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] pub struct RequestPreimage { pub hash : request_preimage :: Hash , } pub mod request_preimage { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RequestPreimage { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "request_preimage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] pub struct UnrequestPreimage { pub hash : unrequest_preimage :: Hash , } pub mod unrequest_preimage { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for UnrequestPreimage { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "unrequest_preimage" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Ensure that the a bulk of pre-images is upgraded."] # [doc = ""] # [doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."] pub struct EnsureUpdated { pub hashes : ensure_updated :: Hashes , } pub mod ensure_updated { use super :: runtime_types ; pub type Hashes = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: H256 > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for EnsureUpdated { const PALLET : & 'static str = "Preimage" ; const CALL : & 'static str = "ensure_updated" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] pub fn note_preimage (& self , bytes : types :: note_preimage :: Bytes ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: NotePreimage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "note_preimage" , types :: NotePreimage { bytes , } , [121u8 , 88u8 , 18u8 , 92u8 , 176u8 , 15u8 , 192u8 , 198u8 , 146u8 , 198u8 , 38u8 , 242u8 , 213u8 , 83u8 , 7u8 , 230u8 , 14u8 , 110u8 , 235u8 , 32u8 , 215u8 , 26u8 , 192u8 , 217u8 , 113u8 , 224u8 , 206u8 , 96u8 , 177u8 , 198u8 , 246u8 , 33u8 ,]) } # [doc = "Clear an unrequested preimage from the runtime storage."] # [doc = ""] # [doc = "If `len` is provided, then it will be a much cheaper operation."] # [doc = ""] # [doc = "- `hash`: The hash of the preimage to be removed from the store."] # [doc = "- `len`: The length of the preimage of `hash`."] pub fn unnote_preimage (& self , hash : types :: unnote_preimage :: Hash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UnnotePreimage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "unnote_preimage" , types :: UnnotePreimage { hash , } , [188u8 , 116u8 , 222u8 , 22u8 , 127u8 , 215u8 , 2u8 , 133u8 , 96u8 , 202u8 , 190u8 , 123u8 , 203u8 , 43u8 , 200u8 , 161u8 , 226u8 , 24u8 , 49u8 , 36u8 , 221u8 , 160u8 , 130u8 , 119u8 , 30u8 , 138u8 , 144u8 , 85u8 , 5u8 , 164u8 , 252u8 , 222u8 ,]) } # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] pub fn request_preimage (& self , hash : types :: request_preimage :: Hash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RequestPreimage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "request_preimage" , types :: RequestPreimage { hash , } , [87u8 , 0u8 , 204u8 , 111u8 , 43u8 , 115u8 , 64u8 , 209u8 , 133u8 , 13u8 , 83u8 , 45u8 , 164u8 , 166u8 , 233u8 , 105u8 , 242u8 , 238u8 , 235u8 , 208u8 , 113u8 , 134u8 , 93u8 , 242u8 , 86u8 , 32u8 , 7u8 , 152u8 , 107u8 , 208u8 , 79u8 , 59u8 ,]) } # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] pub fn unrequest_preimage (& self , hash : types :: unrequest_preimage :: Hash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: UnrequestPreimage > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "unrequest_preimage" , types :: UnrequestPreimage { hash , } , [55u8 , 37u8 , 224u8 , 149u8 , 142u8 , 120u8 , 8u8 , 68u8 , 183u8 , 225u8 , 255u8 , 240u8 , 254u8 , 111u8 , 58u8 , 200u8 , 113u8 , 217u8 , 177u8 , 203u8 , 107u8 , 104u8 , 233u8 , 87u8 , 252u8 , 53u8 , 33u8 , 112u8 , 116u8 , 254u8 , 117u8 , 134u8 ,]) } # [doc = "Ensure that the a bulk of pre-images is upgraded."] # [doc = ""] # [doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."] pub fn ensure_updated (& self , hashes : types :: ensure_updated :: Hashes ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: EnsureUpdated > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Preimage" , "ensure_updated" , types :: EnsureUpdated { hashes , } , [254u8 , 228u8 , 88u8 , 44u8 , 126u8 , 235u8 , 188u8 , 153u8 , 61u8 , 27u8 , 103u8 , 253u8 , 163u8 , 161u8 , 113u8 , 243u8 , 87u8 , 136u8 , 2u8 , 231u8 , 209u8 , 188u8 , 215u8 , 106u8 , 192u8 , 225u8 , 75u8 , 125u8 , 224u8 , 96u8 , 221u8 , 90u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_preimage :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A preimage has been noted."] pub struct Noted { pub hash : noted :: Hash , } pub mod noted { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Noted { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Noted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A preimage has been requested."] pub struct Requested { pub hash : requested :: Hash , } pub mod requested { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Requested { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Requested" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A preimage has ben cleared."] pub struct Cleared { pub hash : cleared :: Hash , } pub mod cleared { use super :: runtime_types ; pub type Hash = :: subxt :: ext :: subxt_core :: utils :: H256 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Cleared { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Cleared" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod status_for { use super :: runtime_types ; pub type StatusFor = runtime_types :: pallet_preimage :: OldRequestStatus < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u128 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod request_status_for { use super :: runtime_types ; pub type RequestStatusFor = runtime_types :: pallet_preimage :: RequestStatus < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , runtime_types :: frame_support :: traits :: tokens :: fungible :: HoldConsideration > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: H256 ; } pub mod preimage_for { use super :: runtime_types ; pub type PreimageFor = runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ; pub type Param0 = (:: subxt :: ext :: subxt_core :: utils :: H256 , :: core :: primitive :: u32 ,) ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The request status of a given hash."] pub fn status_for_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: status_for :: StatusFor , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "StatusFor" , () , [187u8 , 100u8 , 54u8 , 112u8 , 96u8 , 129u8 , 36u8 , 149u8 , 127u8 , 226u8 , 126u8 , 171u8 , 72u8 , 189u8 , 59u8 , 126u8 , 204u8 , 125u8 , 67u8 , 204u8 , 231u8 , 6u8 , 212u8 , 135u8 , 166u8 , 252u8 , 5u8 , 46u8 , 111u8 , 120u8 , 54u8 , 209u8 ,]) } # [doc = " The request status of a given hash."] pub fn status_for (& self , _0 : types :: status_for :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: status_for :: Param0 > , types :: status_for :: StatusFor , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "StatusFor" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [187u8 , 100u8 , 54u8 , 112u8 , 96u8 , 129u8 , 36u8 , 149u8 , 127u8 , 226u8 , 126u8 , 171u8 , 72u8 , 189u8 , 59u8 , 126u8 , 204u8 , 125u8 , 67u8 , 204u8 , 231u8 , 6u8 , 212u8 , 135u8 , 166u8 , 252u8 , 5u8 , 46u8 , 111u8 , 120u8 , 54u8 , 209u8 ,]) } # [doc = " The request status of a given hash."] pub fn request_status_for_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: request_status_for :: RequestStatusFor , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "RequestStatusFor" , () , [72u8 , 59u8 , 254u8 , 211u8 , 96u8 , 223u8 , 10u8 , 64u8 , 6u8 , 139u8 , 213u8 , 85u8 , 14u8 , 29u8 , 166u8 , 37u8 , 140u8 , 124u8 , 186u8 , 156u8 , 172u8 , 157u8 , 73u8 , 5u8 , 121u8 , 117u8 , 51u8 , 6u8 , 249u8 , 203u8 , 75u8 , 190u8 ,]) } # [doc = " The request status of a given hash."] pub fn request_status_for (& self , _0 : types :: request_status_for :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: request_status_for :: Param0 > , types :: request_status_for :: RequestStatusFor , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "RequestStatusFor" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [72u8 , 59u8 , 254u8 , 211u8 , 96u8 , 223u8 , 10u8 , 64u8 , 6u8 , 139u8 , 213u8 , 85u8 , 14u8 , 29u8 , 166u8 , 37u8 , 140u8 , 124u8 , 186u8 , 156u8 , 172u8 , 157u8 , 73u8 , 5u8 , 121u8 , 117u8 , 51u8 , 6u8 , 249u8 , 203u8 , 75u8 , 190u8 ,]) } pub fn preimage_for_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: preimage_for :: PreimageFor , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "PreimageFor" , () , [106u8 , 5u8 , 17u8 , 46u8 , 6u8 , 184u8 , 177u8 , 113u8 , 169u8 , 34u8 , 119u8 , 141u8 , 117u8 , 40u8 , 30u8 , 94u8 , 187u8 , 35u8 , 206u8 , 216u8 , 143u8 , 208u8 , 49u8 , 156u8 , 200u8 , 255u8 , 109u8 , 200u8 , 210u8 , 134u8 , 24u8 , 139u8 ,]) } pub fn preimage_for (& self , _0 : types :: preimage_for :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: preimage_for :: Param0 > , types :: preimage_for :: PreimageFor , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Preimage" , "PreimageFor" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [106u8 , 5u8 , 17u8 , 46u8 , 6u8 , 184u8 , 177u8 , 113u8 , 169u8 , 34u8 , 119u8 , 141u8 , 117u8 , 40u8 , 30u8 , 94u8 , 187u8 , 35u8 , 206u8 , 216u8 , 143u8 , 208u8 , 49u8 , 156u8 , 200u8 , 255u8 , 109u8 , 200u8 , 210u8 , 134u8 , 24u8 , 139u8 ,]) } } } } pub mod multisig { use super :: root_mod ; use super :: runtime_types ; # [doc = "The `Error` enum of this pallet."] pub type Error = runtime_types :: pallet_multisig :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_multisig :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] pub struct AsMultiThreshold1 { pub other_signatories : as_multi_threshold1 :: OtherSignatories , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < as_multi_threshold1 :: Call > , } pub mod as_multi_threshold1 { use super :: runtime_types ; pub type OtherSignatories = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AsMultiThreshold1 { const PALLET : & 'static str = "Multisig" ; const CALL : & 'static str = "as_multi_threshold_1" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub struct AsMulti { pub threshold : as_multi :: Threshold , pub other_signatories : as_multi :: OtherSignatories , pub maybe_timepoint : as_multi :: MaybeTimepoint , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < as_multi :: Call > , pub max_weight : as_multi :: MaxWeight , } pub mod as_multi { use super :: runtime_types ; pub type Threshold = :: core :: primitive :: u16 ; pub type OtherSignatories = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type MaybeTimepoint = :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; pub type MaxWeight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for AsMulti { const PALLET : & 'static str = "Multisig" ; const CALL : & 'static str = "as_multi" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub struct ApproveAsMulti { pub threshold : approve_as_multi :: Threshold , pub other_signatories : approve_as_multi :: OtherSignatories , pub maybe_timepoint : approve_as_multi :: MaybeTimepoint , pub call_hash : approve_as_multi :: CallHash , pub max_weight : approve_as_multi :: MaxWeight , } pub mod approve_as_multi { use super :: runtime_types ; pub type Threshold = :: core :: primitive :: u16 ; pub type OtherSignatories = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type MaybeTimepoint = :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; pub type MaxWeight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for ApproveAsMulti { const PALLET : & 'static str = "Multisig" ; const CALL : & 'static str = "approve_as_multi" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] pub struct CancelAsMulti { pub threshold : cancel_as_multi :: Threshold , pub other_signatories : cancel_as_multi :: OtherSignatories , pub timepoint : cancel_as_multi :: Timepoint , pub call_hash : cancel_as_multi :: CallHash , } pub mod cancel_as_multi { use super :: runtime_types ; pub type Threshold = :: core :: primitive :: u16 ; pub type OtherSignatories = :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Timepoint = runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for CancelAsMulti { const PALLET : & 'static str = "Multisig" ; const CALL : & 'static str = "cancel_as_multi" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] pub fn as_multi_threshold_1 (& self , other_signatories : types :: as_multi_threshold1 :: OtherSignatories , call : types :: as_multi_threshold1 :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AsMultiThreshold1 > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Multisig" , "as_multi_threshold_1" , types :: AsMultiThreshold1 { other_signatories , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [214u8 , 172u8 , 178u8 , 164u8 , 27u8 , 5u8 , 34u8 , 90u8 , 102u8 , 161u8 , 200u8 , 124u8 , 188u8 , 148u8 , 21u8 , 80u8 , 178u8 , 147u8 , 181u8 , 193u8 , 52u8 , 199u8 , 245u8 , 33u8 , 250u8 , 117u8 , 88u8 , 87u8 , 104u8 , 128u8 , 183u8 , 81u8 ,]) } # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub fn as_multi (& self , threshold : types :: as_multi :: Threshold , other_signatories : types :: as_multi :: OtherSignatories , maybe_timepoint : types :: as_multi :: MaybeTimepoint , call : types :: as_multi :: Call , max_weight : types :: as_multi :: MaxWeight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: AsMulti > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Multisig" , "as_multi" , types :: AsMulti { threshold , other_signatories , maybe_timepoint , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , max_weight , } , [33u8 , 128u8 , 124u8 , 9u8 , 47u8 , 150u8 , 173u8 , 253u8 , 33u8 , 124u8 , 25u8 , 224u8 , 171u8 , 94u8 , 24u8 , 1u8 , 6u8 , 227u8 , 86u8 , 205u8 , 66u8 , 160u8 , 58u8 , 189u8 , 179u8 , 131u8 , 137u8 , 220u8 , 43u8 , 216u8 , 84u8 , 36u8 ,]) } # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub fn approve_as_multi (& self , threshold : types :: approve_as_multi :: Threshold , other_signatories : types :: approve_as_multi :: OtherSignatories , maybe_timepoint : types :: approve_as_multi :: MaybeTimepoint , call_hash : types :: approve_as_multi :: CallHash , max_weight : types :: approve_as_multi :: MaxWeight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: ApproveAsMulti > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Multisig" , "approve_as_multi" , types :: ApproveAsMulti { threshold , other_signatories , maybe_timepoint , call_hash , max_weight , } , [248u8 , 46u8 , 131u8 , 35u8 , 204u8 , 12u8 , 218u8 , 150u8 , 88u8 , 131u8 , 89u8 , 13u8 , 95u8 , 122u8 , 87u8 , 107u8 , 136u8 , 154u8 , 92u8 , 199u8 , 108u8 , 92u8 , 207u8 , 171u8 , 113u8 , 8u8 , 47u8 , 248u8 , 65u8 , 26u8 , 203u8 , 135u8 ,]) } # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] pub fn cancel_as_multi (& self , threshold : types :: cancel_as_multi :: Threshold , other_signatories : types :: cancel_as_multi :: OtherSignatories , timepoint : types :: cancel_as_multi :: Timepoint , call_hash : types :: cancel_as_multi :: CallHash ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: CancelAsMulti > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Multisig" , "cancel_as_multi" , types :: CancelAsMulti { threshold , other_signatories , timepoint , call_hash , } , [212u8 , 179u8 , 123u8 , 40u8 , 209u8 , 228u8 , 181u8 , 0u8 , 109u8 , 28u8 , 27u8 , 48u8 , 15u8 , 47u8 , 203u8 , 54u8 , 106u8 , 114u8 , 28u8 , 118u8 , 101u8 , 201u8 , 95u8 , 187u8 , 46u8 , 182u8 , 4u8 , 30u8 , 227u8 , 105u8 , 14u8 , 81u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_multisig :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A new multisig operation has begun."] pub struct NewMultisig { pub approving : new_multisig :: Approving , pub multisig : new_multisig :: Multisig , pub call_hash : new_multisig :: CallHash , } pub mod new_multisig { use super :: runtime_types ; pub type Approving = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Multisig = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for NewMultisig { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "NewMultisig" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A multisig operation has been approved by someone."] pub struct MultisigApproval { pub approving : multisig_approval :: Approving , pub timepoint : multisig_approval :: Timepoint , pub multisig : multisig_approval :: Multisig , pub call_hash : multisig_approval :: CallHash , } pub mod multisig_approval { use super :: runtime_types ; pub type Approving = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Timepoint = runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > ; pub type Multisig = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MultisigApproval { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigApproval" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A multisig operation has been executed."] pub struct MultisigExecuted { pub approving : multisig_executed :: Approving , pub timepoint : multisig_executed :: Timepoint , pub multisig : multisig_executed :: Multisig , pub call_hash : multisig_executed :: CallHash , pub result : multisig_executed :: Result , } pub mod multisig_executed { use super :: runtime_types ; pub type Approving = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Timepoint = runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > ; pub type Multisig = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; pub type Result = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MultisigExecuted { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigExecuted" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A multisig operation has been cancelled."] pub struct MultisigCancelled { pub cancelling : multisig_cancelled :: Cancelling , pub timepoint : multisig_cancelled :: Timepoint , pub multisig : multisig_cancelled :: Multisig , pub call_hash : multisig_cancelled :: CallHash , } pub mod multisig_cancelled { use super :: runtime_types ; pub type Cancelling = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Timepoint = runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > ; pub type Multisig = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type CallHash = [:: core :: primitive :: u8 ; 32usize] ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for MultisigCancelled { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigCancelled" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod multisigs { use super :: runtime_types ; pub type Multisigs = runtime_types :: pallet_multisig :: Multisig < :: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type Param0 = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; pub type Param1 = [:: core :: primitive :: u8 ; 32usize] ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The set of open multisig operations."] pub fn multisigs_iter (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: multisigs :: Multisigs , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Multisig" , "Multisigs" , () , [154u8 , 109u8 , 45u8 , 18u8 , 155u8 , 151u8 , 81u8 , 28u8 , 86u8 , 127u8 , 189u8 , 151u8 , 49u8 , 61u8 , 12u8 , 149u8 , 84u8 , 61u8 , 110u8 , 197u8 , 200u8 , 140u8 , 37u8 , 100u8 , 14u8 , 162u8 , 158u8 , 161u8 , 48u8 , 117u8 , 102u8 , 61u8 ,]) } # [doc = " The set of open multisig operations."] pub fn multisigs_iter1 (& self , _0 : types :: multisigs :: Param0 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: multisigs :: Param0 > , types :: multisigs :: Multisigs , () , () , :: subxt :: ext :: subxt_core :: utils :: Yes > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Multisig" , "Multisigs" , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , [154u8 , 109u8 , 45u8 , 18u8 , 155u8 , 151u8 , 81u8 , 28u8 , 86u8 , 127u8 , 189u8 , 151u8 , 49u8 , 61u8 , 12u8 , 149u8 , 84u8 , 61u8 , 110u8 , 197u8 , 200u8 , 140u8 , 37u8 , 100u8 , 14u8 , 162u8 , 158u8 , 161u8 , 48u8 , 117u8 , 102u8 , 61u8 ,]) } # [doc = " The set of open multisig operations."] pub fn multisigs (& self , _0 : types :: multisigs :: Param0 , _1 : types :: multisigs :: Param1 ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: multisigs :: Param0 > , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey < types :: multisigs :: Param1 > ,) , types :: multisigs :: Multisigs , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Multisig" , "Multisigs" , (:: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_0) , :: subxt :: ext :: subxt_core :: storage :: address :: StaticStorageKey :: new (_1) ,) , [154u8 , 109u8 , 45u8 , 18u8 , 155u8 , 151u8 , 81u8 , 28u8 , 86u8 , 127u8 , 189u8 , 151u8 , 49u8 , 61u8 , 12u8 , 149u8 , 84u8 , 61u8 , 110u8 , 197u8 , 200u8 , 140u8 , 37u8 , 100u8 , 14u8 , 162u8 , 158u8 , 161u8 , 48u8 , 117u8 , 102u8 , 61u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The base amount of currency needed to reserve for creating a multisig execution or to"] # [doc = " store a dispatch call for later."] # [doc = ""] # [doc = " This is held for an additional storage item whose value size is"] # [doc = " `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is"] # [doc = " `32 + sizeof(AccountId)` bytes."] pub fn deposit_base (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Multisig" , "DepositBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of currency needed per unit threshold when creating a multisig execution."] # [doc = ""] # [doc = " This is held for adding 32 bytes more into a pre-existing storage value."] pub fn deposit_factor (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u128 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Multisig" , "DepositFactor" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum amount of signatories allowed in the multisig."] pub fn max_signatories (& self) -> :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress < :: core :: primitive :: u32 > { :: subxt :: ext :: subxt_core :: constants :: address :: StaticAddress :: new_static ("Multisig" , "MaxSignatories" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod sudo { use super :: root_mod ; use super :: runtime_types ; # [doc = "Error for the Sudo pallet."] pub type Error = runtime_types :: pallet_sudo :: pallet :: Error ; # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub type Call = runtime_types :: pallet_sudo :: pallet :: Call ; pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] pub struct Sudo { pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < sudo :: Call > , } pub mod sudo { use super :: runtime_types ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for Sudo { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "sudo" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub struct SudoUncheckedWeight { pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < sudo_unchecked_weight :: Call > , pub weight : sudo_unchecked_weight :: Weight , } pub mod sudo_unchecked_weight { use super :: runtime_types ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; pub type Weight = runtime_types :: sp_weights :: weight_v2 :: Weight ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoUncheckedWeight { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "sudo_unchecked_weight" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] pub struct SetKey { pub new : set_key :: New , } pub mod set_key { use super :: runtime_types ; pub type New = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SetKey { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "set_key" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub struct SudoAs { pub who : sudo_as :: Who , pub call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < sudo_as :: Call > , } pub mod sudo_as { use super :: runtime_types ; pub type Who = :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > ; pub type Call = runtime_types :: subspace_runtime :: RuntimeCall ; } impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for SudoAs { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "sudo_as" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Permanently removes the sudo key."] # [doc = ""] # [doc = "**This cannot be un-done.**"] pub struct RemoveKey ; impl :: subxt :: ext :: subxt_core :: blocks :: StaticExtrinsic for RemoveKey { const PALLET : & 'static str = "Sudo" ; const CALL : & 'static str = "remove_key" ; } } pub struct TransactionApi ; impl TransactionApi { # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] pub fn sudo (& self , call : types :: sudo :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: Sudo > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "sudo" , types :: Sudo { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [121u8 , 75u8 , 246u8 , 70u8 , 176u8 , 182u8 , 185u8 , 133u8 , 44u8 , 230u8 , 210u8 , 230u8 , 181u8 , 69u8 , 77u8 , 170u8 , 55u8 , 174u8 , 70u8 , 75u8 , 139u8 , 150u8 , 75u8 , 12u8 , 91u8 , 13u8 , 84u8 , 0u8 , 31u8 , 161u8 , 198u8 , 59u8 ,]) } # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub fn sudo_unchecked_weight (& self , call : types :: sudo_unchecked_weight :: Call , weight : types :: sudo_unchecked_weight :: Weight ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoUncheckedWeight > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "sudo_unchecked_weight" , types :: SudoUncheckedWeight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , weight , } , [152u8 , 93u8 , 131u8 , 5u8 , 125u8 , 155u8 , 234u8 , 76u8 , 165u8 , 217u8 , 234u8 , 245u8 , 207u8 , 79u8 , 70u8 , 153u8 , 20u8 , 234u8 , 245u8 , 155u8 , 90u8 , 41u8 , 178u8 , 129u8 , 167u8 , 247u8 , 70u8 , 233u8 , 195u8 , 88u8 , 246u8 , 139u8 ,]) } # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] pub fn set_key (& self , new : types :: set_key :: New ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SetKey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "set_key" , types :: SetKey { new , } , [9u8 , 73u8 , 39u8 , 205u8 , 188u8 , 127u8 , 143u8 , 54u8 , 128u8 , 94u8 , 8u8 , 227u8 , 197u8 , 44u8 , 70u8 , 93u8 , 228u8 , 196u8 , 64u8 , 165u8 , 226u8 , 158u8 , 101u8 , 192u8 , 22u8 , 193u8 , 102u8 , 84u8 , 21u8 , 35u8 , 92u8 , 198u8 ,]) } # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub fn sudo_as (& self , who : types :: sudo_as :: Who , call : types :: sudo_as :: Call ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: SudoAs > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "sudo_as" , types :: SudoAs { who , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box :: new (call) , } , [32u8 , 125u8 , 174u8 , 191u8 , 68u8 , 15u8 , 178u8 , 136u8 , 33u8 , 40u8 , 14u8 , 97u8 , 140u8 , 144u8 , 197u8 , 40u8 , 235u8 , 133u8 , 25u8 , 153u8 , 135u8 , 210u8 , 221u8 , 56u8 , 131u8 , 133u8 , 136u8 , 36u8 , 212u8 , 23u8 , 204u8 , 249u8 ,]) } # [doc = "Permanently removes the sudo key."] # [doc = ""] # [doc = "**This cannot be un-done.**"] pub fn remove_key (& self ,) -> :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload < types :: RemoveKey > { :: subxt :: ext :: subxt_core :: tx :: payload :: StaticPayload :: new_static ("Sudo" , "remove_key" , types :: RemoveKey { } , [133u8 , 253u8 , 54u8 , 175u8 , 202u8 , 239u8 , 5u8 , 198u8 , 180u8 , 138u8 , 25u8 , 28u8 , 109u8 , 40u8 , 30u8 , 56u8 , 126u8 , 100u8 , 52u8 , 205u8 , 250u8 , 191u8 , 61u8 , 195u8 , 172u8 , 142u8 , 184u8 , 239u8 , 247u8 , 10u8 , 211u8 , 79u8 ,]) } } } # [doc = "The `Event` enum of this pallet"] pub type Event = runtime_types :: pallet_sudo :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A sudo call just took place."] pub struct Sudid { pub sudo_result : sudid :: SudoResult , } pub mod sudid { use super :: runtime_types ; pub type SudoResult = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for Sudid { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "Sudid" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The sudo key has been updated."] pub struct KeyChanged { pub old : key_changed :: Old , pub new : key_changed :: New , } pub mod key_changed { use super :: runtime_types ; pub type Old = :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ; pub type New = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KeyChanged { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The key was permanently removed."] pub struct KeyRemoved ; impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for KeyRemoved { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "KeyRemoved" ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "A [sudo_as](Pallet::sudo_as) call just took place."] pub struct SudoAsDone { pub sudo_result : sudo_as_done :: SudoResult , } pub mod sudo_as_done { use super :: runtime_types ; pub type SudoResult = :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ; } impl :: subxt :: ext :: subxt_core :: events :: StaticEvent for SudoAsDone { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "SudoAsDone" ; } } pub mod storage { use super :: runtime_types ; pub mod types { use super :: runtime_types ; pub mod key { use super :: runtime_types ; pub type Key = :: subxt :: ext :: subxt_core :: utils :: AccountId32 ; } } pub struct StorageApi ; impl StorageApi { # [doc = " The `AccountId` of the sudo key."] pub fn key (& self ,) -> :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: < () , types :: key :: Key , :: subxt :: ext :: subxt_core :: utils :: Yes , () , () > { :: subxt :: ext :: subxt_core :: storage :: address :: StaticAddress :: new_static ("Sudo" , "Key" , () , [72u8 , 14u8 , 225u8 , 162u8 , 205u8 , 247u8 , 227u8 , 105u8 , 116u8 , 57u8 , 4u8 , 31u8 , 84u8 , 137u8 , 227u8 , 228u8 , 133u8 , 245u8 , 206u8 , 227u8 , 117u8 , 36u8 , 252u8 , 151u8 , 107u8 , 15u8 , 180u8 , 4u8 , 4u8 , 152u8 , 195u8 , 144u8 ,]) } } } } pub mod runtime_types { use super :: runtime_types ; pub mod bounded_collections { use super :: runtime_types ; pub mod bounded_btree_map { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BoundedBTreeMap < _0 , _1 > (pub :: subxt :: ext :: subxt_core :: utils :: KeyedVec < _0 , _1 > ,) ; } pub mod bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BoundedVec < _0 > (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > ,) ; } pub mod weak_bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct WeakBoundedVec < _0 > (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > ,) ; } } pub mod domain_runtime_primitives { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum MultiAccountId { # [codec (index = 0)] AccountId32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 1)] AccountId20 ([:: core :: primitive :: u8 ; 20usize] ,) , # [codec (index = 2)] Raw (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , } } pub mod frame_support { use super :: runtime_types ; pub mod dispatch { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum DispatchClass { # [codec (index = 0)] Normal , # [codec (index = 1)] Operational , # [codec (index = 2)] Mandatory , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Pays { # [codec (index = 0)] Yes , # [codec (index = 1)] No , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PerDispatchClass < _0 > { pub normal : _0 , pub operational : _0 , pub mandatory : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RawOrigin < _0 > { # [codec (index = 0)] Root , # [codec (index = 1)] Signed (_0 ,) , # [codec (index = 2)] None , } } pub mod traits { use super :: runtime_types ; pub mod preimages { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Bounded < _0 , _1 > { # [codec (index = 0)] Legacy { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 1)] Inline (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ,) , # [codec (index = 2)] Lookup { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , len : :: core :: primitive :: u32 , } , __Ignore (:: core :: marker :: PhantomData < (_0 , _1) >) , } } pub mod tokens { use super :: runtime_types ; pub mod fungible { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct HoldConsideration (pub :: core :: primitive :: u128 ,) ; } pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum BalanceStatus { # [codec (index = 0)] Free , # [codec (index = 1)] Reserved , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct IdAmount < _0 , _1 > { pub id : _0 , pub amount : _1 , } } } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PalletId (pub [:: core :: primitive :: u8 ; 8usize] ,) ; } pub mod frame_system { use super :: runtime_types ; pub mod extensions { use super :: runtime_types ; pub mod check_genesis { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckGenesis ; } pub mod check_mortality { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckMortality (pub runtime_types :: sp_runtime :: generic :: era :: Era ,) ; } pub mod check_non_zero_sender { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckNonZeroSender ; } pub mod check_nonce { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckNonce (# [codec (compact)] pub :: core :: primitive :: u32 ,) ; } pub mod check_spec_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckSpecVersion ; } pub mod check_tx_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckTxVersion ; } pub mod check_weight { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckWeight ; } } pub mod limits { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockLength { pub max : runtime_types :: frame_support :: dispatch :: PerDispatchClass < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockWeights { pub base_block : runtime_types :: sp_weights :: weight_v2 :: Weight , pub max_block : runtime_types :: sp_weights :: weight_v2 :: Weight , pub per_class : runtime_types :: frame_support :: dispatch :: PerDispatchClass < runtime_types :: frame_system :: limits :: WeightsPerClass > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct WeightsPerClass { pub base_extrinsic : runtime_types :: sp_weights :: weight_v2 :: Weight , pub max_extrinsic : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , pub max_total : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , pub reserved : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "Can be executed by every `origin`."] remark { remark : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Set the number of pages in the WebAssembly environment's heap."] set_heap_pages { pages : :: core :: primitive :: u64 , } , # [codec (index = 2)] # [doc = "Set the new runtime code."] set_code { code : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 3)] # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"] # [doc = "version!"] set_code_without_checks { code : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "Set some items of storage."] set_storage { items : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } , # [codec (index = 5)] # [doc = "Kill some items from storage."] kill_storage { keys : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 6)] # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] kill_prefix { prefix : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Make some on-chain remark and emit event."] remark_with_event { remark : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 9)] # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "This call requires Root origin."] authorize_upgrade { code_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 10)] # [doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"] # [doc = "later."] # [doc = ""] # [doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"] # [doc = "example that the spec name remains the same and that the version number increases. Not"] # [doc = "recommended for normal use. Use `authorize_upgrade` instead."] # [doc = ""] # [doc = "This call requires Root origin."] authorize_upgrade_without_checks { code_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 11)] # [doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."] # [doc = ""] # [doc = "If the authorization required a version check, this call will ensure the spec name"] # [doc = "remains unchanged and that the spec version has increased."] # [doc = ""] # [doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"] # [doc = "the new `code` in the same block or attempt to schedule the upgrade."] # [doc = ""] # [doc = "All origins are allowed."] apply_authorized_upgrade { code : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Error for the System pallet"] pub enum Error { # [codec (index = 0)] # [doc = "The name of specification does not match between the current runtime"] # [doc = "and the new runtime."] InvalidSpecName , # [codec (index = 1)] # [doc = "The specification version is not allowed to decrease between the current runtime"] # [doc = "and the new runtime."] SpecVersionNeedsToIncrease , # [codec (index = 2)] # [doc = "Failed to extract the runtime version from the new runtime."] # [doc = ""] # [doc = "Either calling `Core_version` or decoding `RuntimeVersion` failed."] FailedToExtractRuntimeVersion , # [codec (index = 3)] # [doc = "Suicide called when the account has non-default composite data."] NonDefaultComposite , # [codec (index = 4)] # [doc = "There is a non-zero reference count preventing the account from being purged."] NonZeroRefCount , # [codec (index = 5)] # [doc = "The origin filter prevent the call to be dispatched."] CallFiltered , # [codec (index = 6)] # [doc = "A multi-block migration is ongoing and prevents the current code from being replaced."] MultiBlockMigrationsOngoing , # [codec (index = 7)] # [doc = "No upgrade authorized."] NothingAuthorized , # [codec (index = 8)] # [doc = "The submitted code is not authorized."] Unauthorized , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Event for the System pallet."] pub enum Event { # [codec (index = 0)] # [doc = "An extrinsic completed successfully."] ExtrinsicSuccess { dispatch_info : runtime_types :: frame_system :: DispatchEventInfo , } , # [codec (index = 1)] # [doc = "An extrinsic failed."] ExtrinsicFailed { dispatch_error : runtime_types :: sp_runtime :: DispatchError , dispatch_info : runtime_types :: frame_system :: DispatchEventInfo , } , # [codec (index = 2)] # [doc = "`:code` was updated."] CodeUpdated , # [codec (index = 3)] # [doc = "A new account was created."] NewAccount { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 4)] # [doc = "An account was reaped."] KilledAccount { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 5)] # [doc = "On on-chain remark happened."] Remarked { sender : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 6)] # [doc = "An upgrade was authorized."] UpgradeAuthorized { code_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , check_version : :: core :: primitive :: bool , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct AccountInfo < _0 , _1 > { pub nonce : _0 , pub consumers : :: core :: primitive :: u32 , pub providers : :: core :: primitive :: u32 , pub sufficients : :: core :: primitive :: u32 , pub data : _1 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CodeUpgradeAuthorization { pub code_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , pub check_version : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DispatchEventInfo { pub weight : runtime_types :: sp_weights :: weight_v2 :: Weight , pub class : runtime_types :: frame_support :: dispatch :: DispatchClass , pub pays_fee : runtime_types :: frame_support :: dispatch :: Pays , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EventRecord < _0 , _1 > { pub phase : runtime_types :: frame_system :: Phase , pub event : _0 , pub topics : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _1 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct LastRuntimeUpgradeInfo { # [codec (compact)] pub spec_version : :: core :: primitive :: u32 , pub spec_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Phase { # [codec (index = 0)] ApplyExtrinsic (:: core :: primitive :: u32 ,) , # [codec (index = 1)] Finalization , # [codec (index = 2)] Initialization , } } pub mod pallet_balances { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] transfer_allow_death { dest : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"] # [doc = "may be specified."] force_transfer { source : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , dest : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"] # [doc = "kill the origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer_allow_death`] instead."] # [doc = ""] # [doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"] transfer_keep_alive { dest : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true)."] transfer_all { dest : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , keep_alive : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] force_unreserve { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Upgrade a specified account."] # [doc = ""] # [doc = "- `origin`: Must be `Signed`."] # [doc = "- `who`: The account to be upgraded."] # [doc = ""] # [doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"] # [doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"] # [doc = "possibility of churn)."] upgrade_accounts { who : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , } , # [codec (index = 8)] # [doc = "Set the regular balance of a given account."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] force_set_balance { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , # [codec (compact)] new_free : :: core :: primitive :: u128 , } , # [codec (index = 9)] # [doc = "Adjust the total issuance in a saturating way."] # [doc = ""] # [doc = "Can only be called by root and always needs a positive `delta`."] # [doc = ""] # [doc = "# Example"] force_adjust_total_issuance { direction : runtime_types :: pallet_balances :: types :: AdjustmentDirection , # [codec (compact)] delta : :: core :: primitive :: u128 , } , # [codec (index = 10)] # [doc = "Burn the specified liquid free balance from the origin account."] # [doc = ""] # [doc = "If the origin's account ends up below the existential deposit as a result"] # [doc = "of the burn and `keep_alive` is false, the account will be reaped."] # [doc = ""] # [doc = "Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,"] # [doc = "this `burn` operation will reduce total issuance by the amount _burned_."] burn { # [codec (compact)] value : :: core :: primitive :: u128 , keep_alive : :: core :: primitive :: bool , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Vesting balance too high to send value."] VestingBalance , # [codec (index = 1)] # [doc = "Account liquidity restrictions prevent withdrawal."] LiquidityRestrictions , # [codec (index = 2)] # [doc = "Balance too low to send value."] InsufficientBalance , # [codec (index = 3)] # [doc = "Value too low to create account due to existential deposit."] ExistentialDeposit , # [codec (index = 4)] # [doc = "Transfer/payment would kill account."] Expendability , # [codec (index = 5)] # [doc = "A vesting schedule already exists for this account."] ExistingVestingSchedule , # [codec (index = 6)] # [doc = "Beneficiary account must pre-exist."] DeadAccount , # [codec (index = 7)] # [doc = "Number of named reserves exceed `MaxReserves`."] TooManyReserves , # [codec (index = 8)] # [doc = "Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`."] TooManyHolds , # [codec (index = 9)] # [doc = "Number of freezes exceed `MaxFreezes`."] TooManyFreezes , # [codec (index = 10)] # [doc = "The issuance cannot be modified since it is already deactivated."] IssuanceDeactivated , # [codec (index = 11)] # [doc = "The delta cannot be zero."] DeltaZero , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "An account was created with some free balance."] Endowed { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , free_balance : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] DustLost { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Transfer succeeded."] Transfer { from : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , to : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "A balance was set by root."] BalanceSet { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , free : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Some balance was reserved (moved from free to reserved)."] Reserved { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Some balance was unreserved (moved from reserved to free)."] Unreserved { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] ReserveRepatriated { from : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , to : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , destination_status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } , # [codec (index = 7)] # [doc = "Some amount was deposited (e.g. for transaction fees)."] Deposit { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] Withdraw { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 9)] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] Slashed { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 10)] # [doc = "Some amount was minted into an account."] Minted { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 11)] # [doc = "Some amount was burned from an account."] Burned { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 12)] # [doc = "Some amount was suspended from an account (it can be restored later)."] Suspended { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 13)] # [doc = "Some amount was restored into an account."] Restored { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 14)] # [doc = "An account was upgraded."] Upgraded { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 15)] # [doc = "Total issuance was increased by `amount`, creating a credit to be balanced."] Issued { amount : :: core :: primitive :: u128 , } , # [codec (index = 16)] # [doc = "Total issuance was decreased by `amount`, creating a debt to be balanced."] Rescinded { amount : :: core :: primitive :: u128 , } , # [codec (index = 17)] # [doc = "Some balance was locked."] Locked { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 18)] # [doc = "Some balance was unlocked."] Unlocked { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 19)] # [doc = "Some balance was frozen."] Frozen { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 20)] # [doc = "Some balance was thawed."] Thawed { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 21)] # [doc = "The `TotalIssuance` was forcefully changed."] TotalIssuanceForced { old : :: core :: primitive :: u128 , new : :: core :: primitive :: u128 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct AccountData < _0 > { pub free : _0 , pub reserved : _0 , pub frozen : _0 , pub flags : runtime_types :: pallet_balances :: types :: ExtraFlags , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum AdjustmentDirection { # [codec (index = 0)] Increase , # [codec (index = 1)] Decrease , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BalanceLock < _0 > { pub id : [:: core :: primitive :: u8 ; 8usize] , pub amount : _0 , pub reasons : runtime_types :: pallet_balances :: types :: Reasons , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExtraFlags (pub :: core :: primitive :: u128 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Reasons { # [codec (index = 0)] Fee , # [codec (index = 1)] Misc , # [codec (index = 2)] All , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ReserveData < _0 , _1 > { pub id : _0 , pub amount : _1 , } } } pub mod pallet_collective { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "The dispatch of this call must be `SetMembersOrigin`."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] set_members { new_members : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , old_count : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "## Complexity:"] # [doc = "- `O(B + M + P)` where:"] # [doc = "- `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "- `M` members-count (code-bounded)"] # [doc = "- `P` complexity of dispatching `proposal`"] execute { proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] propose { # [codec (compact)] threshold : :: core :: primitive :: u32 , proposal : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "## Complexity"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] vote { proposal : :: subxt :: ext :: subxt_core :: utils :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(P) where P is the number of max proposals"] disapprove_proposal { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 6)] # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] close { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , proposal_weight_bound : runtime_types :: sp_weights :: weight_v2 :: Weight , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Disapprove the proposal and burn the cost held for storing this proposal."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: must be the `KillOrigin`."] # [doc = "- `proposal_hash`: The hash of the proposal that should be killed."] # [doc = ""] # [doc = "Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal."] kill { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 8)] # [doc = "Release the cost held for storing a proposal once the given proposal is completed."] # [doc = ""] # [doc = "If there is no associated cost for the given proposal, this call will have no effect."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: must be `Signed` or `Root`."] # [doc = "- `proposal_hash`: The hash of the proposal."] # [doc = ""] # [doc = "Emits `ProposalCostReleased` if any cost held for a given proposal."] release_proposal_cost { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Account is not a member"] NotMember , # [codec (index = 1)] # [doc = "Duplicate proposals not allowed"] DuplicateProposal , # [codec (index = 2)] # [doc = "Proposal must exist"] ProposalMissing , # [codec (index = 3)] # [doc = "Mismatched index"] WrongIndex , # [codec (index = 4)] # [doc = "Duplicate vote ignored"] DuplicateVote , # [codec (index = 5)] # [doc = "Members are already initialized!"] AlreadyInitialized , # [codec (index = 6)] # [doc = "The close call was made too early, before the end of the voting."] TooEarly , # [codec (index = 7)] # [doc = "There can only be a maximum of `MaxProposals` active proposals."] TooManyProposals , # [codec (index = 8)] # [doc = "The given weight bound for the proposal was too low."] WrongProposalWeight , # [codec (index = 9)] # [doc = "The given length bound for the proposal was too low."] WrongProposalLength , # [codec (index = 10)] # [doc = "Prime account is not a member"] PrimeAccountNotMember , # [codec (index = 11)] # [doc = "Proposal is still active."] ProposalActive , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] Proposed { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proposal_index : :: core :: primitive :: u32 , proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] Voted { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , voted : :: core :: primitive :: bool , yes : :: core :: primitive :: u32 , no : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "A motion was approved by the required threshold."] Approved { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 3)] # [doc = "A motion was not approved by the required threshold."] Disapproved { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 4)] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] Executed { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 5)] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] MemberExecuted { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 6)] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] Closed { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , yes : :: core :: primitive :: u32 , no : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "A proposal was killed."] Killed { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 8)] # [doc = "Some cost for storing a proposal was burned."] ProposalCostBurned { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 9)] # [doc = "Some cost for storing a proposal was released."] ProposalCostReleased { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RawOrigin < _0 > { # [codec (index = 0)] Members (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , # [codec (index = 1)] Member (_0 ,) , # [codec (index = 2)] _Phantom , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Votes < _0 , _1 > { pub index : :: core :: primitive :: u32 , pub threshold : :: core :: primitive :: u32 , pub ayes : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > , pub nays : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > , pub end : _1 , } } pub mod pallet_democracy { use super :: runtime_types ; pub mod conviction { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Conviction { # [codec (index = 0)] None , # [codec (index = 1)] Locked1x , # [codec (index = 2)] Locked2x , # [codec (index = 3)] Locked3x , # [codec (index = 4)] Locked4x , # [codec (index = 5)] Locked5x , # [codec (index = 6)] Locked6x , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Propose a sensitive action to be taken."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender must"] # [doc = "have funds to cover the deposit."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the proposal preimage."] # [doc = "- `value`: The amount of deposit (must be at least `MinimumDeposit`)."] # [doc = ""] # [doc = "Emits `Proposed`."] propose { proposal : runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Signals agreement with a particular proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender"] # [doc = "must have funds to cover the deposit, equal to the original deposit."] # [doc = ""] # [doc = "- `proposal`: The index of the proposal to second."] second { # [codec (compact)] proposal : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;"] # [doc = "otherwise it is a vote to keep the status quo."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to vote for."] # [doc = "- `vote`: The vote configuration."] vote { # [codec (compact)] ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } , # [codec (index = 3)] # [doc = "Schedule an emergency cancellation of a referendum. Cannot happen twice to the same"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancellationOrigin`."] # [doc = ""] # [doc = "-`ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(1)`."] emergency_cancel { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Schedule a referendum to be tabled once it is legal to schedule an external"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `ExternalOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] external_propose { proposal : runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , } , # [codec (index = 5)] # [doc = "Schedule a majority-carries referendum to be tabled next once it is legal to schedule"] # [doc = "an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalMajorityOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] external_propose_majority { proposal : runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , } , # [codec (index = 6)] # [doc = "Schedule a negative-turnout-bias referendum to be tabled next once it is legal to"] # [doc = "schedule an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalDefaultOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] external_propose_default { proposal : runtime_types :: frame_support :: traits :: preimages :: Bounded < runtime_types :: subspace_runtime :: RuntimeCall , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , } , # [codec (index = 7)] # [doc = "Schedule the currently externally-proposed majority-carries referendum to be tabled"] # [doc = "immediately. If there is no externally-proposed referendum currently, or if there is one"] # [doc = "but it is not a majority-carries referendum then it fails."] # [doc = ""] # [doc = "The dispatch of this call must be `FastTrackOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the current external proposal."] # [doc = "- `voting_period`: The period that is allowed for voting on this proposal. Increased to"] # [doc = "\tMust be always greater than zero."] # [doc = "\tFor `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`."] # [doc = "- `delay`: The number of block after voting has ended in approval and this should be"] # [doc = "  enacted. This doesn't have a minimum amount."] # [doc = ""] # [doc = "Emits `Started`."] # [doc = ""] # [doc = "Weight: `O(1)`"] fast_track { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , voting_period : :: core :: primitive :: u32 , delay : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Veto and blacklist the external proposal hash."] # [doc = ""] # [doc = "The dispatch origin of this call must be `VetoOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal to veto and blacklist."] # [doc = ""] # [doc = "Emits `Vetoed`."] # [doc = ""] # [doc = "Weight: `O(V + log(V))` where V is number of `existing vetoers`"] veto_external { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 9)] # [doc = "Remove a referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "# Weight: `O(1)`."] cancel_referendum { # [codec (compact)] ref_index : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "Delegate the voting power (with some given conviction) of the sending account."] # [doc = ""] # [doc = "The balance delegated is locked for as long as it's delegated, and thereafter for the"] # [doc = "time appropriate for the conviction's lock period."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signing account must either:"] # [doc = "  - be delegating already; or"] # [doc = "  - have no voting activity (if there is, then it will need to be removed/consolidated"] # [doc = "    through `reap_vote` or `unvote`)."] # [doc = ""] # [doc = "- `to`: The account whose voting the `target` account's voting power will follow."] # [doc = "- `conviction`: The conviction that will be attached to the delegated votes. When the"] # [doc = "  account is undelegated, the funds will be locked for the corresponding period."] # [doc = "- `balance`: The amount of the account's balance to be used in delegating. This must not"] # [doc = "  be more than the account's current balance."] # [doc = ""] # [doc = "Emits `Delegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] delegate { to : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , balance : :: core :: primitive :: u128 , } , # [codec (index = 11)] # [doc = "Undelegate the voting power of the sending account."] # [doc = ""] # [doc = "Tokens may be unlocked following once an amount of time consistent with the lock period"] # [doc = "of the conviction with which the delegation was issued."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the signing account must be"] # [doc = "currently delegating."] # [doc = ""] # [doc = "Emits `Undelegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] undelegate , # [codec (index = 12)] # [doc = "Clears all public proposals."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "Weight: `O(1)`."] clear_public_proposals , # [codec (index = 13)] # [doc = "Unlock tokens that have an expired lock."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account to remove the lock on."] # [doc = ""] # [doc = "Weight: `O(R)` with R number of vote of target."] unlock { target : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , } , # [codec (index = 14)] # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If:"] # [doc = "- the referendum was cancelled, or"] # [doc = "- the referendum is ongoing, or"] # [doc = "- the referendum has ended such that"] # [doc = "  - the vote of the account was in opposition to the result; or"] # [doc = "  - there was no conviction to the account's vote; or"] # [doc = "  - the account made a split vote"] # [doc = "...then the vote is removed cleanly and a following call to `unlock` may result in more"] # [doc = "funds being available."] # [doc = ""] # [doc = "If, however, the referendum has ended and:"] # [doc = "- it finished corresponding to the vote of the account, and"] # [doc = "- the account made a standard vote with conviction, and"] # [doc = "- the lock period of the conviction is not over"] # [doc = "...then the lock will be aggregated into the overall account's lock, which may involve"] # [doc = "*overlocking* (where the two locks are combined into a single lock that is the maximum"] # [doc = "of both the amount locked and the time is it locked for)."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signer must have a vote"] # [doc = "registered for referendum `index`."] # [doc = ""] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] remove_vote { index : :: core :: primitive :: u32 , } , # [codec (index = 15)] # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If the `target` is equal to the signer, then this function is exactly equivalent to"] # [doc = "`remove_vote`. If not equal to the signer, then the vote must have expired,"] # [doc = "either because the referendum was cancelled, because the voter lost the referendum or"] # [doc = "because the conviction period is over."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account of the vote to be removed; this account must have voted for"] # [doc = "  referendum `index`."] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] remove_other_vote { target : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , index : :: core :: primitive :: u32 , } , # [codec (index = 16)] # [doc = "Permanently place a proposal into the blacklist. This prevents it from ever being"] # [doc = "proposed again."] # [doc = ""] # [doc = "If called on a queued public or external proposal, then this will result in it being"] # [doc = "removed. If the `ref_index` supplied is an active referendum with the proposal hash,"] # [doc = "then it will be cancelled."] # [doc = ""] # [doc = "The dispatch origin of this call must be `BlacklistOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The proposal hash to blacklist permanently."] # [doc = "- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be"] # [doc = "cancelled."] # [doc = ""] # [doc = "Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a"] # [doc = "  reasonable value)."] blacklist { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > , } , # [codec (index = 17)] # [doc = "Remove a proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancelProposalOrigin`."] # [doc = ""] # [doc = "- `prop_index`: The index of the proposal to cancel."] # [doc = ""] # [doc = "Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"] cancel_proposal { # [codec (compact)] prop_index : :: core :: primitive :: u32 , } , # [codec (index = 18)] # [doc = "Set or clear a metadata of a proposal or a referendum."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `origin`: Must correspond to the `MetadataOwner`."] # [doc = "    - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`"] # [doc = "      threshold."] # [doc = "    - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`"] # [doc = "      threshold."] # [doc = "    - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`"] # [doc = "      threshold."] # [doc = "    - `Signed` by a creator for a public proposal."] # [doc = "    - `Signed` to clear a metadata for a finished referendum."] # [doc = "    - `Root` to set a metadata for an ongoing referendum."] # [doc = "- `owner`: an identifier of a metadata owner."] # [doc = "- `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata."] set_metadata { owner : runtime_types :: pallet_democracy :: types :: MetadataOwner , maybe_hash : :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: H256 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Value too low"] ValueLow , # [codec (index = 1)] # [doc = "Proposal does not exist"] ProposalMissing , # [codec (index = 2)] # [doc = "Cannot cancel the same proposal twice"] AlreadyCanceled , # [codec (index = 3)] # [doc = "Proposal already made"] DuplicateProposal , # [codec (index = 4)] # [doc = "Proposal still blacklisted"] ProposalBlacklisted , # [codec (index = 5)] # [doc = "Next external proposal not simple majority"] NotSimpleMajority , # [codec (index = 6)] # [doc = "Invalid hash"] InvalidHash , # [codec (index = 7)] # [doc = "No external proposal"] NoProposal , # [codec (index = 8)] # [doc = "Identity may not veto a proposal twice"] AlreadyVetoed , # [codec (index = 9)] # [doc = "Vote given for invalid referendum"] ReferendumInvalid , # [codec (index = 10)] # [doc = "No proposals waiting"] NoneWaiting , # [codec (index = 11)] # [doc = "The given account did not vote on the referendum."] NotVoter , # [codec (index = 12)] # [doc = "The actor has no permission to conduct the action."] NoPermission , # [codec (index = 13)] # [doc = "The account is already delegating."] AlreadyDelegating , # [codec (index = 14)] # [doc = "Too high a balance was provided that the account cannot afford."] InsufficientFunds , # [codec (index = 15)] # [doc = "The account is not currently delegating."] NotDelegating , # [codec (index = 16)] # [doc = "The account currently has votes attached to it and the operation cannot succeed until"] # [doc = "these are removed, either through `unvote` or `reap_vote`."] VotesExist , # [codec (index = 17)] # [doc = "The instant referendum origin is currently disallowed."] InstantNotAllowed , # [codec (index = 18)] # [doc = "Delegation to oneself makes no sense."] Nonsense , # [codec (index = 19)] # [doc = "Invalid upper bound."] WrongUpperBound , # [codec (index = 20)] # [doc = "Maximum number of votes reached."] MaxVotesReached , # [codec (index = 21)] # [doc = "Maximum number of items reached."] TooMany , # [codec (index = 22)] # [doc = "Voting period too low"] VotingPeriodLow , # [codec (index = 23)] # [doc = "The preimage does not exist."] PreimageNotExist , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A motion has been proposed by a public account."] Proposed { proposal_index : :: core :: primitive :: u32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "A public proposal has been tabled for referendum vote."] Tabled { proposal_index : :: core :: primitive :: u32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "An external proposal has been tabled."] ExternalTabled , # [codec (index = 3)] # [doc = "A referendum has begun."] Started { ref_index : :: core :: primitive :: u32 , threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , } , # [codec (index = 4)] # [doc = "A proposal has been approved by referendum."] Passed { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "A proposal has been rejected by referendum."] NotPassed { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "A referendum has been cancelled."] Cancelled { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "An account has delegated their vote to another account."] Delegated { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , target : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 8)] # [doc = "An account has cancelled a previous delegation operation."] Undelegated { account : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 9)] # [doc = "An external proposal has been vetoed."] Vetoed { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , until : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "A proposal_hash has been blacklisted permanently."] Blacklisted { proposal_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 11)] # [doc = "An account has voted in a referendum"] Voted { voter : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } , # [codec (index = 12)] # [doc = "An account has seconded a proposal"] Seconded { seconder : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , prop_index : :: core :: primitive :: u32 , } , # [codec (index = 13)] # [doc = "A proposal got canceled."] ProposalCanceled { prop_index : :: core :: primitive :: u32 , } , # [codec (index = 14)] # [doc = "Metadata for a proposal or a referendum has been set."] MetadataSet { owner : runtime_types :: pallet_democracy :: types :: MetadataOwner , hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 15)] # [doc = "Metadata for a proposal or a referendum has been cleared."] MetadataCleared { owner : runtime_types :: pallet_democracy :: types :: MetadataOwner , hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 16)] # [doc = "Metadata has been transferred to new owner."] MetadataTransferred { prev_owner : runtime_types :: pallet_democracy :: types :: MetadataOwner , owner : runtime_types :: pallet_democracy :: types :: MetadataOwner , hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Delegations < _0 > { pub votes : _0 , pub capital : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum MetadataOwner { # [codec (index = 0)] External , # [codec (index = 1)] Proposal (:: core :: primitive :: u32 ,) , # [codec (index = 2)] Referendum (:: core :: primitive :: u32 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ReferendumInfo < _0 , _1 , _2 > { # [codec (index = 0)] Ongoing (runtime_types :: pallet_democracy :: types :: ReferendumStatus < _0 , _1 , _2 > ,) , # [codec (index = 1)] Finished { approved : :: core :: primitive :: bool , end : _0 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ReferendumStatus < _0 , _1 , _2 > { pub end : _0 , pub proposal : _1 , pub threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , pub delay : _0 , pub tally : runtime_types :: pallet_democracy :: types :: Tally < _2 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Tally < _0 > { pub ayes : _0 , pub nays : _0 , pub turnout : _0 , } } pub mod vote { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum AccountVote < _0 > { # [codec (index = 0)] Standard { vote : runtime_types :: pallet_democracy :: vote :: Vote , balance : _0 , } , # [codec (index = 1)] Split { aye : _0 , nay : _0 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PriorLock < _0 , _1 > (pub _0 , pub _1 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Vote (pub :: core :: primitive :: u8 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Voting < _0 , _1 , _2 > { # [codec (index = 0)] Direct { votes : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < (_2 , runtime_types :: pallet_democracy :: vote :: AccountVote < _0 > ,) > , delegations : runtime_types :: pallet_democracy :: types :: Delegations < _0 > , prior : runtime_types :: pallet_democracy :: vote :: PriorLock < _2 , _0 > , } , # [codec (index = 1)] Delegating { balance : _0 , target : _1 , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , delegations : runtime_types :: pallet_democracy :: types :: Delegations < _0 > , prior : runtime_types :: pallet_democracy :: vote :: PriorLock < _2 , _0 > , } , } } pub mod vote_threshold { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum VoteThreshold { # [codec (index = 0)] SuperMajorityApprove , # [codec (index = 1)] SuperMajorityAgainst , # [codec (index = 2)] SimpleMajority , } } } pub mod pallet_domains { use super :: runtime_types ; pub mod block_tree { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockTreeNode < _0 , _1 , _2 , _3 , _4 > { pub execution_receipt : runtime_types :: sp_domains :: ExecutionReceipt < _0 , _1 , _0 , _1 , _4 > , pub operator_ids : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < (_2 , _3) > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Error { # [codec (index = 0)] InvalidExtrinsicsRoots , # [codec (index = 1)] UnknownParentBlockReceipt , # [codec (index = 2)] BuiltOnUnknownConsensusBlock , # [codec (index = 3)] InFutureReceipt , # [codec (index = 4)] PrunedReceipt , # [codec (index = 5)] StaleReceipt , # [codec (index = 6)] NewBranchReceipt , # [codec (index = 7)] BadGenesisReceipt , # [codec (index = 8)] UnexpectedReceiptType , # [codec (index = 9)] MaxHeadDomainNumber , # [codec (index = 10)] MissingDomainBlock , # [codec (index = 11)] InvalidTraceRoot , # [codec (index = 12)] InvalidExecutionTrace , # [codec (index = 13)] UnavailableConsensusBlockHash , # [codec (index = 14)] InvalidStateRoot , # [codec (index = 15)] BalanceOverflow , # [codec (index = 16)] DomainTransfersTracking , # [codec (index = 17)] InvalidDomainTransfers , # [codec (index = 18)] OverwritingER , # [codec (index = 19)] RuntimeNotFound , # [codec (index = 20)] LastBlockNotFound , # [codec (index = 21)] UnmatchedNewHeadReceipt , } } pub mod bundle_storage_fund { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Error { # [codec (index = 0)] BundleStorageFeePayment , # [codec (index = 1)] BalanceUnderflow , # [codec (index = 2)] MintBalance , # [codec (index = 3)] FailToDeposit , # [codec (index = 4)] WithdrawAndHold , # [codec (index = 5)] BalanceTransfer , # [codec (index = 6)] FailToWithdraw , } } pub mod domain_registry { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainConfig < _0 , _1 > { pub domain_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , pub runtime_id : :: core :: primitive :: u32 , pub max_bundle_size : :: core :: primitive :: u32 , pub max_bundle_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , pub bundle_slot_probability : (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) , pub operator_allow_list : runtime_types :: sp_domains :: OperatorAllowList < _0 > , pub initial_balances : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: domain_runtime_primitives :: MultiAccountId , _1 ,) > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainConfigParams < _0 , _1 > { pub domain_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , pub runtime_id : :: core :: primitive :: u32 , pub maybe_bundle_limit : :: core :: option :: Option < runtime_types :: sp_domains :: DomainBundleLimit > , pub bundle_slot_probability : (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) , pub operator_allow_list : runtime_types :: sp_domains :: OperatorAllowList < _0 > , pub initial_balances : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (runtime_types :: domain_runtime_primitives :: MultiAccountId , _1 ,) > , pub domain_runtime_config : runtime_types :: sp_domains :: DomainRuntimeConfig , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainObject < _0 , _1 , _2 , _3 > { pub owner_account_id : _2 , pub created_at : _0 , pub genesis_receipt_hash : _1 , pub domain_config : runtime_types :: pallet_domains :: domain_registry :: DomainConfig < _2 , _3 > , pub domain_runtime_info : runtime_types :: pallet_domains :: runtime_registry :: DomainRuntimeInfo , pub domain_instantiation_deposit : _3 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Error { # [codec (index = 0)] ExceedMaxDomainBlockWeight , # [codec (index = 1)] ExceedMaxDomainBlockSize , # [codec (index = 2)] MaxDomainId , # [codec (index = 3)] MaxEVMChainId , # [codec (index = 4)] InvalidSlotProbability , # [codec (index = 5)] RuntimeNotFound , # [codec (index = 6)] InsufficientFund , # [codec (index = 7)] DomainNameTooLong , # [codec (index = 8)] BalanceFreeze , # [codec (index = 9)] FailedToGenerateGenesisStateRoot , # [codec (index = 10)] DomainNotFound , # [codec (index = 11)] NotDomainOwner , # [codec (index = 12)] InitialBalanceOverflow , # [codec (index = 13)] TransfersTracker , # [codec (index = 14)] MinInitialAccountBalance , # [codec (index = 15)] MaxInitialDomainAccounts , # [codec (index = 16)] DuplicateInitialAccounts , # [codec (index = 17)] FailedToGenerateRawGenesis (runtime_types :: pallet_domains :: runtime_registry :: Error ,) , # [codec (index = 18)] BundleLimitCalculationOverflow , # [codec (index = 19)] InvalidConfigForRuntimeType , } } pub mod extensions { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainsExtension < _0 > (pub :: core :: marker :: PhantomData < _0 >) ; } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] submit_bundle { opaque_bundle : runtime_types :: sp_domains :: Bundle < runtime_types :: sp_runtime :: OpaqueExtrinsic , :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: core :: primitive :: u128 > , } , # [codec (index = 15)] submit_fraud_proof { fraud_proof : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: sp_domains_fraud_proof :: fraud_proof :: FraudProof < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: subxt :: ext :: subxt_core :: utils :: H256 > > , } , # [codec (index = 2)] register_domain_runtime { runtime_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , runtime_type : runtime_types :: sp_domains :: RuntimeType , raw_genesis_storage : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 3)] upgrade_domain_runtime { runtime_id : :: core :: primitive :: u32 , raw_genesis_storage : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] register_operator { domain_id : runtime_types :: sp_domains :: DomainId , amount : :: core :: primitive :: u128 , config : runtime_types :: pallet_domains :: staking :: OperatorConfig < :: core :: primitive :: u128 > , } , # [codec (index = 5)] nominate_operator { operator_id : :: core :: primitive :: u64 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] instantiate_domain { domain_config_params : runtime_types :: pallet_domains :: domain_registry :: DomainConfigParams < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , :: core :: primitive :: u128 > , } , # [codec (index = 8)] deregister_operator { operator_id : :: core :: primitive :: u64 , } , # [codec (index = 9)] withdraw_stake { operator_id : :: core :: primitive :: u64 , to_withdraw : :: core :: primitive :: u128 , } , # [codec (index = 10)] # [doc = "Unlocks the first withdrawal given the unlocking period is complete."] # [doc = "Even if the rest of the withdrawals are out of the unlocking period, the nominator"] # [doc = "should call this extrinsic to unlock each withdrawal"] unlock_funds { operator_id : :: core :: primitive :: u64 , } , # [codec (index = 11)] # [doc = "Unlocks the nominator under given operator given the unlocking period is complete."] # [doc = "A nominator can initiate their unlock given operator is already deregistered."] unlock_nominator { operator_id : :: core :: primitive :: u64 , } , # [codec (index = 12)] # [doc = "Extrinsic to update domain's operator allow list."] # [doc = "Note:"] # [doc = "- If the previous allowed list is set to specific operators and new allow list is set"] # [doc = "  to `Anyone`, then domain will become permissioned to open for all operators."] # [doc = "- If the previous allowed list is set to `Anyone` or specific operators and the new"] # [doc = "  allow list is set to specific operators, then all the registered not allowed operators"] # [doc = "  will continue to operate until they de-register themselves."] update_domain_operator_allow_list { domain_id : runtime_types :: sp_domains :: DomainId , operator_allow_list : runtime_types :: sp_domains :: OperatorAllowList < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , } , # [codec (index = 13)] # [doc = "Force staking epoch transition for a given domain"] force_staking_epoch_transition { domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 14)] # [doc = "Update permissioned action allowed by storage by Sudo."] set_permissioned_action_allowed_by { permissioned_action_allowed_by : runtime_types :: sp_domains :: PermissionedActionAllowedBy < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , } , # [codec (index = 16)] # [doc = "Submit a domain sudo call."] send_domain_sudo_call { domain_id : runtime_types :: sp_domains :: DomainId , call : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 17)] # [doc = "Freezes a given domain."] # [doc = "A frozen domain does not accept new bundles but accepts fraud proofs."] freeze_domain { domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 18)] # [doc = "Unfreezes a frozen domain."] unfreeze_domain { domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 19)] # [doc = "Prunes a given execution receipt for given frozen domain."] # [doc = "This call assumes the execution receipt to be bad and implicitly trusts Sudo"] # [doc = "to do the necessary validation of the ER before dispatching this call."] prune_domain_execution_receipt { domain_id : runtime_types :: sp_domains :: DomainId , bad_receipt_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 20)] # [doc = "Transfer funds from treasury to given account"] transfer_treasury_funds { account_id : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , balance : :: core :: primitive :: u128 , } , # [codec (index = 21)] submit_receipt { singleton_receipt : runtime_types :: sp_domains :: SealedSingletonReceipt < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 > , :: core :: primitive :: u128 > , } , # [codec (index = 22)] # [doc = "Submit an EVM domain \"set contract creation allowed by\" call as domain owner or root."] send_evm_domain_set_contract_creation_allowed_by_call { domain_id : runtime_types :: sp_domains :: DomainId , contract_creation_allowed_by : runtime_types :: sp_domains :: PermissionedActionAllowedBy < :: subxt :: ext :: subxt_core :: utils :: AccountId20 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Invalid fraud proof."] FraudProof (runtime_types :: pallet_domains :: pallet :: FraudProofError ,) , # [codec (index = 1)] # [doc = "Runtime registry specific errors"] RuntimeRegistry (runtime_types :: pallet_domains :: runtime_registry :: Error ,) , # [codec (index = 2)] # [doc = "Staking related errors."] Staking (runtime_types :: pallet_domains :: staking :: Error ,) , # [codec (index = 3)] # [doc = "Staking epoch specific errors."] StakingEpoch (runtime_types :: pallet_domains :: staking_epoch :: Error ,) , # [codec (index = 4)] # [doc = "Domain registry specific errors"] DomainRegistry (runtime_types :: pallet_domains :: domain_registry :: Error ,) , # [codec (index = 5)] # [doc = "Block tree specific errors"] BlockTree (runtime_types :: pallet_domains :: block_tree :: Error ,) , # [codec (index = 6)] # [doc = "Bundle storage fund specific errors"] BundleStorageFund (runtime_types :: pallet_domains :: bundle_storage_fund :: Error ,) , # [codec (index = 7)] # [doc = "Permissioned action is not allowed by the caller."] PermissionedActionNotAllowed , # [codec (index = 8)] # [doc = "Domain Sudo call already exists."] DomainSudoCallExists , # [codec (index = 9)] # [doc = "Invalid Domain sudo call."] InvalidDomainSudoCall , # [codec (index = 10)] # [doc = "Domain must be frozen before execution receipt can be pruned."] DomainNotFrozen , # [codec (index = 11)] # [doc = "Domain is not a private EVM domain."] NotPrivateEvmDomain , # [codec (index = 12)] # [doc = "Account is not a Domain owner or root."] NotDomainOwnerOrRoot , # [codec (index = 13)] # [doc = "EVM Domain \"set contract creation allowed by\" call already exists."] EvmDomainContractCreationAllowedByCallExists , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A domain bundle was included."] BundleStored { domain_id : runtime_types :: sp_domains :: DomainId , bundle_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , bundle_author : :: core :: primitive :: u64 , } , # [codec (index = 1)] DomainRuntimeCreated { runtime_id : :: core :: primitive :: u32 , runtime_type : runtime_types :: sp_domains :: RuntimeType , } , # [codec (index = 2)] DomainRuntimeUpgradeScheduled { runtime_id : :: core :: primitive :: u32 , scheduled_at : :: core :: primitive :: u32 , } , # [codec (index = 3)] DomainRuntimeUpgraded { runtime_id : :: core :: primitive :: u32 , } , # [codec (index = 4)] OperatorRegistered { operator_id : :: core :: primitive :: u64 , domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 5)] NominatedStakedUnlocked { operator_id : :: core :: primitive :: u64 , nominator_id : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , unlocked_amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] StorageFeeUnlocked { operator_id : :: core :: primitive :: u64 , nominator_id : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , storage_fee : :: core :: primitive :: u128 , } , # [codec (index = 7)] OperatorNominated { operator_id : :: core :: primitive :: u64 , nominator_id : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 8)] DomainInstantiated { domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 9)] OperatorSwitchedDomain { old_domain_id : runtime_types :: sp_domains :: DomainId , new_domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 10)] OperatorDeregistered { operator_id : :: core :: primitive :: u64 , } , # [codec (index = 11)] NominatorUnlocked { operator_id : :: core :: primitive :: u64 , nominator_id : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 12)] WithdrewStake { operator_id : :: core :: primitive :: u64 , nominator_id : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 13)] PreferredOperator { operator_id : :: core :: primitive :: u64 , nominator_id : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 14)] OperatorRewarded { source : runtime_types :: sp_domains :: OperatorRewardSource < :: core :: primitive :: u32 > , operator_id : :: core :: primitive :: u64 , reward : :: core :: primitive :: u128 , } , # [codec (index = 15)] OperatorTaxCollected { operator_id : :: core :: primitive :: u64 , tax : :: core :: primitive :: u128 , } , # [codec (index = 16)] DomainEpochCompleted { domain_id : runtime_types :: sp_domains :: DomainId , completed_epoch_index : :: core :: primitive :: u32 , } , # [codec (index = 17)] ForceDomainEpochTransition { domain_id : runtime_types :: sp_domains :: DomainId , completed_epoch_index : :: core :: primitive :: u32 , } , # [codec (index = 18)] FraudProofProcessed { domain_id : runtime_types :: sp_domains :: DomainId , new_head_receipt_number : :: core :: option :: Option < :: core :: primitive :: u32 > , } , # [codec (index = 19)] DomainOperatorAllowListUpdated { domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 20)] OperatorSlashed { operator_id : :: core :: primitive :: u64 , reason : runtime_types :: pallet_domains :: pallet :: SlashedReason < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 > , } , # [codec (index = 21)] StorageFeeDeposited { operator_id : :: core :: primitive :: u64 , nominator_id : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 22)] DomainFrozen { domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 23)] DomainUnfrozen { domain_id : runtime_types :: sp_domains :: DomainId , } , # [codec (index = 24)] PrunedExecutionReceipt { domain_id : runtime_types :: sp_domains :: DomainId , new_head_receipt_number : :: core :: option :: Option < :: core :: primitive :: u32 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum FraudProofError { # [codec (index = 0)] BadReceiptNotFound , # [codec (index = 1)] ChallengingGenesisReceipt , # [codec (index = 2)] DescendantsOfFraudulentERNotPruned , # [codec (index = 3)] InvalidBlockFeesFraudProof , # [codec (index = 4)] InvalidTransfersFraudProof , # [codec (index = 5)] InvalidDomainBlockHashFraudProof , # [codec (index = 6)] InvalidExtrinsicRootFraudProof , # [codec (index = 7)] InvalidStateTransitionFraudProof , # [codec (index = 8)] ParentReceiptNotFound , # [codec (index = 9)] InvalidBundleFraudProof , # [codec (index = 10)] BadValidBundleFraudProof , # [codec (index = 11)] MissingOperator , # [codec (index = 12)] UnexpectedFraudProof , # [codec (index = 13)] BadReceiptAlreadyReported , # [codec (index = 14)] BadMmrProof , # [codec (index = 15)] UnexpectedMmrProof , # [codec (index = 16)] MissingMmrProof , # [codec (index = 17)] RuntimeNotFound , # [codec (index = 18)] DomainRuntimeCodeProofNotFound , # [codec (index = 19)] UnexpectedDomainRuntimeCodeProof , # [codec (index = 20)] StorageProof (runtime_types :: sp_domains_fraud_proof :: storage_proof :: VerificationError ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum SlashedReason < _0 , _1 > { # [codec (index = 0)] InvalidBundle (_0 ,) , # [codec (index = 1)] BadExecutionReceipt (_1 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct TxRangeState { pub tx_range : runtime_types :: subspace_core_primitives :: U256 , pub interval_blocks : :: core :: primitive :: u64 , pub interval_bundles : :: core :: primitive :: u64 , } } pub mod runtime_registry { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum DomainRuntimeInfo { # [codec (index = 0)] Evm { chain_id : :: core :: primitive :: u64 , domain_runtime_config : runtime_types :: sp_domains :: EvmDomainRuntimeConfig , } , # [codec (index = 1)] AutoId { domain_runtime_config : runtime_types :: sp_domains :: AutoIdDomainRuntimeConfig , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainRuntimeUpgradeEntry < _0 > { pub at_hash : _0 , pub reference_count : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Error { # [codec (index = 0)] FailedToExtractRuntimeVersion , # [codec (index = 1)] InvalidSpecName , # [codec (index = 2)] SpecVersionNeedsToIncrease , # [codec (index = 3)] MaxRuntimeId , # [codec (index = 4)] MissingRuntimeObject , # [codec (index = 5)] RuntimeUpgradeAlreadyScheduled , # [codec (index = 6)] MaxScheduledBlockNumber , # [codec (index = 7)] FailedToDecodeRawGenesis , # [codec (index = 8)] RuntimeCodeNotFoundInRawGenesis , # [codec (index = 9)] InvalidAccountIdType , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ScheduledRuntimeUpgrade < _0 > { pub raw_genesis : runtime_types :: sp_domains :: storage :: RawGenesis , pub version : runtime_types :: sp_version :: RuntimeVersion , pub hash : _0 , } } pub mod staking { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Deposit < _0 , _1 > { pub known : runtime_types :: pallet_domains :: staking :: KnownDeposit < _0 , _0 > , pub pending : :: core :: option :: Option < runtime_types :: pallet_domains :: staking :: PendingDeposit < _0 > > , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _1 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainEpoch (pub runtime_types :: sp_domains :: DomainId , pub :: core :: primitive :: u32 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Error { # [codec (index = 0)] MaximumOperatorId , # [codec (index = 1)] DomainNotInitialized , # [codec (index = 2)] PendingOperatorSwitch , # [codec (index = 3)] InsufficientBalance , # [codec (index = 4)] InsufficientShares , # [codec (index = 5)] ZeroWithdraw , # [codec (index = 6)] BalanceFreeze , # [codec (index = 7)] MinimumOperatorStake , # [codec (index = 8)] UnknownOperator , # [codec (index = 9)] MinimumNominatorStake , # [codec (index = 10)] BalanceOverflow , # [codec (index = 11)] BalanceUnderflow , # [codec (index = 12)] NotOperatorOwner , # [codec (index = 13)] OperatorNotRegistered , # [codec (index = 14)] UnknownNominator , # [codec (index = 15)] MissingOperatorOwner , # [codec (index = 16)] MintBalance , # [codec (index = 17)] BlockNumberOverflow , # [codec (index = 18)] RemoveLock , # [codec (index = 19)] EpochOverflow , # [codec (index = 20)] ShareUnderflow , # [codec (index = 21)] ShareOverflow , # [codec (index = 22)] TooManyPendingStakingOperation , # [codec (index = 23)] OperatorNotAllowed , # [codec (index = 24)] InvalidOperatorSigningKey , # [codec (index = 25)] MissingOperatorEpochSharePrice , # [codec (index = 26)] MissingWithdrawal , # [codec (index = 27)] EpochNotComplete , # [codec (index = 28)] UnlockPeriodNotComplete , # [codec (index = 29)] OperatorNotDeregistered , # [codec (index = 30)] BundleStorageFund (runtime_types :: pallet_domains :: bundle_storage_fund :: Error ,) , # [codec (index = 31)] UnconfirmedER , # [codec (index = 32)] TooManyWithdrawals , # [codec (index = 33)] ZeroDeposit , # [codec (index = 34)] ZeroSharePrice , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct KnownDeposit < _0 , _1 > { pub shares : _0 , pub storage_fee_deposit : _1 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Operator < _0 , _1 , _2 , _3 > { pub signing_key : runtime_types :: sp_domains :: app :: Public , pub current_domain_id : runtime_types :: sp_domains :: DomainId , pub next_domain_id : runtime_types :: sp_domains :: DomainId , pub minimum_nominator_stake : _0 , pub nomination_tax : runtime_types :: sp_arithmetic :: per_things :: Percent , pub current_total_stake : _0 , pub current_total_shares : _1 , pub partial_status : runtime_types :: pallet_domains :: staking :: OperatorStatus < _2 , _3 > , pub deposits_in_epoch : _0 , pub withdrawals_in_epoch : _1 , pub total_storage_fee_deposit : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorConfig < _0 > { pub signing_key : runtime_types :: sp_domains :: app :: Public , pub minimum_nominator_stake : _0 , pub nomination_tax : runtime_types :: sp_arithmetic :: per_things :: Percent , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OperatorDeregisteredInfo < _0 > { pub domain_epoch : runtime_types :: pallet_domains :: staking :: DomainEpoch , pub unlock_at_confirmed_domain_block_number : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum OperatorStatus < _0 , _1 > { # [codec (index = 0)] Registered , # [codec (index = 1)] Deregistered (runtime_types :: pallet_domains :: staking :: OperatorDeregisteredInfo < _0 > ,) , # [codec (index = 2)] Slashed , # [codec (index = 3)] PendingSlash , # [codec (index = 4)] InvalidBundle (_1 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PendingDeposit < _0 > { pub effective_domain_epoch : runtime_types :: pallet_domains :: staking :: DomainEpoch , pub amount : _0 , pub storage_fee_deposit : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SharePrice (pub runtime_types :: sp_arithmetic :: per_things :: Perquintill ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StakingSummary < _0 , _1 > { pub current_epoch_index : :: core :: primitive :: u32 , pub current_total_stake : _1 , pub current_operators : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < _0 , _1 > , pub next_operators : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > , pub current_epoch_rewards : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < _0 , _1 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Withdrawal < _0 , _1 , _2 > { pub total_withdrawal_amount : _0 , pub total_storage_fee_withdrawal : _0 , pub withdrawals : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: pallet_domains :: staking :: WithdrawalInBalance < _2 , _0 > > , pub withdrawal_in_shares : :: core :: option :: Option < runtime_types :: pallet_domains :: staking :: WithdrawalInShares < _2 , _0 , _0 > > , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _1 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct WithdrawalInBalance < _0 , _1 > { pub unlock_at_confirmed_domain_block_number : _0 , pub amount_to_unlock : _1 , pub storage_fee_refund : _1 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct WithdrawalInShares < _0 , _1 , _2 > { pub domain_epoch : runtime_types :: pallet_domains :: staking :: DomainEpoch , pub unlock_at_confirmed_domain_block_number : _0 , pub shares : _1 , pub storage_fee_refund : _2 , } } pub mod staking_epoch { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Error { # [codec (index = 0)] FinalizeDomainEpochStaking (runtime_types :: pallet_domains :: staking :: Error ,) , # [codec (index = 1)] OperatorRewardStaking (runtime_types :: pallet_domains :: staking :: Error ,) , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ElectionVerificationParams < _0 > { pub operators : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < :: core :: primitive :: u64 , _0 > , pub total_domain_stake : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RawOrigin { # [codec (index = 0)] ValidatedUnsigned , } } pub mod pallet_messenger { use super :: runtime_types ; pub mod extensions { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MessengerExtension < _0 > (pub :: core :: marker :: PhantomData < _0 >) ; } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "A new Channel is initiated with a foreign chain."] # [doc = "Next Channel ID is used to assign the new channel."] # [doc = "Channel is set to initiated and do not accept or receive any messages."] initiate_channel { dst_chain_id : runtime_types :: sp_domains :: ChainId , } , # [codec (index = 1)] # [doc = "An open channel is closed with a foreign chain."] # [doc = "Channel is set to Closed and do not accept or receive any messages."] close_channel { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , } , # [codec (index = 2)] # [doc = "Receives an Inbox message that needs to be validated and processed."] relay_message { msg : runtime_types :: sp_messenger :: messages :: CrossDomainMessage < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: H256 > , } , # [codec (index = 3)] # [doc = "Receives a response from the dst_chain for a message in Outbox."] relay_message_response { msg : runtime_types :: sp_messenger :: messages :: CrossDomainMessage < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: H256 > , } , # [codec (index = 4)] # [doc = "A call to update consensus chain allow list."] update_consensus_chain_allowlist { update : runtime_types :: pallet_messenger :: ChainAllowlistUpdate , } , # [codec (index = 5)] # [doc = "A call to initiate chain allowlist update on domains"] initiate_domain_update_chain_allowlist { domain_id : runtime_types :: sp_domains :: DomainId , update : runtime_types :: pallet_messenger :: ChainAllowlistUpdate , } , # [codec (index = 6)] # [doc = "An inherent call to update allowlist for domain."] update_domain_allowlist { updates : runtime_types :: sp_domains :: DomainAllowlistUpdates , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "`pallet-messenger` errors"] pub enum Error { # [codec (index = 0)] # [doc = "Emits when the chain is neither consensus not chain."] InvalidChain , # [codec (index = 1)] # [doc = "Emits when there is no channel for a given Channel ID."] MissingChannel , # [codec (index = 2)] # [doc = "Emits when the said channel is not in an open state."] InvalidChannelState , # [codec (index = 3)] # [doc = "Emits when there are no open channels for a chain"] NoOpenChannel , # [codec (index = 4)] # [doc = "Emits when there are not message handler with given endpoint ID."] NoMessageHandler , # [codec (index = 5)] # [doc = "Emits when the outbox is full for a channel."] OutboxFull , # [codec (index = 6)] # [doc = "Emits when the message payload is invalid."] InvalidMessagePayload , # [codec (index = 7)] # [doc = "Emits when the message destination is not valid."] InvalidMessageDestination , # [codec (index = 8)] # [doc = "Emits when the message verification failed."] MessageVerification (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 9)] # [doc = "Emits when there is no message available for the given nonce."] MissingMessage , # [codec (index = 10)] # [doc = "Emits when there is mismatch between the message's weight tag and the message's"] # [doc = "actual processing path"] WeightTagNotMatch , # [codec (index = 11)] # [doc = "Emits when the there is balance overflow."] BalanceOverflow , # [codec (index = 12)] # [doc = "Emits when the there is balance underflow."] BalanceUnderflow , # [codec (index = 13)] # [doc = "Invalid allowed chain."] InvalidAllowedChain , # [codec (index = 14)] # [doc = "Operation not allowed."] OperationNotAllowed , # [codec (index = 15)] # [doc = "Account is not a Domain owner."] NotDomainOwner , # [codec (index = 16)] # [doc = "Chain not allowed to open channel"] ChainNotAllowed , # [codec (index = 17)] # [doc = "Not enough balance to do the operation"] InsufficientBalance , # [codec (index = 18)] # [doc = "Failed to hold balance"] BalanceHold , # [codec (index = 19)] # [doc = "Not a channel owner"] ChannelOwner , # [codec (index = 20)] # [doc = "Failed to unlock the balance"] BalanceUnlock , # [codec (index = 21)] # [doc = "Invalid channel reserve fee"] InvalidChannelReserveFee , # [codec (index = 22)] # [doc = "Invalid max outgoing messages"] InvalidMaxOutgoingMessages , # [codec (index = 23)] # [doc = "Message count overflow"] MessageCountOverflow , # [codec (index = 24)] # [doc = "Message count underflow"] MessageCountUnderflow , # [codec (index = 25)] # [doc = "Failed to note transfer in"] FailedToNoteTransferIn , # [codec (index = 26)] # [doc = "Failed to note transfer out"] FailedToNoteTransferOut , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "`pallet-messenger` events"] pub enum Event { # [codec (index = 0)] # [doc = "Emits when a channel between two chains is initiated."] ChannelInitiated { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , } , # [codec (index = 1)] # [doc = "Emits when a channel between two chains is closed."] ChannelClosed { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , } , # [codec (index = 2)] # [doc = "Emits when a channel between two chain is open."] ChannelOpen { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , } , # [codec (index = 3)] # [doc = "Emits when a new message is added to the outbox."] OutboxMessage { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , nonce : runtime_types :: primitive_types :: U256 , } , # [codec (index = 4)] # [doc = "Emits when a message response is available for Outbox message."] OutboxMessageResponse { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , nonce : runtime_types :: primitive_types :: U256 , } , # [codec (index = 5)] # [doc = "Emits outbox message result."] OutboxMessageResult { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , nonce : runtime_types :: primitive_types :: U256 , result : runtime_types :: pallet_messenger :: OutboxMessageResult , } , # [codec (index = 6)] # [doc = "Emits when a new inbox message is validated and added to Inbox."] InboxMessage { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , nonce : runtime_types :: primitive_types :: U256 , } , # [codec (index = 7)] # [doc = "Emits when a message response is available for Inbox message."] InboxMessageResponse { chain_id : runtime_types :: sp_domains :: ChainId , channel_id : runtime_types :: primitive_types :: U256 , nonce : runtime_types :: primitive_types :: U256 , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ChainAllowlistUpdate { # [codec (index = 0)] Add (runtime_types :: sp_domains :: ChainId ,) , # [codec (index = 1)] Remove (runtime_types :: sp_domains :: ChainId ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum OutboxMessageResult { # [codec (index = 0)] Ok , # [codec (index = 1)] Err (runtime_types :: sp_runtime :: DispatchError ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RawOrigin { # [codec (index = 0)] ValidatedUnsigned , } } pub mod pallet_multisig { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] as_multi_threshold_1 { other_signatories : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 2)] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] approve_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call_hash : [:: core :: primitive :: u8 ; 32usize] , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 3)] # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] cancel_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Threshold must be 2 or greater."] MinimumThreshold , # [codec (index = 1)] # [doc = "Call is already approved by this signatory."] AlreadyApproved , # [codec (index = 2)] # [doc = "Call doesn't need any (more) approvals."] NoApprovalsNeeded , # [codec (index = 3)] # [doc = "There are too few signatories in the list."] TooFewSignatories , # [codec (index = 4)] # [doc = "There are too many signatories in the list."] TooManySignatories , # [codec (index = 5)] # [doc = "The signatories were provided out of order; they should be ordered."] SignatoriesOutOfOrder , # [codec (index = 6)] # [doc = "The sender was contained in the other signatories; it shouldn't be."] SenderInSignatories , # [codec (index = 7)] # [doc = "Multisig operation not found when attempting to cancel."] NotFound , # [codec (index = 8)] # [doc = "Only the account that originally created the multisig is able to cancel it."] NotOwner , # [codec (index = 9)] # [doc = "No timepoint was given, yet the multisig operation is already underway."] NoTimepoint , # [codec (index = 10)] # [doc = "A different timepoint was given to the multisig operation that is underway."] WrongTimepoint , # [codec (index = 11)] # [doc = "A timepoint was given, yet no multisig operation is underway."] UnexpectedTimepoint , # [codec (index = 12)] # [doc = "The maximum weight information provided was too low."] MaxWeightTooLow , # [codec (index = 13)] # [doc = "The data to be stored is already stored."] AlreadyStored , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A new multisig operation has begun."] NewMultisig { approving : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , multisig : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 1)] # [doc = "A multisig operation has been approved by someone."] MultisigApproval { approving : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 2)] # [doc = "A multisig operation has been executed."] MultisigExecuted { approving : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 3)] # [doc = "A multisig operation has been cancelled."] MultisigCancelled { cancelling : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Multisig < _0 , _1 , _2 > { pub when : runtime_types :: pallet_multisig :: Timepoint < _0 > , pub deposit : _1 , pub depositor : _2 , pub approvals : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < _2 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Timepoint < _0 > { pub height : _0 , pub index : :: core :: primitive :: u32 , } } pub mod pallet_preimage { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] note_preimage { bytes : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Clear an unrequested preimage from the runtime storage."] # [doc = ""] # [doc = "If `len` is provided, then it will be a much cheaper operation."] # [doc = ""] # [doc = "- `hash`: The hash of the preimage to be removed from the store."] # [doc = "- `len`: The length of the preimage of `hash`."] unnote_preimage { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 2)] # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] request_preimage { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 3)] # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] unrequest_preimage { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 4)] # [doc = "Ensure that the a bulk of pre-images is upgraded."] # [doc = ""] # [doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."] ensure_updated { hashes : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: utils :: H256 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Preimage is too large to store on-chain."] TooBig , # [codec (index = 1)] # [doc = "Preimage has already been noted on-chain."] AlreadyNoted , # [codec (index = 2)] # [doc = "The user is not authorized to perform this action."] NotAuthorized , # [codec (index = 3)] # [doc = "The preimage cannot be removed since it has not yet been noted."] NotNoted , # [codec (index = 4)] # [doc = "A preimage may not be removed when there are outstanding requests."] Requested , # [codec (index = 5)] # [doc = "The preimage request cannot be removed since no outstanding requests exist."] NotRequested , # [codec (index = 6)] # [doc = "More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once."] TooMany , # [codec (index = 7)] # [doc = "Too few hashes were requested to be upgraded (i.e. zero)."] TooFew , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A preimage has been noted."] Noted { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 1)] # [doc = "A preimage has been requested."] Requested { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , # [codec (index = 2)] # [doc = "A preimage has ben cleared."] Cleared { hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum OldRequestStatus < _0 , _1 > { # [codec (index = 0)] Unrequested { deposit : (_0 , _1 ,) , len : :: core :: primitive :: u32 , } , # [codec (index = 1)] Requested { deposit : :: core :: option :: Option < (_0 , _1 ,) > , count : :: core :: primitive :: u32 , len : :: core :: option :: Option < :: core :: primitive :: u32 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RequestStatus < _0 , _1 > { # [codec (index = 0)] Unrequested { ticket : (_0 , _1 ,) , len : :: core :: primitive :: u32 , } , # [codec (index = 1)] Requested { maybe_ticket : :: core :: option :: Option < (_0 , _1 ,) > , count : :: core :: primitive :: u32 , maybe_len : :: core :: option :: Option < :: core :: primitive :: u32 > , } , } } pub mod pallet_rewards { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Update dynamic issuance parameters"] update_issuance_params { proposer_subsidy_points : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_rewards :: RewardPoint < :: core :: primitive :: u32 , :: core :: primitive :: u128 > > , voter_subsidy_points : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_rewards :: RewardPoint < :: core :: primitive :: u32 , :: core :: primitive :: u128 > > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "`pallet-rewards` events"] pub enum Event { # [codec (index = 0)] # [doc = "Issued reward for the block author"] BlockReward { block_author : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , reward : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Issued reward for the voter"] VoteReward { voter : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , reward : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RewardPoint < _0 , _1 > { pub block : _0 , pub subsidy : _1 , } } pub mod pallet_runtime_configs { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Change enable domains state."] set_enable_domains { enable_domains : :: core :: primitive :: bool , } , # [codec (index = 1)] # [doc = "Enable or disable dynamic cost of storage."] set_enable_dynamic_cost_of_storage { enable_dynamic_cost_of_storage : :: core :: primitive :: bool , } , # [codec (index = 2)] # [doc = "Enable or disable balance transfers for all users."] set_enable_balance_transfers { enable_balance_transfers : :: core :: primitive :: bool , } , } } } pub mod pallet_scheduler { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Anonymously schedule a task."] schedule { when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Cancel an anonymously scheduled task."] cancel { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Schedule a named task."] schedule_named { id : [:: core :: primitive :: u8 ; 32usize] , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 3)] # [doc = "Cancel a named scheduled task."] cancel_named { id : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 4)] # [doc = "Anonymously schedule a task after a delay."] schedule_after { after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 5)] # [doc = "Schedule a named task after a delay."] schedule_named_after { id : [:: core :: primitive :: u8 ; 32usize] , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 6)] # [doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"] # [doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"] # [doc = "succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] set_retry { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , retries : :: core :: primitive :: u8 , period : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"] # [doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"] # [doc = "it succeeds."] # [doc = ""] # [doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"] # [doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"] # [doc = "normally while the task is retrying."] # [doc = ""] # [doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"] # [doc = "clones of the original task. Their retry configuration will be derived from the"] # [doc = "original task's configuration, but will have a lower value for `remaining` than the"] # [doc = "original `total_retries`."] set_retry_named { id : [:: core :: primitive :: u8 ; 32usize] , retries : :: core :: primitive :: u8 , period : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Removes the retry configuration of a task."] cancel_retry { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , } , # [codec (index = 9)] # [doc = "Cancel the retry configuration of a named task."] cancel_retry_named { id : [:: core :: primitive :: u8 ; 32usize] , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Failed to schedule a call"] FailedToSchedule , # [codec (index = 1)] # [doc = "Cannot find the scheduled call."] NotFound , # [codec (index = 2)] # [doc = "Given target block number is in the past."] TargetBlockNumberInPast , # [codec (index = 3)] # [doc = "Reschedule failed because it does not change scheduled time."] RescheduleNoChange , # [codec (index = 4)] # [doc = "Attempt to use a non-named function on a named task."] Named , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Events type."] pub enum Event { # [codec (index = 0)] # [doc = "Scheduled some task."] Scheduled { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Canceled some task."] Canceled { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Dispatched some task."] Dispatched { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 3)] # [doc = "Set a retry configuration for some task."] RetrySet { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , period : :: core :: primitive :: u32 , retries : :: core :: primitive :: u8 , } , # [codec (index = 4)] # [doc = "Cancel a retry configuration for some task."] RetryCancelled { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , # [codec (index = 5)] # [doc = "The call for the provided hash was not found so the task has been aborted."] CallUnavailable { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , # [codec (index = 6)] # [doc = "The given task was unable to be renewed since the agenda is full at that block."] PeriodicFailed { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , # [codec (index = 7)] # [doc = "The given task was unable to be retried since the agenda is full at that block or there"] # [doc = "was not enough weight to reschedule it."] RetryFailed { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , # [codec (index = 8)] # [doc = "The given task can never be executed since it is overweight."] PermanentlyOverweight { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RetryConfig < _0 > { pub total_retries : :: core :: primitive :: u8 , pub remaining : :: core :: primitive :: u8 , pub period : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Scheduled < _0 , _1 , _2 , _3 , _4 > { pub maybe_id : :: core :: option :: Option < _0 > , pub priority : :: core :: primitive :: u8 , pub call : _1 , pub maybe_periodic : :: core :: option :: Option < (_2 , _2 ,) > , pub origin : _3 , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _4 > } } pub mod pallet_subspace { use super :: runtime_types ; pub mod extensions { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SubspaceExtension < _0 > (pub :: core :: marker :: PhantomData < _0 >) ; } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Submit new segment header to the blockchain. This is an inherent extrinsic and part of"] # [doc = "the Subspace consensus logic."] store_segment_headers { segment_headers : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_core_primitives :: segments :: SegmentHeader > , } , # [codec (index = 1)] # [doc = "Enable solution range adjustment after every era."] # [doc = "Note: No effect on the solution range for the current era"] enable_solution_range_adjustment { solution_range_override : :: core :: option :: Option < :: core :: primitive :: u64 > , voting_solution_range_override : :: core :: option :: Option < :: core :: primitive :: u64 > , } , # [codec (index = 2)] # [doc = "Farmer vote, currently only used for extra rewards to farmers."] vote { signed_vote : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: sp_consensus_subspace :: SignedVote < :: core :: primitive :: u32 , :: subxt :: ext :: subxt_core :: utils :: H256 , :: subxt :: ext :: subxt_core :: utils :: AccountId32 > > , } , # [codec (index = 3)] # [doc = "Enable rewards for blocks and votes at specified block height."] enable_rewards_at { enable_rewards_at : runtime_types :: pallet_subspace :: pallet :: EnableRewardsAt < :: core :: primitive :: u32 > , } , # [codec (index = 4)] # [doc = "Enable storage access for all users."] enable_authoring_by_anyone , # [codec (index = 5)] # [doc = "Update proof of time slot iterations"] set_pot_slot_iterations { slot_iterations : :: core :: num :: NonZeroU32 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum EnableRewardsAt < _0 > { # [codec (index = 0)] Height (_0 ,) , # [codec (index = 1)] SolutionRange (:: core :: primitive :: u64 ,) , # [codec (index = 2)] Manually , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Solution range adjustment already enabled."] SolutionRangeAdjustmentAlreadyEnabled , # [codec (index = 1)] # [doc = "Iterations are not multiple of number of checkpoints times two"] NotMultipleOfCheckpoints , # [codec (index = 2)] # [doc = "Proof of time slot iterations must increase as hardware improves"] PotSlotIterationsMustIncrease , # [codec (index = 3)] # [doc = "Proof of time slot iterations update already scheduled"] PotSlotIterationsUpdateAlreadyScheduled , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Events type."] pub enum Event { # [codec (index = 0)] # [doc = "Segment header was stored in blockchain history."] SegmentHeaderStored { segment_header : runtime_types :: subspace_core_primitives :: segments :: SegmentHeader , } , # [codec (index = 1)] # [doc = "Farmer vote."] FarmerVote { public_key : runtime_types :: subspace_core_primitives :: PublicKey , reward_address : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , height : :: core :: primitive :: u32 , parent_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PotEntropyValue { pub target_slot : :: core :: option :: Option < runtime_types :: sp_consensus_slots :: Slot > , pub entropy : runtime_types :: subspace_core_primitives :: hashes :: Blake3Hash , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PotSlotIterationsUpdate { pub target_slot : :: core :: option :: Option < runtime_types :: sp_consensus_slots :: Slot > , pub slot_iterations : :: core :: num :: NonZeroU32 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PotSlotIterationsValue { pub slot_iterations : :: core :: num :: NonZeroU32 , pub update : :: core :: option :: Option < runtime_types :: pallet_subspace :: pallet :: PotSlotIterationsUpdate > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SolutionRangeOverride { pub solution_range : :: core :: primitive :: u64 , pub voting_solution_range : :: core :: primitive :: u64 , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RawOrigin { # [codec (index = 0)] ValidatedUnsigned , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct VoteVerificationData { pub solution_range : :: core :: primitive :: u64 , pub vote_solution_range : :: core :: primitive :: u64 , pub current_slot : runtime_types :: sp_consensus_slots :: Slot , pub parent_slot : runtime_types :: sp_consensus_slots :: Slot , } } pub mod pallet_sudo { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] sudo { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] sudo_unchecked_weight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 2)] # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] set_key { new : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , } , # [codec (index = 3)] # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] sudo_as { who : :: subxt :: ext :: subxt_core :: utils :: MultiAddress < :: subxt :: ext :: subxt_core :: utils :: AccountId32 , () > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 4)] # [doc = "Permanently removes the sudo key."] # [doc = ""] # [doc = "**This cannot be un-done.**"] remove_key , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Error for the Sudo pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Sender must be the Sudo account."] RequireSudo , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A sudo call just took place."] Sudid { sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 1)] # [doc = "The sudo key has been updated."] KeyChanged { old : :: core :: option :: Option < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > , new : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , } , # [codec (index = 2)] # [doc = "The key was permanently removed."] KeyRemoved , # [codec (index = 3)] # [doc = "A [sudo_as](Pallet::sudo_as) call just took place."] SudoAsDone { sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , } } } pub mod pallet_timestamp { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "[`Config::MinimumPeriod`]."] # [doc = ""] # [doc = "The dispatch origin for this call must be _None_."] # [doc = ""] # [doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"] # [doc = "that changing the complexity of this call could result exhausting the resources in a"] # [doc = "block to execute any other calls."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] set { # [codec (compact)] now : :: core :: primitive :: u64 , } , } } } pub mod pallet_transaction_fees { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "`pallet-transaction-fees` events"] pub enum Event { # [codec (index = 0)] # [doc = "Storage fees."] BlockFees { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , storage : :: core :: primitive :: u128 , compute : :: core :: primitive :: u128 , tips : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Fees burned due to equivocated block author or rewards not enabled."] BurnedBlockFees { storage : :: core :: primitive :: u128 , compute : :: core :: primitive :: u128 , tips : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CollectedFees < _0 > { pub storage : _0 , pub compute : _0 , pub tips : _0 , } } pub mod pallet_transaction_payment { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] TransactionFeePaid { who : :: subxt :: ext :: subxt_core :: utils :: AccountId32 , actual_fee : :: core :: primitive :: u128 , tip : :: core :: primitive :: u128 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FeeDetails < _0 > { pub inclusion_fee : :: core :: option :: Option < runtime_types :: pallet_transaction_payment :: types :: InclusionFee < _0 > > , pub tip : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InclusionFee < _0 > { pub base_fee : _0 , pub len_fee : _0 , pub adjusted_weight_fee : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeDispatchInfo < _0 , _1 > { pub weight : _1 , pub class : runtime_types :: frame_support :: dispatch :: DispatchClass , pub partial_fee : _0 , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChargeTransactionPayment (# [codec (compact)] pub :: core :: primitive :: u128 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Releases { # [codec (index = 0)] V1Ancient , # [codec (index = 1)] V2 , } } pub mod pallet_transporter { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Initiates transfer of funds from account on src_chain to account on dst_chain."] # [doc = "Funds are burned on src_chain first and are minted on dst_chain using Messenger."] transfer { dst_location : runtime_types :: pallet_transporter :: Location , amount : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Errors emitted by pallet-transporter."] pub enum Error { # [codec (index = 0)] # [doc = "Emits when the account has low balance to make a transfer."] LowBalance , # [codec (index = 1)] # [doc = "Failed to decode transfer payload."] InvalidPayload , # [codec (index = 2)] # [doc = "Emits when the request for a response received is missing."] MissingTransferRequest , # [codec (index = 3)] # [doc = "Emits when the request doesn't match the expected one.."] InvalidTransferRequest , # [codec (index = 4)] # [doc = "Emits when the incoming message is not bound to this chain."] UnexpectedMessage , # [codec (index = 5)] # [doc = "Emits when the account id type is invalid."] InvalidAccountId , # [codec (index = 6)] # [doc = "Emits when from_chain do not have enough funds to finalize the transfer."] LowBalanceOnDomain , # [codec (index = 7)] # [doc = "Emits when the transfer tracking was called from non-consensus chain"] NonConsensusChain , # [codec (index = 8)] # [doc = "Emits when balance overflow"] BalanceOverflow , # [codec (index = 9)] # [doc = "Emits when balance underflow"] BalanceUnderflow , # [codec (index = 10)] # [doc = "Emits when domain balance is already initialized"] DomainBalanceAlreadyInitialized , # [codec (index = 11)] # [doc = "Emits when the requested transfer amount is less than Minimum transfer amount."] MinimumTransferAmount , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Events emitted by pallet-transporter."] pub enum Event { # [codec (index = 0)] # [doc = "Emits when there is a new outgoing transfer."] OutgoingTransferInitiated { chain_id : runtime_types :: sp_domains :: ChainId , message_id : (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) , amount : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Emits when a given outgoing transfer was failed on dst_chain."] OutgoingTransferFailed { chain_id : runtime_types :: sp_domains :: ChainId , message_id : (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) , err : runtime_types :: sp_runtime :: DispatchError , } , # [codec (index = 2)] # [doc = "Emits when a given outgoing transfer was successful."] OutgoingTransferSuccessful { chain_id : runtime_types :: sp_domains :: ChainId , message_id : (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) , } , # [codec (index = 3)] # [doc = "Emits when a given incoming transfer was successfully processed."] IncomingTransferSuccessful { chain_id : runtime_types :: sp_domains :: ChainId , message_id : (runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) , amount : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Location { pub chain_id : runtime_types :: sp_domains :: ChainId , pub account_id : runtime_types :: domain_runtime_primitives :: MultiAccountId , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Transfer < _0 > { pub amount : _0 , pub sender : runtime_types :: pallet_transporter :: Location , pub receiver : runtime_types :: pallet_transporter :: Location , } } pub mod pallet_utility { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "Contains a variant per dispatchable extrinsic that this pallet has."] pub enum Call { # [codec (index = 0)] # [doc = "Send a batch of dispatch calls."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] # [doc = ""] # [doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"] # [doc = "event is deposited. If a call failed and the batch was interrupted, then the"] # [doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"] # [doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"] # [doc = "event is deposited."] batch { calls : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Send a call through an indexed pseudonym of the sender."] # [doc = ""] # [doc = "Filter from origin are passed along. The call will be dispatched with an origin which"] # [doc = "use the same filter as the origin of this call."] # [doc = ""] # [doc = "NOTE: If you need to ensure that any account-based filtering is not honored (i.e."] # [doc = "because you expect `proxy` to have been used prior in the call stack and you do not want"] # [doc = "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`"] # [doc = "in the Multisig pallet instead."] # [doc = ""] # [doc = "NOTE: Prior to version *12, this was called `as_limited_sub`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] as_derivative { index : :: core :: primitive :: u16 , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 2)] # [doc = "Send a batch of dispatch calls and atomically execute them."] # [doc = "The whole transaction will rollback and fail if any of the calls failed."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatched without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] batch_all { calls : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 3)] # [doc = "Dispatches a function call with a provided origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] dispatch_as { as_origin : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: OriginCaller > , call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 4)] # [doc = "Send a batch of dispatch calls."] # [doc = "Unlike `batch`, it allows errors and won't interrupt."] # [doc = ""] # [doc = "May be called from any origin except `None`."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then the calls are dispatch without checking origin filter. (This"] # [doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(C) where C is the number of calls to be batched."] force_batch { calls : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_runtime :: RuntimeCall > , } , # [codec (index = 5)] # [doc = "Dispatch a function call with a specified weight."] # [doc = ""] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Root origin to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] with_weight { call : :: subxt :: ext :: subxt_core :: alloc :: boxed :: Box < runtime_types :: subspace_runtime :: RuntimeCall > , weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Error` enum of this pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Too many calls batched."] TooManyCalls , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] # [doc = "The `Event` enum of this pallet"] pub enum Event { # [codec (index = 0)] # [doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"] # [doc = "well as the error."] BatchInterrupted { index : :: core :: primitive :: u32 , error : runtime_types :: sp_runtime :: DispatchError , } , # [codec (index = 1)] # [doc = "Batch of dispatches completed fully with no error."] BatchCompleted , # [codec (index = 2)] # [doc = "Batch of dispatches completed but has errors."] BatchCompletedWithErrors , # [codec (index = 3)] # [doc = "A single item within a Batch of dispatches has completed with no error."] ItemCompleted , # [codec (index = 4)] # [doc = "A single item within a Batch of dispatches has completed with error."] ItemFailed { error : runtime_types :: sp_runtime :: DispatchError , } , # [codec (index = 5)] # [doc = "A call was dispatched."] DispatchedAs { result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , } } } pub mod primitive_types { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct U256 (pub [:: core :: primitive :: u64 ; 4usize] ,) ; } pub mod sp_arithmetic { use super :: runtime_types ; pub mod fixed_point { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FixedU128 (pub :: core :: primitive :: u128 ,) ; } pub mod per_things { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Perbill (pub :: core :: primitive :: u32 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Percent (pub :: core :: primitive :: u8 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Perquintill (pub :: core :: primitive :: u64 ,) ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ArithmeticError { # [codec (index = 0)] Underflow , # [codec (index = 1)] Overflow , # [codec (index = 2)] DivisionByZero , } } pub mod sp_consensus_slots { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Slot (pub :: core :: primitive :: u64 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SlotDuration (pub :: core :: primitive :: u64 ,) ; } pub mod sp_consensus_subspace { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ChainConstants { # [codec (index = 0)] V0 { confirmation_depth_k : :: core :: primitive :: u32 , block_authoring_delay : runtime_types :: sp_consensus_slots :: Slot , era_duration : :: core :: primitive :: u32 , slot_probability : (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) , slot_duration : runtime_types :: sp_consensus_slots :: SlotDuration , recent_segments : runtime_types :: subspace_core_primitives :: segments :: HistorySize , recent_history_fraction : (runtime_types :: subspace_core_primitives :: segments :: HistorySize , runtime_types :: subspace_core_primitives :: segments :: HistorySize ,) , min_sector_lifetime : runtime_types :: subspace_core_primitives :: segments :: HistorySize , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum PotParameters { # [codec (index = 0)] V0 { slot_iterations : :: core :: num :: NonZeroU32 , next_change : :: core :: option :: Option < runtime_types :: sp_consensus_subspace :: PotParametersChange > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PotParametersChange { pub slot : runtime_types :: sp_consensus_slots :: Slot , pub slot_iterations : :: core :: num :: NonZeroU32 , pub entropy : runtime_types :: subspace_core_primitives :: hashes :: Blake3Hash , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SignedVote < _0 , _1 , _2 > { pub vote : runtime_types :: sp_consensus_subspace :: Vote < _0 , _1 , _2 > , pub signature : runtime_types :: subspace_core_primitives :: solutions :: RewardSignature , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SolutionRanges { pub current : :: core :: primitive :: u64 , pub next : :: core :: option :: Option < :: core :: primitive :: u64 > , pub voting_current : :: core :: primitive :: u64 , pub voting_next : :: core :: option :: Option < :: core :: primitive :: u64 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Vote < _0 , _1 , _2 > { # [codec (index = 0)] V0 { height : _0 , parent_hash : _1 , slot : runtime_types :: sp_consensus_slots :: Slot , solution : runtime_types :: subspace_core_primitives :: solutions :: Solution < _2 > , proof_of_time : runtime_types :: subspace_core_primitives :: pot :: PotOutput , future_proof_of_time : runtime_types :: subspace_core_primitives :: pot :: PotOutput , } , } } pub mod sp_core { use super :: runtime_types ; pub mod crypto { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct KeyTypeId (pub [:: core :: primitive :: u8 ; 4usize] ,) ; } pub mod sr25519 { use super :: runtime_types ; pub mod vrf { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct VrfSignature { pub pre_output : [:: core :: primitive :: u8 ; 32usize] , pub proof : [:: core :: primitive :: u8 ; 64usize] , } } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OpaqueMetadata (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) ; } pub mod sp_domains { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } pub mod bundle_producer_election { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BundleProducerElectionParams < _0 > { pub total_domain_stake : _0 , pub bundle_slot_probability : (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) , } } pub mod proof_provider_and_verifier { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum VerificationError { # [codec (index = 0)] InvalidProof , # [codec (index = 1)] MissingValue , # [codec (index = 2)] FailedToDecode , # [codec (index = 3)] UnusedNodesInTheProof , } } pub mod storage { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RawGenesis { pub top : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < runtime_types :: sp_domains :: storage :: StorageKey , runtime_types :: sp_domains :: storage :: StorageData > , pub children_default : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < runtime_types :: sp_domains :: storage :: StorageKey , :: subxt :: ext :: subxt_core :: utils :: KeyedVec < runtime_types :: sp_domains :: storage :: StorageKey , runtime_types :: sp_domains :: storage :: StorageData > > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StorageData (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StorageKey (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct AutoIdDomainRuntimeConfig ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockFees < _0 > { pub consensus_storage_fee : _0 , pub domain_execution_fee : _0 , pub burned_balance : _0 , pub chain_rewards : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < runtime_types :: sp_domains :: ChainId , _0 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Bundle < _0 , _1 , _2 , _3 , _4 > { pub sealed_header : runtime_types :: sp_domains :: SealedBundleHeader < _1 , _2 , _3 , _4 > , pub extrinsics : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BundleDigest < _0 > { pub header_hash : _0 , pub extrinsics_root : _0 , pub size : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BundleHeader < _0 , _1 , _2 , _3 > { pub proof_of_election : runtime_types :: sp_domains :: ProofOfElection , pub receipt : runtime_types :: sp_domains :: ExecutionReceipt < _0 , _1 , _0 , _1 , _3 > , pub estimated_bundle_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , pub bundle_extrinsics_root : :: subxt :: ext :: subxt_core :: utils :: H256 , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _2 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum BundleValidity < _0 > { # [codec (index = 0)] Invalid (runtime_types :: sp_domains :: InvalidBundleType ,) , # [codec (index = 1)] Valid (_0 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ChainId { # [codec (index = 0)] Consensus , # [codec (index = 1)] Domain (runtime_types :: sp_domains :: DomainId ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainAllowlistUpdates { pub allow_chains : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: ChainId > , pub remove_chains : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: ChainId > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainBundleLimit { pub max_bundle_size : :: core :: primitive :: u32 , pub max_bundle_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainId (pub :: core :: primitive :: u32 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainInstanceData { pub runtime_type : runtime_types :: sp_domains :: RuntimeType , pub raw_genesis : runtime_types :: sp_domains :: storage :: RawGenesis , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum DomainRuntimeConfig { # [codec (index = 0)] Evm (runtime_types :: sp_domains :: EvmDomainRuntimeConfig ,) , # [codec (index = 1)] AutoId (runtime_types :: sp_domains :: AutoIdDomainRuntimeConfig ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainSudoCall { pub maybe_call : :: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EvmDomainContractCreationAllowedByCall { pub maybe_call : :: core :: option :: Option < runtime_types :: sp_domains :: PermissionedActionAllowedBy < :: subxt :: ext :: subxt_core :: utils :: AccountId20 > > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EvmDomainRuntimeConfig { pub evm_type : runtime_types :: sp_domains :: EvmType , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum EvmType { # [codec (index = 0)] Public , # [codec (index = 1)] Private { initial_contract_creation_allow_list : runtime_types :: sp_domains :: PermissionedActionAllowedBy < :: subxt :: ext :: subxt_core :: utils :: AccountId20 > , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ExecutionReceipt < _0 , _1 , _2 , _3 , _4 > { pub domain_block_number : _2 , pub domain_block_hash : _3 , pub domain_block_extrinsic_root : _3 , pub parent_domain_block_receipt_hash : _3 , pub consensus_block_number : _0 , pub consensus_block_hash : _1 , pub inboxed_bundles : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: InboxedBundle < _1 > > , pub final_state_root : _3 , pub execution_trace : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _1 > , pub execution_trace_root : :: subxt :: ext :: subxt_core :: utils :: H256 , pub block_fees : runtime_types :: sp_domains :: BlockFees < _4 > , pub transfers : runtime_types :: sp_domains :: Transfers < _4 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ExtrinsicDigest { # [codec (index = 0)] Data (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 1)] Hash (:: subxt :: ext :: subxt_core :: utils :: H256 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InboxedBundle < _0 > { pub bundle : runtime_types :: sp_domains :: BundleValidity < _0 > , pub extrinsics_root : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum InvalidBundleType { # [codec (index = 0)] UndecodableTx (:: core :: primitive :: u32 ,) , # [codec (index = 1)] OutOfRangeTx (:: core :: primitive :: u32 ,) , # [codec (index = 2)] IllegalTx (:: core :: primitive :: u32 ,) , # [codec (index = 3)] InvalidXDM (:: core :: primitive :: u32 ,) , # [codec (index = 4)] InherentExtrinsic (:: core :: primitive :: u32 ,) , # [codec (index = 5)] InvalidBundleWeight , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct NominatorPosition < _0 , _1 , _2 > { pub current_staked_value : _0 , pub total_shares : _2 , pub storage_fee_deposit : runtime_types :: sp_domains :: StorageFeeDeposit < _0 > , pub pending_deposit : :: core :: option :: Option < runtime_types :: sp_domains :: PendingDeposit < _0 > > , pub pending_withdrawals : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains :: PendingWithdrawal < _0 , _1 > > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum OperatorAllowList < _0 > { # [codec (index = 0)] Anyone , # [codec (index = 1)] Operators (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum OperatorRewardSource < _0 > { # [codec (index = 0)] Bundle { at_block_number : _0 , } , # [codec (index = 1)] XDMProtocolFees , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PendingDeposit < _0 > { pub amount : _0 , pub effective_epoch : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PendingWithdrawal < _0 , _1 > { pub stake_withdrawal_amount : _0 , pub storage_fee_refund : _0 , pub unlock_at_block : _1 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum PermissionedActionAllowedBy < _0 > { # [codec (index = 0)] Accounts (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > ,) , # [codec (index = 1)] Anyone , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ProofOfElection { pub domain_id : runtime_types :: sp_domains :: DomainId , pub slot_number : :: core :: primitive :: u64 , pub proof_of_time : runtime_types :: subspace_core_primitives :: pot :: PotOutput , pub vrf_signature : runtime_types :: sp_core :: sr25519 :: vrf :: VrfSignature , pub operator_id : :: core :: primitive :: u64 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeObject < _0 , _1 > { pub runtime_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , pub runtime_type : runtime_types :: sp_domains :: RuntimeType , pub runtime_upgrades : :: core :: primitive :: u32 , pub instance_count : :: core :: primitive :: u32 , pub hash : _1 , pub raw_genesis : runtime_types :: sp_domains :: storage :: RawGenesis , pub version : runtime_types :: sp_version :: RuntimeVersion , pub created_at : _0 , pub updated_at : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeType { # [codec (index = 0)] Evm , # [codec (index = 1)] AutoId , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SealedBundleHeader < _0 , _1 , _2 , _3 > { pub header : runtime_types :: sp_domains :: BundleHeader < _0 , _1 , _2 , _3 > , pub signature : runtime_types :: sp_domains :: app :: Signature , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SealedSingletonReceipt < _0 , _1 , _2 , _3 > { pub singleton_receipt : runtime_types :: sp_domains :: SingletonReceipt < _0 , _1 , _2 , _3 > , pub signature : runtime_types :: sp_domains :: app :: Signature , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SingletonReceipt < _0 , _1 , _2 , _3 > { pub proof_of_election : runtime_types :: sp_domains :: ProofOfElection , pub receipt : runtime_types :: sp_domains :: ExecutionReceipt < _0 , _1 , _0 , _1 , _3 > , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _2 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StorageFeeDeposit < _0 > { pub total_deposited : _0 , pub current_value : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Transfers < _0 > { pub transfers_in : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < runtime_types :: sp_domains :: ChainId , _0 > , pub transfers_out : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < runtime_types :: sp_domains :: ChainId , _0 > , pub rejected_transfers_claimed : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < runtime_types :: sp_domains :: ChainId , _0 > , pub transfers_rejected : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < runtime_types :: sp_domains :: ChainId , _0 > , } } pub mod sp_domains_fraud_proof { use super :: runtime_types ; pub mod fraud_proof { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ApplyExtrinsicMismatch { # [codec (index = 0)] StateRoot (:: core :: primitive :: u32 ,) , # [codec (index = 1)] Shorter , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainRuntimeCodeAt < _0 , _1 , _2 > { pub mmr_proof : runtime_types :: sp_subspace_mmr :: ConsensusChainMmrLeafProof < _0 , _1 , _1 > , pub domain_runtime_code_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: DomainRuntimeCodeProof , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _2 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ExecutionPhase { # [codec (index = 0)] InitializeBlock , # [codec (index = 1)] ApplyExtrinsic { extrinsic_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , mismatch : runtime_types :: sp_domains_fraud_proof :: fraud_proof :: ApplyExtrinsicMismatch , } , # [codec (index = 2)] FinalizeBlock { mismatch : runtime_types :: sp_domains_fraud_proof :: fraud_proof :: FinalizeBlockMismatch , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum FinalizeBlockMismatch { # [codec (index = 0)] StateRoot , # [codec (index = 1)] Longer (:: core :: primitive :: u32 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct FraudProof < _0 , _1 , _2 , _3 > { pub domain_id : runtime_types :: sp_domains :: DomainId , pub bad_receipt_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , pub maybe_mmr_proof : :: core :: option :: Option < runtime_types :: sp_subspace_mmr :: ConsensusChainMmrLeafProof < _0 , _1 , _1 > > , pub maybe_domain_runtime_code_proof : :: core :: option :: Option < runtime_types :: sp_domains_fraud_proof :: fraud_proof :: DomainRuntimeCodeAt < _0 , _1 , _1 > > , pub proof : runtime_types :: sp_domains_fraud_proof :: fraud_proof :: FraudProofVariant < _0 , _1 , _1 , _2 > , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _3 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum FraudProofVariant < _0 , _1 , _2 , _3 > { # [codec (index = 0)] InvalidStateTransition (runtime_types :: sp_domains_fraud_proof :: fraud_proof :: InvalidStateTransitionProof ,) , # [codec (index = 1)] ValidBundle (runtime_types :: sp_domains_fraud_proof :: fraud_proof :: ValidBundleProof < _0 , _1 , _3 > ,) , # [codec (index = 2)] InvalidExtrinsicsRoot (runtime_types :: sp_domains_fraud_proof :: fraud_proof :: InvalidExtrinsicsRootProof ,) , # [codec (index = 3)] InvalidBundles (runtime_types :: sp_domains_fraud_proof :: fraud_proof :: InvalidBundlesProof < _0 , _1 , _1 , _3 > ,) , # [codec (index = 4)] InvalidDomainBlockHash (runtime_types :: sp_domains_fraud_proof :: fraud_proof :: InvalidDomainBlockHashProof ,) , # [codec (index = 5)] InvalidBlockFees (runtime_types :: sp_domains_fraud_proof :: fraud_proof :: InvalidBlockFeesProof ,) , # [codec (index = 6)] InvalidTransfers (runtime_types :: sp_domains_fraud_proof :: fraud_proof :: InvalidTransfersProof ,) , __Ignore (:: core :: marker :: PhantomData < _2 >) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InvalidBlockFeesProof { pub storage_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InvalidBundlesProof < _0 , _1 , _2 , _3 > { pub bundle_index : :: core :: primitive :: u32 , pub invalid_bundle_type : runtime_types :: sp_domains :: InvalidBundleType , pub is_good_invalid_fraud_proof : :: core :: primitive :: bool , pub proof_data : runtime_types :: sp_domains_fraud_proof :: fraud_proof :: InvalidBundlesProofData < _0 , _1 , _1 , _3 > , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _2 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum InvalidBundlesProofData < _0 , _1 , _2 , _3 > { # [codec (index = 0)] Extrinsic (runtime_types :: sp_trie :: storage_proof :: StorageProof ,) , # [codec (index = 1)] Bundle (runtime_types :: sp_domains_fraud_proof :: storage_proof :: OpaqueBundleWithProof < _0 , _1 , _3 , :: core :: primitive :: u128 > ,) , # [codec (index = 2)] BundleAndExecution { bundle_with_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: OpaqueBundleWithProof < _0 , _1 , _3 , :: core :: primitive :: u128 > , execution_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , } , # [codec (index = 3)] InvalidXDMProofData { extrinsic_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , mmr_root_proof : :: core :: option :: Option < runtime_types :: sp_domains_fraud_proof :: fraud_proof :: MmrRootProof < _0 , _1 , _1 > > , } , __Ignore (:: core :: marker :: PhantomData < _2 >) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InvalidDomainBlockHashProof { pub digest_storage_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InvalidExtrinsicsRootProof { pub valid_bundle_digests : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_domains_fraud_proof :: fraud_proof :: ValidBundleDigest > , pub invalid_inherent_extrinsic_proofs : runtime_types :: sp_domains_fraud_proof :: storage_proof :: InvalidInherentExtrinsicDataProof , pub maybe_domain_runtime_upgraded_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: MaybeDomainRuntimeUpgradedProof , pub domain_chain_allowlist_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: DomainChainsAllowlistUpdateStorageProof , pub domain_sudo_call_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: DomainSudoCallStorageProof , pub evm_domain_contract_creation_allowed_by_call_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: EvmDomainContractCreationAllowedByCallStorageProof , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InvalidStateTransitionProof { pub execution_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , pub execution_phase : runtime_types :: sp_domains_fraud_proof :: fraud_proof :: ExecutionPhase , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InvalidTransfersProof { pub storage_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MmrRootProof < _0 , _1 , _2 > { pub mmr_proof : runtime_types :: sp_subspace_mmr :: ConsensusChainMmrLeafProof < _0 , _1 , _1 > , pub mmr_root_storage_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: MmrRootStorageProof < _1 > , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _2 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ValidBundleDigest { pub bundle_index : :: core :: primitive :: u32 , pub bundle_digest : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < (:: core :: option :: Option < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , runtime_types :: sp_domains :: ExtrinsicDigest ,) > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ValidBundleProof < _0 , _1 , _2 > { pub bundle_with_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: OpaqueBundleWithProof < _0 , _1 , _2 , :: core :: primitive :: u128 > , } } pub mod storage_proof { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainChainsAllowlistUpdateStorageProof (pub runtime_types :: sp_trie :: storage_proof :: StorageProof ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainRuntimeCodeProof (pub runtime_types :: sp_trie :: storage_proof :: StorageProof ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainRuntimeUpgradesProof (pub runtime_types :: sp_trie :: storage_proof :: StorageProof ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct DomainSudoCallStorageProof (pub runtime_types :: sp_trie :: storage_proof :: StorageProof ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EvmDomainContractCreationAllowedByCallStorageProof (pub runtime_types :: sp_trie :: storage_proof :: StorageProof ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum FraudProofStorageKeyRequest < _0 > { # [codec (index = 0)] InvalidInherentExtrinsicData , # [codec (index = 1)] SuccessfulBundles (runtime_types :: sp_domains :: DomainId ,) , # [codec (index = 2)] DomainAllowlistUpdates (runtime_types :: sp_domains :: DomainId ,) , # [codec (index = 3)] DomainRuntimeUpgrades , # [codec (index = 4)] RuntimeRegistry (:: core :: primitive :: u32 ,) , # [codec (index = 5)] DomainSudoCall (runtime_types :: sp_domains :: DomainId ,) , # [codec (index = 6)] EvmDomainContractCreationAllowedByCall (runtime_types :: sp_domains :: DomainId ,) , # [codec (index = 7)] MmrRoot (_0 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InherentExtrinsicData { pub extrinsics_shuffling_seed : runtime_types :: subspace_core_primitives :: Randomness , pub timestamp : :: core :: primitive :: u64 , pub consensus_transaction_byte_fee : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InvalidInherentExtrinsicDataProof (pub runtime_types :: sp_trie :: storage_proof :: StorageProof ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MaybeDomainRuntimeUpgradedProof { pub domain_runtime_upgrades : runtime_types :: sp_domains_fraud_proof :: storage_proof :: DomainRuntimeUpgradesProof , pub new_domain_runtime_code : :: core :: option :: Option < runtime_types :: sp_domains_fraud_proof :: storage_proof :: DomainRuntimeCodeProof > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MmrRootStorageProof < _0 > { pub storage_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _0 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OpaqueBundleWithProof < _0 , _1 , _2 , _3 > { pub bundle : runtime_types :: sp_domains :: Bundle < runtime_types :: sp_runtime :: OpaqueExtrinsic , _0 , _1 , _2 , _3 > , pub bundle_index : :: core :: primitive :: u32 , pub bundle_storage_proof : runtime_types :: sp_domains_fraud_proof :: storage_proof :: SuccessfulBundlesProof , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SuccessfulBundlesProof (pub runtime_types :: sp_trie :: storage_proof :: StorageProof ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum VerificationError { # [codec (index = 0)] InvalidBundleStorageProof , # [codec (index = 1)] RuntimeCodeNotFound , # [codec (index = 2)] UnexpectedDomainRuntimeUpgrade , # [codec (index = 3)] InvalidInherentExtrinsicStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 4)] SuccessfulBundlesStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 5)] DomainAllowlistUpdatesStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 6)] DomainRuntimeUpgradesStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 7)] RuntimeRegistryStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 8)] DigestStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 9)] BlockFeesStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 10)] TransfersStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 11)] ExtrinsicStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 12)] DomainSudoCallStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 13)] EvmDomainContractCreationAllowedByCallStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , # [codec (index = 14)] MmrRootStorageProof (runtime_types :: sp_domains :: proof_provider_and_verifier :: VerificationError ,) , } } } pub mod sp_inherents { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CheckInherentsResult { pub okay : :: core :: primitive :: bool , pub fatal_error : :: core :: primitive :: bool , pub errors : runtime_types :: sp_inherents :: InherentData , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct InherentData { pub data : :: subxt :: ext :: subxt_core :: utils :: KeyedVec < [:: core :: primitive :: u8 ; 8usize] , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , } } pub mod sp_messenger { use super :: runtime_types ; pub mod endpoint { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CollectedFee < _0 > { pub src_chain_fee : _0 , pub dst_chain_fee : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Endpoint { # [codec (index = 0)] Id (:: core :: primitive :: u64 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EndpointRequest { pub src_endpoint : runtime_types :: sp_messenger :: endpoint :: Endpoint , pub dst_endpoint : runtime_types :: sp_messenger :: endpoint :: Endpoint , pub payload : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EndpointRequestWithCollectedFee < _0 > { pub req : runtime_types :: sp_messenger :: endpoint :: EndpointRequest , pub collected_fee : runtime_types :: sp_messenger :: endpoint :: CollectedFee < _0 > , } } pub mod messages { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockMessageWithStorageKey { pub src_chain_id : runtime_types :: sp_domains :: ChainId , pub dst_chain_id : runtime_types :: sp_domains :: ChainId , pub channel_id : runtime_types :: primitive_types :: U256 , pub nonce : runtime_types :: primitive_types :: U256 , pub storage_key : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub weight_tag : runtime_types :: sp_messenger :: messages :: MessageWeightTag , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockMessagesQuery { pub chain_id : runtime_types :: sp_domains :: ChainId , pub channel_id : runtime_types :: primitive_types :: U256 , pub outbox_from : runtime_types :: primitive_types :: U256 , pub inbox_responses_from : runtime_types :: primitive_types :: U256 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockMessagesWithStorageKey { pub outbox : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_messenger :: messages :: BlockMessageWithStorageKey > , pub inbox_responses : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_messenger :: messages :: BlockMessageWithStorageKey > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Channel < _0 , _1 > { pub channel_id : runtime_types :: primitive_types :: U256 , pub state : runtime_types :: sp_messenger :: messages :: ChannelState , pub next_inbox_nonce : runtime_types :: primitive_types :: U256 , pub next_outbox_nonce : runtime_types :: primitive_types :: U256 , pub latest_response_received_message_nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , pub max_outgoing_messages : :: core :: primitive :: u32 , pub maybe_owner : :: core :: option :: Option < _1 > , pub channel_reserve_fee : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChannelOpenParamsV1 { pub max_outgoing_messages : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ChannelState { # [codec (index = 0)] Initiated , # [codec (index = 1)] Open , # [codec (index = 2)] Closed , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ChannelStateWithNonce { # [codec (index = 0)] Initiated , # [codec (index = 1)] Open , # [codec (index = 2)] Closed { next_outbox_nonce : runtime_types :: primitive_types :: U256 , next_inbox_nonce : runtime_types :: primitive_types :: U256 , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CrossDomainMessage < _0 , _1 , _2 > { pub src_chain_id : runtime_types :: sp_domains :: ChainId , pub dst_chain_id : runtime_types :: sp_domains :: ChainId , pub channel_id : runtime_types :: primitive_types :: U256 , pub nonce : runtime_types :: primitive_types :: U256 , pub proof : runtime_types :: sp_messenger :: messages :: Proof < _0 , _1 , _1 > , pub weight_tag : runtime_types :: sp_messenger :: messages :: MessageWeightTag , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _2 > } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Message < _0 > { pub src_chain_id : runtime_types :: sp_domains :: ChainId , pub dst_chain_id : runtime_types :: sp_domains :: ChainId , pub channel_id : runtime_types :: primitive_types :: U256 , pub nonce : runtime_types :: primitive_types :: U256 , pub payload : runtime_types :: sp_messenger :: messages :: VersionedPayload < _0 > , pub last_delivered_message_response_nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MessageNonceWithStorageKey { pub nonce : runtime_types :: primitive_types :: U256 , pub storage_key : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , pub weight_tag : runtime_types :: sp_messenger :: messages :: MessageWeightTag , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum MessageWeightTag { # [codec (index = 0)] ProtocolChannelOpen , # [codec (index = 1)] ProtocolChannelClose , # [codec (index = 2)] EndpointRequest (runtime_types :: sp_messenger :: endpoint :: Endpoint ,) , # [codec (index = 3)] EndpointResponse (runtime_types :: sp_messenger :: endpoint :: Endpoint ,) , # [codec (index = 4)] None , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct MessagesWithStorageKey { pub outbox : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_messenger :: messages :: MessageNonceWithStorageKey > , pub inbox_responses : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_messenger :: messages :: MessageNonceWithStorageKey > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum PayloadV1 < _0 > { # [codec (index = 0)] Protocol (runtime_types :: sp_messenger :: messages :: RequestResponse < runtime_types :: sp_messenger :: messages :: ProtocolMessageRequest < runtime_types :: sp_messenger :: messages :: ChannelOpenParamsV1 > , :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > > ,) , # [codec (index = 1)] Endpoint (runtime_types :: sp_messenger :: messages :: RequestResponse < runtime_types :: sp_messenger :: endpoint :: EndpointRequestWithCollectedFee < _0 > , :: core :: result :: Result < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: sp_runtime :: DispatchError > > ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Proof < _0 , _1 , _2 > { # [codec (index = 0)] Consensus { consensus_chain_mmr_proof : runtime_types :: sp_subspace_mmr :: ConsensusChainMmrLeafProof < _0 , _1 , _1 > , message_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , } , # [codec (index = 1)] Domain { consensus_chain_mmr_proof : runtime_types :: sp_subspace_mmr :: ConsensusChainMmrLeafProof < _0 , _1 , _1 > , domain_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , message_proof : runtime_types :: sp_trie :: storage_proof :: StorageProof , } , __Ignore (:: core :: marker :: PhantomData < _2 >) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ProtocolMessageRequest < _0 > { # [codec (index = 0)] ChannelOpen (_0 ,) , # [codec (index = 1)] ChannelClose , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RequestResponse < _0 , _1 > { # [codec (index = 0)] Request (_0 ,) , # [codec (index = 1)] Response (_1 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum VersionedPayload < _0 > { # [codec (index = 1)] V1 (runtime_types :: sp_messenger :: messages :: PayloadV1 < _0 > ,) , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChannelNonce { pub relay_msg_nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , pub relay_response_msg_nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum XdmId { # [codec (index = 0)] RelayMessage ((runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ,) , # [codec (index = 1)] RelayResponseMessage ((runtime_types :: sp_domains :: ChainId , runtime_types :: primitive_types :: U256 , runtime_types :: primitive_types :: U256 ,) ,) , } } pub mod sp_mmr_primitives { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct EncodableOpaqueLeaf (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Error { # [codec (index = 0)] InvalidNumericOp , # [codec (index = 1)] Push , # [codec (index = 2)] GetRoot , # [codec (index = 3)] Commit , # [codec (index = 4)] GenerateProof , # [codec (index = 5)] Verify , # [codec (index = 6)] LeafNotFound , # [codec (index = 7)] PalletNotIncluded , # [codec (index = 8)] InvalidLeafIndex , # [codec (index = 9)] InvalidBestKnownBlock , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct LeafProof < _0 > { pub leaf_indices : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u64 > , pub leaf_count : :: core :: primitive :: u64 , pub items : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _0 > , } } pub mod sp_runtime { use super :: runtime_types ; pub mod generic { use super :: runtime_types ; pub mod block { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Block < _0 , _1 > { pub header : _0 , pub extrinsics : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < _1 > , } } pub mod digest { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Digest { pub logs : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: sp_runtime :: generic :: digest :: DigestItem > , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum DigestItem { # [codec (index = 6)] PreRuntime ([:: core :: primitive :: u8 ; 4usize] , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 4)] Consensus ([:: core :: primitive :: u8 ; 4usize] , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 5)] Seal ([:: core :: primitive :: u8 ; 4usize] , :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 0)] Other (:: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 8)] RuntimeEnvironmentUpdated , } } pub mod era { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum Era { # [codec (index = 0)] Immortal , # [codec (index = 1)] Mortal1 (:: core :: primitive :: u8 ,) , # [codec (index = 2)] Mortal2 (:: core :: primitive :: u8 ,) , # [codec (index = 3)] Mortal3 (:: core :: primitive :: u8 ,) , # [codec (index = 4)] Mortal4 (:: core :: primitive :: u8 ,) , # [codec (index = 5)] Mortal5 (:: core :: primitive :: u8 ,) , # [codec (index = 6)] Mortal6 (:: core :: primitive :: u8 ,) , # [codec (index = 7)] Mortal7 (:: core :: primitive :: u8 ,) , # [codec (index = 8)] Mortal8 (:: core :: primitive :: u8 ,) , # [codec (index = 9)] Mortal9 (:: core :: primitive :: u8 ,) , # [codec (index = 10)] Mortal10 (:: core :: primitive :: u8 ,) , # [codec (index = 11)] Mortal11 (:: core :: primitive :: u8 ,) , # [codec (index = 12)] Mortal12 (:: core :: primitive :: u8 ,) , # [codec (index = 13)] Mortal13 (:: core :: primitive :: u8 ,) , # [codec (index = 14)] Mortal14 (:: core :: primitive :: u8 ,) , # [codec (index = 15)] Mortal15 (:: core :: primitive :: u8 ,) , # [codec (index = 16)] Mortal16 (:: core :: primitive :: u8 ,) , # [codec (index = 17)] Mortal17 (:: core :: primitive :: u8 ,) , # [codec (index = 18)] Mortal18 (:: core :: primitive :: u8 ,) , # [codec (index = 19)] Mortal19 (:: core :: primitive :: u8 ,) , # [codec (index = 20)] Mortal20 (:: core :: primitive :: u8 ,) , # [codec (index = 21)] Mortal21 (:: core :: primitive :: u8 ,) , # [codec (index = 22)] Mortal22 (:: core :: primitive :: u8 ,) , # [codec (index = 23)] Mortal23 (:: core :: primitive :: u8 ,) , # [codec (index = 24)] Mortal24 (:: core :: primitive :: u8 ,) , # [codec (index = 25)] Mortal25 (:: core :: primitive :: u8 ,) , # [codec (index = 26)] Mortal26 (:: core :: primitive :: u8 ,) , # [codec (index = 27)] Mortal27 (:: core :: primitive :: u8 ,) , # [codec (index = 28)] Mortal28 (:: core :: primitive :: u8 ,) , # [codec (index = 29)] Mortal29 (:: core :: primitive :: u8 ,) , # [codec (index = 30)] Mortal30 (:: core :: primitive :: u8 ,) , # [codec (index = 31)] Mortal31 (:: core :: primitive :: u8 ,) , # [codec (index = 32)] Mortal32 (:: core :: primitive :: u8 ,) , # [codec (index = 33)] Mortal33 (:: core :: primitive :: u8 ,) , # [codec (index = 34)] Mortal34 (:: core :: primitive :: u8 ,) , # [codec (index = 35)] Mortal35 (:: core :: primitive :: u8 ,) , # [codec (index = 36)] Mortal36 (:: core :: primitive :: u8 ,) , # [codec (index = 37)] Mortal37 (:: core :: primitive :: u8 ,) , # [codec (index = 38)] Mortal38 (:: core :: primitive :: u8 ,) , # [codec (index = 39)] Mortal39 (:: core :: primitive :: u8 ,) , # [codec (index = 40)] Mortal40 (:: core :: primitive :: u8 ,) , # [codec (index = 41)] Mortal41 (:: core :: primitive :: u8 ,) , # [codec (index = 42)] Mortal42 (:: core :: primitive :: u8 ,) , # [codec (index = 43)] Mortal43 (:: core :: primitive :: u8 ,) , # [codec (index = 44)] Mortal44 (:: core :: primitive :: u8 ,) , # [codec (index = 45)] Mortal45 (:: core :: primitive :: u8 ,) , # [codec (index = 46)] Mortal46 (:: core :: primitive :: u8 ,) , # [codec (index = 47)] Mortal47 (:: core :: primitive :: u8 ,) , # [codec (index = 48)] Mortal48 (:: core :: primitive :: u8 ,) , # [codec (index = 49)] Mortal49 (:: core :: primitive :: u8 ,) , # [codec (index = 50)] Mortal50 (:: core :: primitive :: u8 ,) , # [codec (index = 51)] Mortal51 (:: core :: primitive :: u8 ,) , # [codec (index = 52)] Mortal52 (:: core :: primitive :: u8 ,) , # [codec (index = 53)] Mortal53 (:: core :: primitive :: u8 ,) , # [codec (index = 54)] Mortal54 (:: core :: primitive :: u8 ,) , # [codec (index = 55)] Mortal55 (:: core :: primitive :: u8 ,) , # [codec (index = 56)] Mortal56 (:: core :: primitive :: u8 ,) , # [codec (index = 57)] Mortal57 (:: core :: primitive :: u8 ,) , # [codec (index = 58)] Mortal58 (:: core :: primitive :: u8 ,) , # [codec (index = 59)] Mortal59 (:: core :: primitive :: u8 ,) , # [codec (index = 60)] Mortal60 (:: core :: primitive :: u8 ,) , # [codec (index = 61)] Mortal61 (:: core :: primitive :: u8 ,) , # [codec (index = 62)] Mortal62 (:: core :: primitive :: u8 ,) , # [codec (index = 63)] Mortal63 (:: core :: primitive :: u8 ,) , # [codec (index = 64)] Mortal64 (:: core :: primitive :: u8 ,) , # [codec (index = 65)] Mortal65 (:: core :: primitive :: u8 ,) , # [codec (index = 66)] Mortal66 (:: core :: primitive :: u8 ,) , # [codec (index = 67)] Mortal67 (:: core :: primitive :: u8 ,) , # [codec (index = 68)] Mortal68 (:: core :: primitive :: u8 ,) , # [codec (index = 69)] Mortal69 (:: core :: primitive :: u8 ,) , # [codec (index = 70)] Mortal70 (:: core :: primitive :: u8 ,) , # [codec (index = 71)] Mortal71 (:: core :: primitive :: u8 ,) , # [codec (index = 72)] Mortal72 (:: core :: primitive :: u8 ,) , # [codec (index = 73)] Mortal73 (:: core :: primitive :: u8 ,) , # [codec (index = 74)] Mortal74 (:: core :: primitive :: u8 ,) , # [codec (index = 75)] Mortal75 (:: core :: primitive :: u8 ,) , # [codec (index = 76)] Mortal76 (:: core :: primitive :: u8 ,) , # [codec (index = 77)] Mortal77 (:: core :: primitive :: u8 ,) , # [codec (index = 78)] Mortal78 (:: core :: primitive :: u8 ,) , # [codec (index = 79)] Mortal79 (:: core :: primitive :: u8 ,) , # [codec (index = 80)] Mortal80 (:: core :: primitive :: u8 ,) , # [codec (index = 81)] Mortal81 (:: core :: primitive :: u8 ,) , # [codec (index = 82)] Mortal82 (:: core :: primitive :: u8 ,) , # [codec (index = 83)] Mortal83 (:: core :: primitive :: u8 ,) , # [codec (index = 84)] Mortal84 (:: core :: primitive :: u8 ,) , # [codec (index = 85)] Mortal85 (:: core :: primitive :: u8 ,) , # [codec (index = 86)] Mortal86 (:: core :: primitive :: u8 ,) , # [codec (index = 87)] Mortal87 (:: core :: primitive :: u8 ,) , # [codec (index = 88)] Mortal88 (:: core :: primitive :: u8 ,) , # [codec (index = 89)] Mortal89 (:: core :: primitive :: u8 ,) , # [codec (index = 90)] Mortal90 (:: core :: primitive :: u8 ,) , # [codec (index = 91)] Mortal91 (:: core :: primitive :: u8 ,) , # [codec (index = 92)] Mortal92 (:: core :: primitive :: u8 ,) , # [codec (index = 93)] Mortal93 (:: core :: primitive :: u8 ,) , # [codec (index = 94)] Mortal94 (:: core :: primitive :: u8 ,) , # [codec (index = 95)] Mortal95 (:: core :: primitive :: u8 ,) , # [codec (index = 96)] Mortal96 (:: core :: primitive :: u8 ,) , # [codec (index = 97)] Mortal97 (:: core :: primitive :: u8 ,) , # [codec (index = 98)] Mortal98 (:: core :: primitive :: u8 ,) , # [codec (index = 99)] Mortal99 (:: core :: primitive :: u8 ,) , # [codec (index = 100)] Mortal100 (:: core :: primitive :: u8 ,) , # [codec (index = 101)] Mortal101 (:: core :: primitive :: u8 ,) , # [codec (index = 102)] Mortal102 (:: core :: primitive :: u8 ,) , # [codec (index = 103)] Mortal103 (:: core :: primitive :: u8 ,) , # [codec (index = 104)] Mortal104 (:: core :: primitive :: u8 ,) , # [codec (index = 105)] Mortal105 (:: core :: primitive :: u8 ,) , # [codec (index = 106)] Mortal106 (:: core :: primitive :: u8 ,) , # [codec (index = 107)] Mortal107 (:: core :: primitive :: u8 ,) , # [codec (index = 108)] Mortal108 (:: core :: primitive :: u8 ,) , # [codec (index = 109)] Mortal109 (:: core :: primitive :: u8 ,) , # [codec (index = 110)] Mortal110 (:: core :: primitive :: u8 ,) , # [codec (index = 111)] Mortal111 (:: core :: primitive :: u8 ,) , # [codec (index = 112)] Mortal112 (:: core :: primitive :: u8 ,) , # [codec (index = 113)] Mortal113 (:: core :: primitive :: u8 ,) , # [codec (index = 114)] Mortal114 (:: core :: primitive :: u8 ,) , # [codec (index = 115)] Mortal115 (:: core :: primitive :: u8 ,) , # [codec (index = 116)] Mortal116 (:: core :: primitive :: u8 ,) , # [codec (index = 117)] Mortal117 (:: core :: primitive :: u8 ,) , # [codec (index = 118)] Mortal118 (:: core :: primitive :: u8 ,) , # [codec (index = 119)] Mortal119 (:: core :: primitive :: u8 ,) , # [codec (index = 120)] Mortal120 (:: core :: primitive :: u8 ,) , # [codec (index = 121)] Mortal121 (:: core :: primitive :: u8 ,) , # [codec (index = 122)] Mortal122 (:: core :: primitive :: u8 ,) , # [codec (index = 123)] Mortal123 (:: core :: primitive :: u8 ,) , # [codec (index = 124)] Mortal124 (:: core :: primitive :: u8 ,) , # [codec (index = 125)] Mortal125 (:: core :: primitive :: u8 ,) , # [codec (index = 126)] Mortal126 (:: core :: primitive :: u8 ,) , # [codec (index = 127)] Mortal127 (:: core :: primitive :: u8 ,) , # [codec (index = 128)] Mortal128 (:: core :: primitive :: u8 ,) , # [codec (index = 129)] Mortal129 (:: core :: primitive :: u8 ,) , # [codec (index = 130)] Mortal130 (:: core :: primitive :: u8 ,) , # [codec (index = 131)] Mortal131 (:: core :: primitive :: u8 ,) , # [codec (index = 132)] Mortal132 (:: core :: primitive :: u8 ,) , # [codec (index = 133)] Mortal133 (:: core :: primitive :: u8 ,) , # [codec (index = 134)] Mortal134 (:: core :: primitive :: u8 ,) , # [codec (index = 135)] Mortal135 (:: core :: primitive :: u8 ,) , # [codec (index = 136)] Mortal136 (:: core :: primitive :: u8 ,) , # [codec (index = 137)] Mortal137 (:: core :: primitive :: u8 ,) , # [codec (index = 138)] Mortal138 (:: core :: primitive :: u8 ,) , # [codec (index = 139)] Mortal139 (:: core :: primitive :: u8 ,) , # [codec (index = 140)] Mortal140 (:: core :: primitive :: u8 ,) , # [codec (index = 141)] Mortal141 (:: core :: primitive :: u8 ,) , # [codec (index = 142)] Mortal142 (:: core :: primitive :: u8 ,) , # [codec (index = 143)] Mortal143 (:: core :: primitive :: u8 ,) , # [codec (index = 144)] Mortal144 (:: core :: primitive :: u8 ,) , # [codec (index = 145)] Mortal145 (:: core :: primitive :: u8 ,) , # [codec (index = 146)] Mortal146 (:: core :: primitive :: u8 ,) , # [codec (index = 147)] Mortal147 (:: core :: primitive :: u8 ,) , # [codec (index = 148)] Mortal148 (:: core :: primitive :: u8 ,) , # [codec (index = 149)] Mortal149 (:: core :: primitive :: u8 ,) , # [codec (index = 150)] Mortal150 (:: core :: primitive :: u8 ,) , # [codec (index = 151)] Mortal151 (:: core :: primitive :: u8 ,) , # [codec (index = 152)] Mortal152 (:: core :: primitive :: u8 ,) , # [codec (index = 153)] Mortal153 (:: core :: primitive :: u8 ,) , # [codec (index = 154)] Mortal154 (:: core :: primitive :: u8 ,) , # [codec (index = 155)] Mortal155 (:: core :: primitive :: u8 ,) , # [codec (index = 156)] Mortal156 (:: core :: primitive :: u8 ,) , # [codec (index = 157)] Mortal157 (:: core :: primitive :: u8 ,) , # [codec (index = 158)] Mortal158 (:: core :: primitive :: u8 ,) , # [codec (index = 159)] Mortal159 (:: core :: primitive :: u8 ,) , # [codec (index = 160)] Mortal160 (:: core :: primitive :: u8 ,) , # [codec (index = 161)] Mortal161 (:: core :: primitive :: u8 ,) , # [codec (index = 162)] Mortal162 (:: core :: primitive :: u8 ,) , # [codec (index = 163)] Mortal163 (:: core :: primitive :: u8 ,) , # [codec (index = 164)] Mortal164 (:: core :: primitive :: u8 ,) , # [codec (index = 165)] Mortal165 (:: core :: primitive :: u8 ,) , # [codec (index = 166)] Mortal166 (:: core :: primitive :: u8 ,) , # [codec (index = 167)] Mortal167 (:: core :: primitive :: u8 ,) , # [codec (index = 168)] Mortal168 (:: core :: primitive :: u8 ,) , # [codec (index = 169)] Mortal169 (:: core :: primitive :: u8 ,) , # [codec (index = 170)] Mortal170 (:: core :: primitive :: u8 ,) , # [codec (index = 171)] Mortal171 (:: core :: primitive :: u8 ,) , # [codec (index = 172)] Mortal172 (:: core :: primitive :: u8 ,) , # [codec (index = 173)] Mortal173 (:: core :: primitive :: u8 ,) , # [codec (index = 174)] Mortal174 (:: core :: primitive :: u8 ,) , # [codec (index = 175)] Mortal175 (:: core :: primitive :: u8 ,) , # [codec (index = 176)] Mortal176 (:: core :: primitive :: u8 ,) , # [codec (index = 177)] Mortal177 (:: core :: primitive :: u8 ,) , # [codec (index = 178)] Mortal178 (:: core :: primitive :: u8 ,) , # [codec (index = 179)] Mortal179 (:: core :: primitive :: u8 ,) , # [codec (index = 180)] Mortal180 (:: core :: primitive :: u8 ,) , # [codec (index = 181)] Mortal181 (:: core :: primitive :: u8 ,) , # [codec (index = 182)] Mortal182 (:: core :: primitive :: u8 ,) , # [codec (index = 183)] Mortal183 (:: core :: primitive :: u8 ,) , # [codec (index = 184)] Mortal184 (:: core :: primitive :: u8 ,) , # [codec (index = 185)] Mortal185 (:: core :: primitive :: u8 ,) , # [codec (index = 186)] Mortal186 (:: core :: primitive :: u8 ,) , # [codec (index = 187)] Mortal187 (:: core :: primitive :: u8 ,) , # [codec (index = 188)] Mortal188 (:: core :: primitive :: u8 ,) , # [codec (index = 189)] Mortal189 (:: core :: primitive :: u8 ,) , # [codec (index = 190)] Mortal190 (:: core :: primitive :: u8 ,) , # [codec (index = 191)] Mortal191 (:: core :: primitive :: u8 ,) , # [codec (index = 192)] Mortal192 (:: core :: primitive :: u8 ,) , # [codec (index = 193)] Mortal193 (:: core :: primitive :: u8 ,) , # [codec (index = 194)] Mortal194 (:: core :: primitive :: u8 ,) , # [codec (index = 195)] Mortal195 (:: core :: primitive :: u8 ,) , # [codec (index = 196)] Mortal196 (:: core :: primitive :: u8 ,) , # [codec (index = 197)] Mortal197 (:: core :: primitive :: u8 ,) , # [codec (index = 198)] Mortal198 (:: core :: primitive :: u8 ,) , # [codec (index = 199)] Mortal199 (:: core :: primitive :: u8 ,) , # [codec (index = 200)] Mortal200 (:: core :: primitive :: u8 ,) , # [codec (index = 201)] Mortal201 (:: core :: primitive :: u8 ,) , # [codec (index = 202)] Mortal202 (:: core :: primitive :: u8 ,) , # [codec (index = 203)] Mortal203 (:: core :: primitive :: u8 ,) , # [codec (index = 204)] Mortal204 (:: core :: primitive :: u8 ,) , # [codec (index = 205)] Mortal205 (:: core :: primitive :: u8 ,) , # [codec (index = 206)] Mortal206 (:: core :: primitive :: u8 ,) , # [codec (index = 207)] Mortal207 (:: core :: primitive :: u8 ,) , # [codec (index = 208)] Mortal208 (:: core :: primitive :: u8 ,) , # [codec (index = 209)] Mortal209 (:: core :: primitive :: u8 ,) , # [codec (index = 210)] Mortal210 (:: core :: primitive :: u8 ,) , # [codec (index = 211)] Mortal211 (:: core :: primitive :: u8 ,) , # [codec (index = 212)] Mortal212 (:: core :: primitive :: u8 ,) , # [codec (index = 213)] Mortal213 (:: core :: primitive :: u8 ,) , # [codec (index = 214)] Mortal214 (:: core :: primitive :: u8 ,) , # [codec (index = 215)] Mortal215 (:: core :: primitive :: u8 ,) , # [codec (index = 216)] Mortal216 (:: core :: primitive :: u8 ,) , # [codec (index = 217)] Mortal217 (:: core :: primitive :: u8 ,) , # [codec (index = 218)] Mortal218 (:: core :: primitive :: u8 ,) , # [codec (index = 219)] Mortal219 (:: core :: primitive :: u8 ,) , # [codec (index = 220)] Mortal220 (:: core :: primitive :: u8 ,) , # [codec (index = 221)] Mortal221 (:: core :: primitive :: u8 ,) , # [codec (index = 222)] Mortal222 (:: core :: primitive :: u8 ,) , # [codec (index = 223)] Mortal223 (:: core :: primitive :: u8 ,) , # [codec (index = 224)] Mortal224 (:: core :: primitive :: u8 ,) , # [codec (index = 225)] Mortal225 (:: core :: primitive :: u8 ,) , # [codec (index = 226)] Mortal226 (:: core :: primitive :: u8 ,) , # [codec (index = 227)] Mortal227 (:: core :: primitive :: u8 ,) , # [codec (index = 228)] Mortal228 (:: core :: primitive :: u8 ,) , # [codec (index = 229)] Mortal229 (:: core :: primitive :: u8 ,) , # [codec (index = 230)] Mortal230 (:: core :: primitive :: u8 ,) , # [codec (index = 231)] Mortal231 (:: core :: primitive :: u8 ,) , # [codec (index = 232)] Mortal232 (:: core :: primitive :: u8 ,) , # [codec (index = 233)] Mortal233 (:: core :: primitive :: u8 ,) , # [codec (index = 234)] Mortal234 (:: core :: primitive :: u8 ,) , # [codec (index = 235)] Mortal235 (:: core :: primitive :: u8 ,) , # [codec (index = 236)] Mortal236 (:: core :: primitive :: u8 ,) , # [codec (index = 237)] Mortal237 (:: core :: primitive :: u8 ,) , # [codec (index = 238)] Mortal238 (:: core :: primitive :: u8 ,) , # [codec (index = 239)] Mortal239 (:: core :: primitive :: u8 ,) , # [codec (index = 240)] Mortal240 (:: core :: primitive :: u8 ,) , # [codec (index = 241)] Mortal241 (:: core :: primitive :: u8 ,) , # [codec (index = 242)] Mortal242 (:: core :: primitive :: u8 ,) , # [codec (index = 243)] Mortal243 (:: core :: primitive :: u8 ,) , # [codec (index = 244)] Mortal244 (:: core :: primitive :: u8 ,) , # [codec (index = 245)] Mortal245 (:: core :: primitive :: u8 ,) , # [codec (index = 246)] Mortal246 (:: core :: primitive :: u8 ,) , # [codec (index = 247)] Mortal247 (:: core :: primitive :: u8 ,) , # [codec (index = 248)] Mortal248 (:: core :: primitive :: u8 ,) , # [codec (index = 249)] Mortal249 (:: core :: primitive :: u8 ,) , # [codec (index = 250)] Mortal250 (:: core :: primitive :: u8 ,) , # [codec (index = 251)] Mortal251 (:: core :: primitive :: u8 ,) , # [codec (index = 252)] Mortal252 (:: core :: primitive :: u8 ,) , # [codec (index = 253)] Mortal253 (:: core :: primitive :: u8 ,) , # [codec (index = 254)] Mortal254 (:: core :: primitive :: u8 ,) , # [codec (index = 255)] Mortal255 (:: core :: primitive :: u8 ,) , } } pub mod header { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Header < _0 > { pub parent_hash : :: subxt :: ext :: subxt_core :: utils :: H256 , # [codec (compact)] pub number : _0 , pub state_root : :: subxt :: ext :: subxt_core :: utils :: H256 , pub extrinsics_root : :: subxt :: ext :: subxt_core :: utils :: H256 , pub digest : runtime_types :: sp_runtime :: generic :: digest :: Digest , } } } pub mod proving_trie { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TrieError { # [codec (index = 0)] InvalidStateRoot , # [codec (index = 1)] IncompleteDatabase , # [codec (index = 2)] ValueAtIncompleteKey , # [codec (index = 3)] DecoderError , # [codec (index = 4)] InvalidHash , # [codec (index = 5)] DuplicateKey , # [codec (index = 6)] ExtraneousNode , # [codec (index = 7)] ExtraneousValue , # [codec (index = 8)] ExtraneousHashReference , # [codec (index = 9)] InvalidChildReference , # [codec (index = 10)] ValueMismatch , # [codec (index = 11)] IncompleteProof , # [codec (index = 12)] RootMismatch , # [codec (index = 13)] DecodeError , } } pub mod traits { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlakeTwo256 ; } pub mod transaction_validity { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum InvalidTransaction { # [codec (index = 0)] Call , # [codec (index = 1)] Payment , # [codec (index = 2)] Future , # [codec (index = 3)] Stale , # [codec (index = 4)] BadProof , # [codec (index = 5)] AncientBirthBlock , # [codec (index = 6)] ExhaustsResources , # [codec (index = 7)] Custom (:: core :: primitive :: u8 ,) , # [codec (index = 8)] BadMandatory , # [codec (index = 9)] MandatoryValidation , # [codec (index = 10)] BadSigner , # [codec (index = 11)] IndeterminateImplicit , # [codec (index = 12)] UnknownOrigin , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TransactionSource { # [codec (index = 0)] InBlock , # [codec (index = 1)] Local , # [codec (index = 2)] External , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TransactionValidityError { # [codec (index = 0)] Invalid (runtime_types :: sp_runtime :: transaction_validity :: InvalidTransaction ,) , # [codec (index = 1)] Unknown (runtime_types :: sp_runtime :: transaction_validity :: UnknownTransaction ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum UnknownTransaction { # [codec (index = 0)] CannotLookup , # [codec (index = 1)] NoUnsignedValidator , # [codec (index = 2)] Custom (:: core :: primitive :: u8 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ValidTransaction { pub priority : :: core :: primitive :: u64 , pub requires : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , pub provides : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , pub longevity : :: core :: primitive :: u64 , pub propagate : :: core :: primitive :: bool , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum DispatchError { # [codec (index = 0)] Other , # [codec (index = 1)] CannotLookup , # [codec (index = 2)] BadOrigin , # [codec (index = 3)] Module (runtime_types :: sp_runtime :: ModuleError ,) , # [codec (index = 4)] ConsumerRemaining , # [codec (index = 5)] NoProviders , # [codec (index = 6)] TooManyConsumers , # [codec (index = 7)] Token (runtime_types :: sp_runtime :: TokenError ,) , # [codec (index = 8)] Arithmetic (runtime_types :: sp_arithmetic :: ArithmeticError ,) , # [codec (index = 9)] Transactional (runtime_types :: sp_runtime :: TransactionalError ,) , # [codec (index = 10)] Exhausted , # [codec (index = 11)] Corruption , # [codec (index = 12)] Unavailable , # [codec (index = 13)] RootNotAllowed , # [codec (index = 14)] Trie (runtime_types :: sp_runtime :: proving_trie :: TrieError ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ExtrinsicInclusionMode { # [codec (index = 0)] AllExtrinsics , # [codec (index = 1)] OnlyInherents , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ModuleError { pub index : :: core :: primitive :: u8 , pub error : [:: core :: primitive :: u8 ; 4usize] , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum MultiSignature { # [codec (index = 0)] Ed25519 ([:: core :: primitive :: u8 ; 64usize] ,) , # [codec (index = 1)] Sr25519 ([:: core :: primitive :: u8 ; 64usize] ,) , # [codec (index = 2)] Ecdsa ([:: core :: primitive :: u8 ; 65usize] ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct OpaqueExtrinsic (pub :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TokenError { # [codec (index = 0)] FundsUnavailable , # [codec (index = 1)] OnlyProvider , # [codec (index = 2)] BelowMinimum , # [codec (index = 3)] CannotCreate , # [codec (index = 4)] UnknownAsset , # [codec (index = 5)] Frozen , # [codec (index = 6)] Unsupported , # [codec (index = 7)] CannotCreateHold , # [codec (index = 8)] NotExpendable , # [codec (index = 9)] Blocked , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum TransactionalError { # [codec (index = 0)] LimitReached , # [codec (index = 1)] NoLayer , } } pub mod sp_subspace_mmr { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ConsensusChainMmrLeafProof < _0 , _1 , _2 > { pub consensus_block_number : _0 , pub consensus_block_hash : _1 , pub opaque_mmr_leaf : runtime_types :: sp_mmr_primitives :: EncodableOpaqueLeaf , pub proof : runtime_types :: sp_mmr_primitives :: LeafProof < _1 > , # [codec (skip)] pub __ignore : :: core :: marker :: PhantomData < _2 > } } pub mod sp_trie { use super :: runtime_types ; pub mod storage_proof { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct StorageProof { pub trie_nodes : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < :: core :: primitive :: u8 > > , } } } pub mod sp_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeVersion { pub spec_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , pub impl_name : :: subxt :: ext :: subxt_core :: alloc :: string :: String , pub authoring_version : :: core :: primitive :: u32 , pub spec_version : :: core :: primitive :: u32 , pub impl_version : :: core :: primitive :: u32 , pub apis : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < ([:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u32 ,) > , pub transaction_version : :: core :: primitive :: u32 , pub system_version : :: core :: primitive :: u8 , } } pub mod sp_weights { use super :: runtime_types ; pub mod weight_v2 { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Weight { # [codec (compact)] pub ref_time : :: core :: primitive :: u64 , # [codec (compact)] pub proof_size : :: core :: primitive :: u64 , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RuntimeDbWeight { pub read : :: core :: primitive :: u64 , pub write : :: core :: primitive :: u64 , } } pub mod subspace_core_primitives { use super :: runtime_types ; pub mod hashes { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Blake3Hash (pub [:: core :: primitive :: u8 ; 32usize] ,) ; } pub mod objects { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockObject { pub hash : runtime_types :: subspace_core_primitives :: hashes :: Blake3Hash , pub offset : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum BlockObjectMapping { # [codec (index = 0)] V0 { objects : :: subxt :: ext :: subxt_core :: alloc :: vec :: Vec < runtime_types :: subspace_core_primitives :: objects :: BlockObject > , } , } } pub mod pieces { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PieceOffset (pub :: core :: primitive :: u16 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RecordCommitment (pub [:: core :: primitive :: u8 ; 48usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RecordWitness (pub [:: core :: primitive :: u8 ; 48usize] ,) ; } pub mod pos { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PosProof (pub [:: core :: primitive :: u8 ; 160usize] ,) ; } pub mod pot { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PotOutput (pub [:: core :: primitive :: u8 ; 16usize] ,) ; } pub mod private_u256 { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct U256 (pub [:: core :: primitive :: u64 ; 4usize] ,) ; } pub mod segments { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum ArchivedBlockProgress { # [codec (index = 0)] Complete , # [codec (index = 1)] Partial (:: core :: primitive :: u32 ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct HistorySize (pub :: core :: num :: NonZeroU64 ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct LastArchivedBlock { pub number : :: core :: primitive :: u32 , pub archived_progress : runtime_types :: subspace_core_primitives :: segments :: ArchivedBlockProgress , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SegmentCommitment (pub [:: core :: primitive :: u8 ; 48usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum SegmentHeader { # [codec (index = 0)] V0 { segment_index : runtime_types :: subspace_core_primitives :: segments :: SegmentIndex , segment_commitment : runtime_types :: subspace_core_primitives :: segments :: SegmentCommitment , prev_segment_header_hash : runtime_types :: subspace_core_primitives :: hashes :: Blake3Hash , last_archived_block : runtime_types :: subspace_core_primitives :: segments :: LastArchivedBlock , } , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct SegmentIndex (pub :: core :: primitive :: u64 ,) ; } pub mod solutions { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ChunkWitness (pub [:: core :: primitive :: u8 ; 48usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct RewardSignature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Solution < _0 > { pub public_key : runtime_types :: subspace_core_primitives :: PublicKey , pub reward_address : _0 , pub sector_index : :: core :: primitive :: u16 , pub history_size : runtime_types :: subspace_core_primitives :: segments :: HistorySize , pub piece_offset : runtime_types :: subspace_core_primitives :: pieces :: PieceOffset , pub record_commitment : runtime_types :: subspace_core_primitives :: pieces :: RecordCommitment , pub record_witness : runtime_types :: subspace_core_primitives :: pieces :: RecordWitness , pub chunk : runtime_types :: subspace_core_primitives :: ScalarBytes , pub chunk_witness : runtime_types :: subspace_core_primitives :: solutions :: ChunkWitness , pub proof_of_space : runtime_types :: subspace_core_primitives :: pos :: PosProof , } } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct PublicKey (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Randomness (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct ScalarBytes (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct U256 (pub runtime_types :: subspace_core_primitives :: private_u256 :: U256 ,) ; } pub mod subspace_runtime { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct HoldIdentifierWrapper (pub runtime_types :: subspace_runtime_primitives :: HoldIdentifier ,) ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum OriginCaller { # [codec (index = 0)] system (runtime_types :: frame_support :: dispatch :: RawOrigin < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ,) , # [codec (index = 2)] Subspace (runtime_types :: pallet_subspace :: RawOrigin ,) , # [codec (index = 12)] Domains (runtime_types :: pallet_domains :: RawOrigin ,) , # [codec (index = 60)] Messenger (runtime_types :: pallet_messenger :: RawOrigin ,) , # [codec (index = 82)] Council (runtime_types :: pallet_collective :: RawOrigin < :: subxt :: ext :: subxt_core :: utils :: AccountId32 > ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct Runtime ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeCall { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Call ,) , # [codec (index = 1)] Timestamp (runtime_types :: pallet_timestamp :: pallet :: Call ,) , # [codec (index = 2)] Subspace (runtime_types :: pallet_subspace :: pallet :: Call ,) , # [codec (index = 4)] Rewards (runtime_types :: pallet_rewards :: pallet :: Call ,) , # [codec (index = 5)] Balances (runtime_types :: pallet_balances :: pallet :: Call ,) , # [codec (index = 8)] Utility (runtime_types :: pallet_utility :: pallet :: Call ,) , # [codec (index = 12)] Domains (runtime_types :: pallet_domains :: pallet :: Call ,) , # [codec (index = 14)] RuntimeConfigs (runtime_types :: pallet_runtime_configs :: pallet :: Call ,) , # [codec (index = 60)] Messenger (runtime_types :: pallet_messenger :: pallet :: Call ,) , # [codec (index = 61)] Transporter (runtime_types :: pallet_transporter :: pallet :: Call ,) , # [codec (index = 81)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Call ,) , # [codec (index = 82)] Council (runtime_types :: pallet_collective :: pallet :: Call ,) , # [codec (index = 83)] Democracy (runtime_types :: pallet_democracy :: pallet :: Call ,) , # [codec (index = 84)] Preimage (runtime_types :: pallet_preimage :: pallet :: Call ,) , # [codec (index = 90)] Multisig (runtime_types :: pallet_multisig :: pallet :: Call ,) , # [codec (index = 100)] Sudo (runtime_types :: pallet_sudo :: pallet :: Call ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeError { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Error ,) , # [codec (index = 2)] Subspace (runtime_types :: pallet_subspace :: pallet :: Error ,) , # [codec (index = 5)] Balances (runtime_types :: pallet_balances :: pallet :: Error ,) , # [codec (index = 8)] Utility (runtime_types :: pallet_utility :: pallet :: Error ,) , # [codec (index = 12)] Domains (runtime_types :: pallet_domains :: pallet :: Error ,) , # [codec (index = 60)] Messenger (runtime_types :: pallet_messenger :: pallet :: Error ,) , # [codec (index = 61)] Transporter (runtime_types :: pallet_transporter :: pallet :: Error ,) , # [codec (index = 81)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Error ,) , # [codec (index = 82)] Council (runtime_types :: pallet_collective :: pallet :: Error ,) , # [codec (index = 83)] Democracy (runtime_types :: pallet_democracy :: pallet :: Error ,) , # [codec (index = 84)] Preimage (runtime_types :: pallet_preimage :: pallet :: Error ,) , # [codec (index = 90)] Multisig (runtime_types :: pallet_multisig :: pallet :: Error ,) , # [codec (index = 100)] Sudo (runtime_types :: pallet_sudo :: pallet :: Error ,) , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum RuntimeEvent { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Event ,) , # [codec (index = 2)] Subspace (runtime_types :: pallet_subspace :: pallet :: Event ,) , # [codec (index = 4)] Rewards (runtime_types :: pallet_rewards :: pallet :: Event ,) , # [codec (index = 5)] Balances (runtime_types :: pallet_balances :: pallet :: Event ,) , # [codec (index = 6)] TransactionFees (runtime_types :: pallet_transaction_fees :: pallet :: Event ,) , # [codec (index = 7)] TransactionPayment (runtime_types :: pallet_transaction_payment :: pallet :: Event ,) , # [codec (index = 8)] Utility (runtime_types :: pallet_utility :: pallet :: Event ,) , # [codec (index = 12)] Domains (runtime_types :: pallet_domains :: pallet :: Event ,) , # [codec (index = 60)] Messenger (runtime_types :: pallet_messenger :: pallet :: Event ,) , # [codec (index = 61)] Transporter (runtime_types :: pallet_transporter :: pallet :: Event ,) , # [codec (index = 81)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Event ,) , # [codec (index = 82)] Council (runtime_types :: pallet_collective :: pallet :: Event ,) , # [codec (index = 83)] Democracy (runtime_types :: pallet_democracy :: pallet :: Event ,) , # [codec (index = 84)] Preimage (runtime_types :: pallet_preimage :: pallet :: Event ,) , # [codec (index = 90)] Multisig (runtime_types :: pallet_multisig :: pallet :: Event ,) , # [codec (index = 100)] Sudo (runtime_types :: pallet_sudo :: pallet :: Event ,) , } } pub mod subspace_runtime_primitives { use super :: runtime_types ; pub mod extension { use super :: runtime_types ; # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BalanceTransferCheckExtension < _0 > (pub :: core :: marker :: PhantomData < _0 >) ; } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct BlockTransactionByteFee < _0 > { pub current : _0 , pub next : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub struct CouncilDemocracyConfigParams < _0 > { pub council_motion_duration : _0 , pub democracy_cooloff_period : _0 , pub democracy_enactment_period : _0 , pub democracy_fast_track_voting_period : _0 , pub democracy_launch_period : _0 , pub democracy_vote_locking_period : _0 , pub democracy_voting_period : _0 , } # [derive (:: subxt :: ext :: subxt_core :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: subxt_core :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: subxt_core :: ext :: scale_encode")] pub enum HoldIdentifier { # [codec (index = 0)] DomainStaking , # [codec (index = 1)] DomainInstantiation , # [codec (index = 2)] DomainStorageFund , # [codec (index = 3)] MessengerChannel , # [codec (index = 4)] Preimage , } } } }
